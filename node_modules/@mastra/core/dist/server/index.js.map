{"version":3,"sources":["../../src/server/auth.ts","../../src/server/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,KAAA,CAAA;AASA,IAAA,IAAA,OAAA,EAAA,aAAA,EAAA;AAAiB,MACf,IAAQ,CAAA,aAAA,GAAA,OAAA,CAAA,aAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AAAA,IACR;AACF,EAAC;AACM,EAAA,eAAe,CAAA,IAAA,EAAA;AAAuD,cAC/D,aAA4C,EAAA;AACtD,MAAA,IAAM,cAAa,GAAA,IAAQ,CAAA,aAAM,CAAS,KAAK,IAAC,CAAA;AAEhD,IAAA;AACE,EAAA;AAAoD;AACtD,kBACF,gBAAA,CAAA,CAAA,IAAA;AAAA,EAkBU,wBAAyD,CAAA,EAAA,CAAA;AACjE,EAAA,kBAAU,GAAA,iBAAe,CAAA,KAAA,EAAA,CAAA,EAAA,oBAAA,EAAA,8BAAA,EAAA,kBAAA,CAAA;AACvB,EAAA,iBAAK,CAAA,KAAA,EAAgB,CAAA,EAAA,kBAAmB,CAAA;;AAC1C;AAEJ,EAAA,OAAA,kBAAA;AA9BO,CAAA,EAAA;AAAe;AAAf,SAAA,eAAA,CAAA,IAAe,EAAA,OAAA,EAAA;;;ACgCtB,IAAA,MAAS,IAAA,WACP;AAGA,MAAA,EAAM,EAAA,yCAAO;AAEb,MAAI,IAAA,8BAA2B,EAAA,IAAA,CAAA,4BAAA,CAAA;AAC7B,MAAA,QAAU,eAAY;AAAA,MACpB,QAAI,EAAA,MAAA;AAAA,KAAA,CACJ;AAAwC,EAAA;AACxC,EAAA,IACA,IAAA,CAAA,OAAA,KAAA,MAAA,IAAA,IAAA,CAAA,aAAA,KAAA,MAAA,EAAA;AAAA,IACF,MAAC,IAAA,WAAA,CAAA;AAAA,MACH,EAAA,EAAA,yCAAA;AAEA,MAAI,IAAA,EAAK,CAAA,4FAA2D,CAAA;AAClE,MAAA,QAAU,eAAY;AAAA,MACpB,QAAI,EAAA,MAAA;AAAA,KAAA,CACJ;AAAwC,EAAA;AACxC,EAAA,IACA,IAAA,CAAA,OAAA,KAAA,MAAA,IAAA,IAAA,CAAA,aAAA,KAAA,MAAA,EAAA;AAAA,IACF,MAAC,IAAA,WAAA,CAAA;AAAA,MACH,EAAA,EAAA,yCAAA;AAEA,MAAI,IAAA,EAAK,CAAA,sHAA2D,CAAA;AAClE,MAAA,QAAU,eAAY;AAAA,MACpB,QAAI,EAAA,MAAA;AAAA,KAAA,CACJ;AAAwC,EAAA;AACxC;AACA,SACD,gBAAA,CAAA,IAAA,EAAA,OAAA,EAAA;AAAA,EACH,IAAA,IAAA,CAAA,UAAA,CAAA,OAAA,CAAA,EAAA;AACF,IAAA,MAAA,IAAA,WAAA,CAAA;AAEO,MAAA,EAAA,EAAS,iCAGa;AAC3B,MAAI,IAAA,EAAK,CAAA,sEAAqB,CAAA;AAC5B,MAAA,QAAU,eAAY;AAAA,MACpB,QAAI,EAAA,MAAA;AAAA,KAAA,CACJ;AAAM,EAAA;AACN,EAAA,eACA,CAAA,IAAA,EAAA,OAAA,CAAA;AAAA,EAAA,OACD;AAAA,IACH,IAAA;AAEA,IAAA,MAAA,EAAA,cAAsB;AAEtB,IAAA,OAAO,EAAA,OAAA,CAAA,OAAA;AAAA,IACL,aAAA,EAAA,OAAA,CAAA,aAAA;AAAA,IACA,SAAQ,OAAQ,CAAA,OAAA;AAAA,IAChB,UAAS,EAAA,OAAQ,CAAA;AAAA,GAAA;AACM;AACN,mBACL,CAAA,MAAQ,EAAA;AAAA,EACtB,OAAA,MAAA;AACF","file":"index.js","sourcesContent":["import type { HonoRequest } from 'hono';\nimport { MastraBase } from '../base';\nimport { InstrumentClass } from '../telemetry';\n\nexport interface MastraAuthProviderOptions<TUser = unknown> {\n  name?: string;\n  authorizeUser?: (user: TUser, request: HonoRequest) => Promise<boolean> | boolean;\n}\n\n@InstrumentClass({\n  prefix: 'auth',\n  excludeMethods: ['__setTools', '__setLogger', '__setTelemetry', '#log'],\n})\nexport abstract class MastraAuthProvider<TUser = unknown> extends MastraBase {\n  constructor(options?: MastraAuthProviderOptions<TUser>) {\n    super({ component: 'AUTH', name: options?.name });\n\n    if (options?.authorizeUser) {\n      this.authorizeUser = options.authorizeUser.bind(this);\n    }\n  }\n\n  /**\n   * Authenticate a token and return the payload\n   * @param token - The token to authenticate\n   * @param request - The request\n   * @returns The payload\n   */\n  abstract authenticateToken(token: string, request: HonoRequest): Promise<TUser | null>;\n\n  /**\n   * Authorize a user for a path and method\n   * @param user - The user to authorize\n   * @param request - The request\n   * @returns The authorization result\n   */\n  abstract authorizeUser(user: TUser, request: HonoRequest): Promise<boolean> | boolean;\n\n  protected registerOptions(opts?: MastraAuthProviderOptions<TUser>) {\n    if (opts?.authorizeUser) {\n      this.authorizeUser = opts.authorizeUser.bind(this);\n    }\n  }\n}\n","import type { Context, Handler, MiddlewareHandler } from 'hono';\nimport type { DescribeRouteOptions } from 'hono-openapi';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { Mastra } from '../mastra';\nimport type { ApiRoute, MastraAuthConfig, Methods } from './types';\n\nexport type { MastraAuthConfig, ContextWithMastra, ApiRoute } from './types';\nexport { MastraAuthProvider } from './auth';\nexport type { MastraAuthProviderOptions } from './auth';\n\n// Helper type for inferring parameters from a path\n// Thank you Claude!\ntype ParamsFromPath<P extends string> = {\n  [K in P extends `${string}:${infer Param}/${string}` | `${string}:${infer Param}` ? Param : never]: string;\n};\n\ntype RegisterApiRoutePathError = `Param 'path' must not start with '/api', it is reserved for internal API routes.`;\ntype ValidatePath<P extends string, T> = P extends `/api/${string}` ? RegisterApiRoutePathError : T;\n\ntype RegisterApiRouteOptions<P extends string> = {\n  method: Methods;\n  openapi?: DescribeRouteOptions;\n  handler?: Handler<\n    {\n      Variables: {\n        mastra: Mastra;\n      };\n    },\n    P,\n    ParamsFromPath<P>\n  >;\n  createHandler?: (c: Context) => Promise<\n    Handler<\n      {\n        Variables: {\n          mastra: Mastra;\n        };\n      },\n      P,\n      ParamsFromPath<P>\n    >\n  >;\n  middleware?: MiddlewareHandler | MiddlewareHandler[];\n};\n\nfunction validateOptions<P extends string>(\n  path: P,\n  options: RegisterApiRoutePathError | RegisterApiRouteOptions<P>,\n): asserts options is RegisterApiRouteOptions<P> {\n  const opts = options as RegisterApiRouteOptions<P>;\n\n  if (opts.method === undefined) {\n    throw new MastraError({\n      id: 'MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS',\n      text: `Invalid options for route \"${path}\", missing \"method\" property`,\n      domain: ErrorDomain.MASTRA_SERVER,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  if (opts.handler === undefined && opts.createHandler === undefined) {\n    throw new MastraError({\n      id: 'MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS',\n      text: `Invalid options for route \"${path}\", you must define a \"handler\" or \"createHandler\" property`,\n      domain: ErrorDomain.MASTRA_SERVER,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  if (opts.handler !== undefined && opts.createHandler !== undefined) {\n    throw new MastraError({\n      id: 'MASTRA_SERVER_API_INVALID_ROUTE_OPTIONS',\n      text: `Invalid options for route \"${path}\", you can only define one of the following properties: \"handler\" or \"createHandler\"`,\n      domain: ErrorDomain.MASTRA_SERVER,\n      category: ErrorCategory.USER,\n    });\n  }\n}\n\nexport function registerApiRoute<P extends string>(\n  path: P,\n  options: ValidatePath<P, RegisterApiRouteOptions<P>>,\n): ValidatePath<P, ApiRoute> {\n  if (path.startsWith('/api/')) {\n    throw new MastraError({\n      id: 'MASTRA_SERVER_API_PATH_RESERVED',\n      text: 'Path must not start with \"/api\", it\\'s reserved for internal API routes',\n      domain: ErrorDomain.MASTRA_SERVER,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  validateOptions(path, options);\n\n  return {\n    path,\n    method: options.method,\n    handler: options.handler,\n    createHandler: options.createHandler,\n    openapi: options.openapi,\n    middleware: options.middleware,\n  } as unknown as ValidatePath<P, ApiRoute>;\n}\n\nexport function defineAuth<TUser>(config: MastraAuthConfig<TUser>): MastraAuthConfig<TUser> {\n  return config;\n}\n"]}