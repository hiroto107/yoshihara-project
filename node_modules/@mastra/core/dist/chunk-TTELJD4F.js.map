{"version":3,"sources":["../src/hooks/mitt.ts","../src/hooks/index.ts"],"names":["AvailableHooks"],"mappings":";AAqCe,SAAR,KACL,GAAA,EACiB;AAEjB,EAAA,GAAA,GAAM,GAAA,wBAAW,GAAA,EAAI;AAErB,EAAA,OAAO;AAAA;AAAA;AAAA;AAAA,IAIL,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,EAAA,CAA6B,MAAW,OAAA,EAA8B;AACpE,MAAA,MAAM,QAAA,GAAmD,GAAA,CAAK,GAAA,CAAI,IAAI,CAAA;AACtE,MAAA,IAAI,QAAA,EAAU;AACZ,QAAA,QAAA,CAAS,KAAK,OAAO,CAAA;AAAA,MACvB,CAAA,MAAO;AACL,QAAA,GAAA,CAAK,GAAA,CAAI,IAAA,EAAM,CAAC,OAAO,CAA2C,CAAA;AAAA,MACpE;AAAA,IACF,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASA,GAAA,CAA8B,MAAW,OAAA,EAA+B;AACtE,MAAA,MAAM,QAAA,GAAmD,GAAA,CAAK,GAAA,CAAI,IAAI,CAAA;AACtE,MAAA,IAAI,QAAA,EAAU;AACZ,QAAA,IAAI,OAAA,EAAS;AACX,UAAA,QAAA,CAAS,OAAO,QAAA,CAAS,OAAA,CAAQ,OAAO,CAAA,KAAM,GAAG,CAAC,CAAA;AAAA,QACpD,CAAA,MAAO;AACL,UAAA,GAAA,CAAK,GAAA,CAAI,IAAA,EAAM,EAAE,CAAA;AAAA,QACnB;AAAA,MACF;AAAA,IACF,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,IAAA,CAA+B,MAAW,GAAA,EAAmB;AAC3D,MAAA,IAAI,QAAA,GAAW,GAAA,CAAK,GAAA,CAAI,IAAI,CAAA;AAC5B,MAAA,IAAI,QAAA,EAAU;AACZ,QAAC,QAAA,CAAoD,KAAA,EAAM,CAAE,GAAA,CAAI,CAAA,OAAA,KAAW;AAC1E,UAAA,OAAA,CAAQ,GAAI,CAAA;AAAA,QACd,CAAC,CAAA;AAAA,MACH;AAEA,MAAA,QAAA,GAAW,GAAA,CAAK,IAAI,GAAG,CAAA;AACvB,MAAA,IAAI,QAAA,EAAU;AACZ,QAAC,QAAA,CAA8C,KAAA,EAAM,CAAE,GAAA,CAAI,CAAA,OAAA,KAAW;AACpE,UAAA,OAAA,CAAQ,MAAM,GAAI,CAAA;AAAA,QACpB,CAAC,CAAA;AAAA,MACH;AAAA,IACF;AAAA,GACF;AACF;;;ACrGO,IAAK,cAAA,qBAAAA,eAAAA,KAAL;AACL,EAAAA,gBAAA,eAAA,CAAA,GAAgB,cAAA;AAChB,EAAAA,gBAAA,eAAA,CAAA,GAAgB,cAAA;AAChB,EAAAA,gBAAA,eAAA,CAAA,GAAgB,aAAA;AAHN,EAAA,OAAAA,eAAAA;AAAA,CAAA,EAAA,cAAA,IAAA,EAAA;AAMZ,IAAM,QAAQ,IAAA,EAAK;AA0BZ,SAAS,YAAA,CAAa,MAA2B,MAAA,EAA4B;AAClF,EAAA,KAAA,CAAM,EAAA,CAAG,MAAM,MAAM,CAAA;AACvB;AAKO,SAAS,WAAA,CAAY,MAA2B,IAAA,EAAqB;AAE1E,EAAA,YAAA,CAAa,MAAM;AACjB,IAAA,KAAA,CAAM,IAAA,CAAK,MAAM,IAAI,CAAA;AAAA,EACvB,CAAC,CAAA;AACH","file":"chunk-TTELJD4F.js","sourcesContent":["// copied from https://github.com/developit/mitt\n\nexport type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (type: keyof T, event: T[keyof T]) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<WildcardHandler<T>>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n  keyof Events | '*',\n  EventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n  all: EventHandlerMap<Events>;\n\n  on<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n  on(type: '*', handler: WildcardHandler<Events>): void;\n\n  off<Key extends keyof Events>(type: Key, handler?: Handler<Events[Key]>): void;\n  off(type: '*', handler: WildcardHandler<Events>): void;\n\n  emit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n  emit<Key extends keyof Events>(type: undefined extends Events[Key] ? Key : never): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n  all?: EventHandlerMap<Events>,\n): Emitter<Events> {\n  type GenericEventHandler = Handler<Events[keyof Events]> | WildcardHandler<Events>;\n  all = all || new Map();\n\n  return {\n    /**\n     * A Map of event names to registered handler functions.\n     */\n    all,\n\n    /**\n     * Register an event handler for the given type.\n     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n     * @param {Function} handler Function to call in response to given event\n     * @memberOf mitt\n     */\n    on<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n      const handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n      if (handlers) {\n        handlers.push(handler);\n      } else {\n        all!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n      }\n    },\n\n    /**\n     * Remove an event handler for the given type.\n     * If `handler` is omitted, all handlers of the given type are removed.\n     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n     * @param {Function} [handler] Handler function to remove\n     * @memberOf mitt\n     */\n    off<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n      const handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n      if (handlers) {\n        if (handler) {\n          handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n        } else {\n          all!.set(type, []);\n        }\n      }\n    },\n\n    /**\n     * Invoke all handlers for the given type.\n     * If present, `'*'` handlers are invoked after type-matched handlers.\n     *\n     * Note: Manually firing '*' handlers is not supported.\n     *\n     * @param {string|symbol} type The event type to invoke\n     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n     * @memberOf mitt\n     */\n    emit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n      let handlers = all!.get(type);\n      if (handlers) {\n        (handlers as EventHandlerList<Events[keyof Events]>).slice().map(handler => {\n          handler(evt!);\n        });\n      }\n\n      handlers = all!.get('*');\n      if (handlers) {\n        (handlers as WildCardEventHandlerList<Events>).slice().map(handler => {\n          handler(type, evt!);\n        });\n      }\n    },\n  };\n}\n","import type { Metric, MetricResult } from '../eval/metric';\nimport type { TestInfo } from '../eval/types';\nimport type { ScoringHookInput } from '../scores';\n\nimport mitt from './mitt';\nimport type { Handler } from './mitt';\n\nexport enum AvailableHooks {\n  ON_EVALUATION = 'onEvaluation',\n  ON_GENERATION = 'onGeneration',\n  ON_SCORER_RUN = 'onScorerRun',\n}\n\nconst hooks = mitt();\n\ntype EvaluationHookData = {\n  input: string;\n  output: string;\n  result: MetricResult;\n  agentName: string;\n  metricName: string;\n  instructions: string;\n  runId: string;\n  globalRunId: string;\n  testInfo?: TestInfo;\n};\n\ntype GenerationHookData = {\n  input: string;\n  output: string;\n  metric: Metric;\n  runId: string;\n  agentName: string;\n  instructions: string;\n};\n\nexport function registerHook(hook: AvailableHooks.ON_EVALUATION, action: Handler<EvaluationHookData>): void;\nexport function registerHook(hook: AvailableHooks.ON_GENERATION, action: Handler<GenerationHookData>): void;\nexport function registerHook(hook: AvailableHooks.ON_SCORER_RUN, action: Handler<ScoringHookInput>): void;\nexport function registerHook(hook: `${AvailableHooks}`, action: Handler<any>): void {\n  hooks.on(hook, action);\n}\n\nexport function executeHook(hook: AvailableHooks.ON_EVALUATION, action: EvaluationHookData): void;\nexport function executeHook(hook: AvailableHooks.ON_GENERATION, action: GenerationHookData): void;\nexport function executeHook(hook: AvailableHooks.ON_SCORER_RUN, action: ScoringHookInput): void;\nexport function executeHook(hook: `${AvailableHooks}`, data: unknown): void {\n  // do not block the main thread\n  setImmediate(() => {\n    hooks.emit(hook, data);\n  });\n}\n"]}