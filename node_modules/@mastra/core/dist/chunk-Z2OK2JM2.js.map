{"version":3,"sources":["../src/vector/vector.ts"],"names":[],"mappings":";;;;;;AAkBO,IAAe,YAAA,GAAf,cAA2D,UAAA,CAAW;AAAA,EAC3E,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,EAAE,IAAA,EAAM,cAAA,EAAgB,SAAA,EAAW,UAAU,CAAA;AAAA,EACrD;AAAA,EAEA,IAAI,cAAA,GAAyB;AAC3B,IAAA,OAAO,GAAA;AAAA,EACT;AAAA,EAkBA,MAAgB,qBAAA,CAAsB,SAAA,EAAmB,SAAA,EAAmB,MAAA,EAAgB;AAC1F,IAAA,IAAI,IAAA;AACJ,IAAA,IAAI;AACF,MAAA,IAAA,GAAO,MAAM,IAAA,CAAK,aAAA,CAAc,EAAE,WAAW,CAAA;AAAA,IAC/C,SAAS,SAAA,EAAW;AAClB,MAAA,MAAM,cAAc,IAAI,WAAA;AAAA,QACtB;AAAA,UACE,EAAA,EAAI,oCAAA;AAAA,UACJ,IAAA,EAAM,UAAU,SAAS,CAAA,qEAAA,CAAA;AAAA,UACzB,MAAA,EAAA,eAAA;AAAA,UACA,QAAA,EAAA,QAAA;AAAA,UACA,OAAA,EAAS,EAAE,SAAA;AAAU,SACvB;AAAA,QACA;AAAA,OACF;AACA,MAAA,IAAA,CAAK,MAAA,EAAQ,eAAe,WAAW,CAAA;AACvC,MAAA,IAAA,CAAK,MAAA,EAAQ,KAAA,CAAM,WAAA,CAAY,QAAA,EAAU,CAAA;AACzC,MAAA,MAAM,WAAA;AAAA,IACR;AACA,IAAA,MAAM,cAAc,IAAA,EAAM,SAAA;AAC1B,IAAA,MAAM,iBAAiB,IAAA,EAAM,MAAA;AAC7B,IAAA,IAAI,gBAAgB,SAAA,EAAW;AAC7B,MAAA,IAAA,CAAK,MAAA,EAAQ,IAAA;AAAA,QACX,CAAA,OAAA,EAAU,SAAS,CAAA,sBAAA,EAAyB,WAAW,0BAA0B,cAAc,CAAA,oBAAA;AAAA,OACjG;AACA,MAAA,IAAI,mBAAmB,MAAA,EAAQ;AAC7B,QAAA,IAAA,CAAK,MAAA,EAAQ,IAAA;AAAA,UACX,CAAA,uCAAA,EAA0C,MAAM,CAAA,yCAAA,EAA4C,cAAc,CAAA,4DAAA;AAAA,SAC5G;AAAA,MACF;AAAA,IACF,WAAW,IAAA,EAAM;AACf,MAAA,MAAM,WAAA,GAAc,IAAI,WAAA,CAAY;AAAA,QAClC,EAAA,EAAI,0CAAA;AAAA,QACJ,MAAM,CAAA,OAAA,EAAU,SAAS,CAAA,sBAAA,EAAyB,WAAW,oBAAoB,SAAS,CAAA,0BAAA,CAAA;AAAA,QAC1F,MAAA,EAAA,eAAA;AAAA,QACA,QAAA,EAAA,MAAA;AAAA,QACA,OAAA,EAAS,EAAE,SAAA,EAAW,WAAA,EAAa,cAAc,SAAA;AAAU,OAC5D,CAAA;AACD,MAAA,IAAA,CAAK,MAAA,EAAQ,eAAe,WAAW,CAAA;AACvC,MAAA,IAAA,CAAK,MAAA,EAAQ,KAAA,CAAM,WAAA,CAAY,QAAA,EAAU,CAAA;AACzC,MAAA,MAAM,WAAA;AAAA,IACR,CAAA,MAAO;AACL,MAAA,MAAM,WAAA,GAAc,IAAI,WAAA,CAAY;AAAA,QAClC,EAAA,EAAI,oCAAA;AAAA,QACJ,IAAA,EAAM,UAAU,SAAS,CAAA,uEAAA,CAAA;AAAA,QACzB,MAAA,EAAA,eAAA;AAAA,QACA,QAAA,EAAA,QAAA;AAAA,QACA,OAAA,EAAS,EAAE,SAAA;AAAU,OACtB,CAAA;AACD,MAAA,IAAA,CAAK,MAAA,EAAQ,eAAe,WAAW,CAAA;AACvC,MAAA,IAAA,CAAK,MAAA,EAAQ,KAAA,CAAM,WAAA,CAAY,QAAA,EAAU,CAAA;AACzC,MAAA,MAAM,WAAA;AAAA,IACR;AAAA,EACF;AACF","file":"chunk-Z2OK2JM2.js","sourcesContent":["import type { EmbeddingModelV2 } from '@ai-sdk/provider-v5';\nimport type { EmbeddingModel as EmbeddingModelV1 } from 'ai';\nimport { MastraBase } from '../base';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { VectorFilter } from './filter';\nimport type {\n  CreateIndexParams,\n  UpsertVectorParams,\n  QueryVectorParams,\n  IndexStats,\n  QueryResult,\n  UpdateVectorParams,\n  DeleteVectorParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n} from './types';\n\nexport type MastraEmbeddingModel<T> = EmbeddingModelV1<T> | EmbeddingModelV2<T>;\nexport abstract class MastraVector<Filter = VectorFilter> extends MastraBase {\n  constructor() {\n    super({ name: 'MastraVector', component: 'VECTOR' });\n  }\n\n  get indexSeparator(): string {\n    return '_';\n  }\n\n  abstract query(params: QueryVectorParams<Filter>): Promise<QueryResult[]>;\n  // Adds type checks for positional arguments if used\n  abstract upsert(params: UpsertVectorParams): Promise<string[]>;\n  // Adds type checks for positional arguments if used\n  abstract createIndex(params: CreateIndexParams): Promise<void>;\n\n  abstract listIndexes(): Promise<string[]>;\n\n  abstract describeIndex(params: DescribeIndexParams): Promise<IndexStats>;\n\n  abstract deleteIndex(params: DeleteIndexParams): Promise<void>;\n\n  abstract updateVector(params: UpdateVectorParams): Promise<void>;\n\n  abstract deleteVector(params: DeleteVectorParams): Promise<void>;\n\n  protected async validateExistingIndex(indexName: string, dimension: number, metric: string) {\n    let info: IndexStats;\n    try {\n      info = await this.describeIndex({ indexName });\n    } catch (infoError) {\n      const mastraError = new MastraError(\n        {\n          id: 'VECTOR_VALIDATE_INDEX_FETCH_FAILED',\n          text: `Index \"${indexName}\" already exists, but failed to fetch index info for dimension check.`,\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.SYSTEM,\n          details: { indexName },\n        },\n        infoError,\n      );\n      this.logger?.trackException(mastraError);\n      this.logger?.error(mastraError.toString());\n      throw mastraError;\n    }\n    const existingDim = info?.dimension;\n    const existingMetric = info?.metric;\n    if (existingDim === dimension) {\n      this.logger?.info(\n        `Index \"${indexName}\" already exists with ${existingDim} dimensions and metric ${existingMetric}, skipping creation.`,\n      );\n      if (existingMetric !== metric) {\n        this.logger?.warn(\n          `Attempted to create index with metric \"${metric}\", but index already exists with metric \"${existingMetric}\". To use a different metric, delete and recreate the index.`,\n        );\n      }\n    } else if (info) {\n      const mastraError = new MastraError({\n        id: 'VECTOR_VALIDATE_INDEX_DIMENSION_MISMATCH',\n        text: `Index \"${indexName}\" already exists with ${existingDim} dimensions, but ${dimension} dimensions were requested`,\n        domain: ErrorDomain.MASTRA_VECTOR,\n        category: ErrorCategory.USER,\n        details: { indexName, existingDim, requestedDim: dimension },\n      });\n      this.logger?.trackException(mastraError);\n      this.logger?.error(mastraError.toString());\n      throw mastraError;\n    } else {\n      const mastraError = new MastraError({\n        id: 'VECTOR_VALIDATE_INDEX_NO_DIMENSION',\n        text: `Index \"${indexName}\" already exists, but could not retrieve its dimensions for validation.`,\n        domain: ErrorDomain.MASTRA_VECTOR,\n        category: ErrorCategory.SYSTEM,\n        details: { indexName },\n      });\n      this.logger?.trackException(mastraError);\n      this.logger?.error(mastraError.toString());\n      throw mastraError;\n    }\n  }\n}\n"]}