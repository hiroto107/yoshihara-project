{"version":3,"sources":["../src/storage/base.ts"],"names":["MastraBase","TABLE_WORKFLOW_SNAPSHOT","TABLE_EVALS","TABLE_MESSAGES","TABLE_THREADS","TABLE_TRACES","TABLE_SCHEMAS","TABLE_SCORERS","TABLE_RESOURCES","TABLE_AI_SPANS","MastraError"],"mappings":"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","file":"chunk-TKYKL7Y4.cjs","sourcesContent":["import type { MastraMessageContentV2, MastraMessageV2 } from '../agent';\nimport type { TracingStrategy } from '../ai-tracing';\nimport { MastraBase } from '../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../error';\nimport type { MastraMessageV1, StorageThreadType } from '../memory/types';\nimport type { ScoreRowData, ScoringSource, ValidatedSaveScorePayload } from '../scores';\nimport type { Trace } from '../telemetry';\nimport type { StepResult, WorkflowRunState } from '../workflows/types';\n\nimport {\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_EVALS,\n  TABLE_MESSAGES,\n  TABLE_THREADS,\n  TABLE_TRACES,\n  TABLE_RESOURCES,\n  TABLE_SCORERS,\n  TABLE_SCHEMAS,\n  TABLE_AI_SPANS,\n} from './constants';\nimport type { TABLE_NAMES } from './constants';\nimport type {\n  ScoresStorage,\n  StoreOperations,\n  WorkflowsStorage,\n  TracesStorage,\n  MemoryStorage,\n  LegacyEvalsStorage,\n  ObservabilityStorage,\n} from './domains';\nimport type {\n  EvalRow,\n  PaginationInfo,\n  StorageColumn,\n  StorageGetMessagesArg,\n  StorageResourceType,\n  StoragePagination,\n  ThreadSortOptions,\n  WorkflowRun,\n  WorkflowRuns,\n  StorageGetTracesArg,\n  PaginationArgs,\n  StorageGetTracesPaginatedArg,\n  AISpanRecord,\n  AITraceRecord,\n  AITracesPaginatedArg,\n  CreateIndexOptions,\n  IndexInfo,\n  StorageIndexStats,\n  UpdateAISpanRecord,\n  CreateAISpanRecord,\n} from './types';\n\nexport type StorageDomains = {\n  legacyEvals: LegacyEvalsStorage;\n  operations: StoreOperations;\n  workflows: WorkflowsStorage;\n  scores: ScoresStorage;\n  traces: TracesStorage;\n  memory: MemoryStorage;\n  observability?: ObservabilityStorage;\n};\n\nexport function ensureDate(date: Date | string | undefined): Date | undefined {\n  if (!date) return undefined;\n  return date instanceof Date ? date : new Date(date);\n}\n\nexport function serializeDate(date: Date | string | undefined): string | undefined {\n  if (!date) return undefined;\n  const dateObj = ensureDate(date);\n  return dateObj?.toISOString();\n}\n\nexport function resolveMessageLimit({\n  last,\n  defaultLimit,\n}: {\n  last: number | false | undefined;\n  defaultLimit: number;\n}): number {\n  // TODO: Figure out consistent default limit for all stores as some stores use 40 and some use no limit (Number.MAX_SAFE_INTEGER)\n  if (typeof last === 'number') return Math.max(0, last);\n  if (last === false) return 0;\n  return defaultLimit;\n}\nexport abstract class MastraStorage extends MastraBase {\n  /** @deprecated import from { TABLE_WORKFLOW_SNAPSHOT } '@mastra/core/storage' instead */\n  static readonly TABLE_WORKFLOW_SNAPSHOT = TABLE_WORKFLOW_SNAPSHOT;\n  /** @deprecated import from { TABLE_EVALS } '@mastra/core/storage' instead */\n  static readonly TABLE_EVALS = TABLE_EVALS;\n  /** @deprecated import from { TABLE_MESSAGES } '@mastra/core/storage' instead */\n  static readonly TABLE_MESSAGES = TABLE_MESSAGES;\n  /** @deprecated import from { TABLE_THREADS } '@mastra/core/storage' instead */\n  static readonly TABLE_THREADS = TABLE_THREADS;\n  /** @deprecated import { TABLE_TRACES } from '@mastra/core/storage' instead */\n  static readonly TABLE_TRACES = TABLE_TRACES;\n\n  protected hasInitialized: null | Promise<boolean> = null;\n  protected shouldCacheInit = true;\n\n  stores?: StorageDomains;\n\n  constructor({ name }: { name: string }) {\n    super({\n      component: 'STORAGE',\n      name,\n    });\n  }\n\n  public get supports(): {\n    selectByIncludeResourceScope: boolean;\n    resourceWorkingMemory: boolean;\n    hasColumn: boolean;\n    createTable: boolean;\n    deleteMessages: boolean;\n    aiTracing?: boolean;\n    indexManagement?: boolean;\n    getScoresBySpan?: boolean;\n  } {\n    return {\n      selectByIncludeResourceScope: false,\n      resourceWorkingMemory: false,\n      hasColumn: false,\n      createTable: false,\n      deleteMessages: false,\n      aiTracing: false,\n      indexManagement: false,\n      getScoresBySpan: false,\n    };\n  }\n\n  protected ensureDate(date: Date | string | undefined): Date | undefined {\n    return ensureDate(date);\n  }\n\n  protected serializeDate(date: Date | string | undefined): string | undefined {\n    return serializeDate(date);\n  }\n\n  /**\n   * Resolves limit for how many messages to fetch\n   *\n   * @param last The number of messages to fetch\n   * @param defaultLimit The default limit to use if last is not provided\n   * @returns The resolved limit\n   */\n  protected resolveMessageLimit({\n    last,\n    defaultLimit,\n  }: {\n    last: number | false | undefined;\n    defaultLimit: number;\n  }): number {\n    return resolveMessageLimit({ last, defaultLimit });\n  }\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n        return 'TEXT';\n      case 'timestamp':\n        return 'TIMESTAMP';\n      case 'float':\n        return 'FLOAT';\n      case 'integer':\n        return 'INTEGER';\n      case 'bigint':\n        return 'BIGINT';\n      case 'jsonb':\n        return 'JSONB';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'timestamp':\n        return \"DEFAULT '1970-01-01 00:00:00'\";\n      case 'integer':\n      case 'float':\n      case 'bigint':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  abstract createTable({ tableName }: { tableName: TABLE_NAMES; schema: Record<string, StorageColumn> }): Promise<void>;\n\n  abstract clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract alterTable(args: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void>;\n\n  abstract insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void>;\n\n  abstract batchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void>;\n\n  batchTraceInsert({ records }: { records: Record<string, any>[] }): Promise<void> {\n    if (this.stores?.traces) {\n      return this.stores.traces.batchTraceInsert({ records });\n    }\n    return this.batchInsert({ tableName: TABLE_TRACES, records });\n  }\n\n  abstract load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<R | null>;\n\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract getThreadsByResourceId({\n    resourceId,\n    orderBy,\n    sortDirection,\n  }: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]>;\n\n  abstract saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType>;\n\n  abstract updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType>;\n\n  abstract deleteThread({ threadId }: { threadId: string }): Promise<void>;\n\n  async getResourceById(_: { resourceId: string }): Promise<StorageResourceType | null> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  async saveResource(_: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  async updateResource(_: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  abstract getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  abstract getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  abstract getMessages({\n    threadId,\n    resourceId,\n    selectBy,\n    format,\n  }: StorageGetMessagesArg & { format?: 'v1' | 'v2' }): Promise<MastraMessageV1[] | MastraMessageV2[]>;\n  abstract getMessagesById({ messageIds }: { messageIds: string[]; format: 'v1' }): Promise<MastraMessageV1[]>;\n  abstract getMessagesById({ messageIds }: { messageIds: string[]; format?: 'v2' }): Promise<MastraMessageV2[]>;\n  abstract getMessagesById({\n    messageIds,\n  }: {\n    messageIds: string[];\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]>;\n\n  abstract saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  abstract saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  abstract saveMessages(\n    args: { messages: MastraMessageV1[]; format?: undefined | 'v1' } | { messages: MastraMessageV2[]; format: 'v2' },\n  ): Promise<MastraMessageV2[] | MastraMessageV1[]>;\n\n  abstract updateMessages(args: {\n    messages: Partial<Omit<MastraMessageV2, 'createdAt'>> &\n      {\n        id: string;\n        content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n      }[];\n  }): Promise<MastraMessageV2[]>;\n\n  async deleteMessages(_messageIds: string[]): Promise<void> {\n    throw new Error(\n      `Message deletion is not supported by this storage adapter (${this.constructor.name}). ` +\n        `The deleteMessages method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  abstract getTraces(args: StorageGetTracesArg): Promise<Trace[]>;\n\n  abstract getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }>;\n\n  async init(): Promise<void> {\n    // to prevent race conditions, await any current init\n    if (this.shouldCacheInit && (await this.hasInitialized)) {\n      return;\n    }\n\n    const tableCreationTasks = [\n      this.createTable({\n        tableName: TABLE_WORKFLOW_SNAPSHOT,\n        schema: TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT],\n      }),\n\n      this.createTable({\n        tableName: TABLE_EVALS,\n        schema: TABLE_SCHEMAS[TABLE_EVALS],\n      }),\n\n      this.createTable({\n        tableName: TABLE_THREADS,\n        schema: TABLE_SCHEMAS[TABLE_THREADS],\n      }),\n\n      this.createTable({\n        tableName: TABLE_MESSAGES,\n        schema: TABLE_SCHEMAS[TABLE_MESSAGES],\n      }),\n\n      this.createTable({\n        tableName: TABLE_TRACES,\n        schema: TABLE_SCHEMAS[TABLE_TRACES],\n      }),\n\n      this.createTable({\n        tableName: TABLE_SCORERS,\n        schema: TABLE_SCHEMAS[TABLE_SCORERS],\n      }),\n    ];\n\n    // Only create resources table for storage adapters that support it\n    if (this.supports.resourceWorkingMemory) {\n      tableCreationTasks.push(\n        this.createTable({\n          tableName: TABLE_RESOURCES,\n          schema: TABLE_SCHEMAS[TABLE_RESOURCES],\n        }),\n      );\n    }\n\n    if (this.supports.aiTracing) {\n      tableCreationTasks.push(\n        this.createTable({\n          tableName: TABLE_AI_SPANS,\n          schema: TABLE_SCHEMAS[TABLE_AI_SPANS],\n        }),\n      );\n    }\n\n    this.hasInitialized = Promise.all(tableCreationTasks).then(() => true);\n\n    await this.hasInitialized;\n\n    await this?.alterTable?.({\n      tableName: TABLE_MESSAGES,\n      schema: TABLE_SCHEMAS[TABLE_MESSAGES],\n      ifNotExists: ['resourceId'],\n    });\n    await this?.alterTable?.({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      schema: TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT],\n      ifNotExists: ['resourceId'],\n    });\n    await this?.alterTable?.({\n      tableName: TABLE_SCORERS,\n      schema: TABLE_SCHEMAS[TABLE_SCORERS],\n      ifNotExists: ['spanId'],\n    });\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    await this.init();\n\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n    this.logger.debug('Persisting workflow snapshot', { workflowName, runId, data });\n    await this.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  abstract updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    runtimeContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>>;\n\n  abstract updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined>;\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    if (!this.hasInitialized) {\n      await this.init();\n    }\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.load<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    return d ? d.snapshot : null;\n  }\n\n  /**\n   * SCORERS\n   */\n\n  abstract getScoreById({ id }: { id: string }): Promise<ScoreRowData | null>;\n\n  abstract saveScore(score: ValidatedSaveScorePayload): Promise<{ score: ScoreRowData }>;\n\n  abstract getScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  async getScoresBySpan({\n    traceId,\n    spanId,\n    pagination: _pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    throw new MastraError({\n      id: 'SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      details: { traceId, spanId },\n    });\n  }\n\n  abstract getEvals(\n    options: {\n      agentName?: string;\n      type?: 'test' | 'live';\n    } & PaginationArgs,\n  ): Promise<PaginationInfo & { evals: EvalRow[] }>;\n\n  abstract getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]>;\n\n  abstract getWorkflowRuns(args?: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  }): Promise<WorkflowRuns>;\n\n  abstract getWorkflowRunById(args: { runId: string; workflowName?: string }): Promise<WorkflowRun | null>;\n\n  abstract getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }>;\n\n  abstract getMessagesPaginated(\n    args: StorageGetMessagesArg & { format?: 'v1' | 'v2' },\n  ): Promise<PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }>;\n\n  /**\n   * OBSERVABILITY\n   */\n\n  /**\n   * Provides hints for AI tracing strategy selection by the DefaultExporter.\n   * Storage adapters can override this to specify their preferred and supported strategies.\n   */\n  public get aiTracingStrategy(): {\n    preferred: TracingStrategy;\n    supported: TracingStrategy[];\n  } {\n    if (this.stores?.observability) {\n      return this.stores.observability.aiTracingStrategy;\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_TRACING_STRATEGY_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Creates a single AI span record in the storage provider.\n   */\n  async createAISpan(span: CreateAISpanRecord): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.createAISpan(span);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_AI_SPAN_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Updates a single AI span with partial data. Primarily used for realtime trace creation.\n   */\n  async updateAISpan(params: { spanId: string; traceId: string; updates: Partial<UpdateAISpanRecord> }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.updateAISpan(params);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_UPDATE_AI_SPAN_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Retrieves a single AI trace with all its associated spans.\n   */\n  async getAITrace(traceId: string): Promise<AITraceRecord | null> {\n    if (this.stores?.observability) {\n      return this.stores.observability.getAITrace(traceId);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_GET_AI_TRACE_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Retrieves a paginated list of AI traces with optional filtering.\n   */\n  async getAITracesPaginated(\n    args: AITracesPaginatedArg,\n  ): Promise<{ pagination: PaginationInfo; spans: AISpanRecord[] }> {\n    if (this.stores?.observability) {\n      return this.stores.observability.getAITracesPaginated(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_GET_AI_TRACES_PAGINATED_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Creates multiple AI spans in a single batch.\n   */\n  async batchCreateAISpans(args: { records: CreateAISpanRecord[] }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.batchCreateAISpans(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_BATCH_CREATE_AI_SPANS_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Updates multiple AI spans in a single batch.\n   */\n  async batchUpdateAISpans(args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateAISpanRecord>;\n    }[];\n  }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.batchUpdateAISpans(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_BATCH_UPDATE_AI_SPANS_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Deletes multiple AI traces and all their associated spans in a single batch operation.\n   */\n  async batchDeleteAITraces(args: { traceIds: string[] }): Promise<void> {\n    if (this.stores?.observability) {\n      return this.stores.observability.batchDeleteAITraces(args);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_BATCH_DELETE_AI_TRACES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `AI tracing is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * DATABASE INDEX MANAGEMENT\n   * These methods delegate to the operations store for index management.\n   * Storage adapters that support indexes should implement these in their operations class.\n   */\n\n  /**\n   * Creates a database index on specified columns\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async createIndex(options: CreateIndexOptions): Promise<void> {\n    if (this.stores?.operations) {\n      return this.stores.operations.createIndex(options);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Drops a database index by name\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async dropIndex(indexName: string): Promise<void> {\n    if (this.stores?.operations) {\n      return this.stores.operations.dropIndex(indexName);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Lists database indexes for a table or all tables\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async listIndexes(tableName?: string): Promise<IndexInfo[]> {\n    if (this.stores?.operations) {\n      return this.stores.operations.listIndexes(tableName);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n\n  /**\n   * Gets detailed statistics for a specific index\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async describeIndex(indexName: string): Promise<StorageIndexStats> {\n    if (this.stores?.operations) {\n      return this.stores.operations.describeIndex(indexName);\n    }\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter (${this.constructor.name})`,\n    });\n  }\n}\n"]}