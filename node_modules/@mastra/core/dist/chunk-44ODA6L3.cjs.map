{"version":3,"sources":["../src/ai-tracing/types.ts","../src/ai-tracing/spans/base.ts","../src/ai-tracing/spans/default.ts","../src/ai-tracing/spans/no-op.ts","../src/ai-tracing/tracers/base.ts","../src/ai-tracing/tracers/default.ts","../src/tools/tool-builder/builder.ts","../src/utils.ts","../src/ai-tracing/exporters/cloud.ts","../src/ai-tracing/exporters/console.ts","../src/ai-tracing/exporters/default.ts","../src/ai-tracing/span_processors/sensitive-data-filter.ts","../src/ai-tracing/registry.ts","../src/ai-tracing/utils.ts","../src/ai-tracing/context.ts"],"names":["AISpanType","InternalSpans","SamplingStrategyType","AITracingEventType","MastraError","MastraBase","RegisteredLogger","isVercelTool","z","convertZodSchemaToAISDKSchema","RuntimeContext","ToolStream","error","logger","validateToolInput","OpenAIReasoningSchemaCompatLayer","OpenAISchemaCompatLayer","GoogleSchemaCompatLayer","AnthropicSchemaCompatLayer","DeepSeekSchemaCompatLayer","MetaSchemaCompatLayer","applyCompatLayer","createHash","jsonSchemaToZod","delay","ConsoleLogger","LogLevel"],"mappings":"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","file":"chunk-44ODA6L3.cjs","sourcesContent":["/**\n * AI Tracing interfaces\n */\n\nimport type { MastraError } from '../error';\nimport type { IMastraLogger } from '../logger';\nimport type { RuntimeContext } from '../runtime-context';\nimport type { WorkflowRunStatus, WorkflowStepStatus } from '../workflows';\n\n// ============================================================================\n// Core AI-Specific Span Types\n// ============================================================================\n\n/**\n * AI-specific span types with their associated metadata\n */\nexport enum AISpanType {\n  /** Agent run - root span for agent processes */\n  AGENT_RUN = 'agent_run',\n  /** Generic span for custom operations */\n  GENERIC = 'generic',\n  /** LLM generation with model calls, token usage, prompts, completions */\n  LLM_GENERATION = 'llm_generation',\n  /** Individual LLM streaming chunk/event */\n  LLM_CHUNK = 'llm_chunk',\n  /** MCP (Model Context Protocol) tool execution */\n  MCP_TOOL_CALL = 'mcp_tool_call',\n  /** Input or Output Processor execution */\n  PROCESSOR_RUN = 'processor_run',\n  /** Function/tool execution with inputs, outputs, errors */\n  TOOL_CALL = 'tool_call',\n  /** Workflow run - root span for workflow processes */\n  WORKFLOW_RUN = 'workflow_run',\n  /** Workflow step execution with step status, data flow */\n  WORKFLOW_STEP = 'workflow_step',\n  /** Workflow conditional execution with condition evaluation */\n  WORKFLOW_CONDITIONAL = 'workflow_conditional',\n  /** Individual condition evaluation within conditional */\n  WORKFLOW_CONDITIONAL_EVAL = 'workflow_conditional_eval',\n  /** Workflow parallel execution */\n  WORKFLOW_PARALLEL = 'workflow_parallel',\n  /** Workflow loop execution */\n  WORKFLOW_LOOP = 'workflow_loop',\n  /** Workflow sleep operation */\n  WORKFLOW_SLEEP = 'workflow_sleep',\n  /** Workflow wait for event operation */\n  WORKFLOW_WAIT_EVENT = 'workflow_wait_event',\n}\n\n// ============================================================================\n// Type-Specific Attributes Interfaces\n// ============================================================================\n\n/**\n * Base attributes that all spans can have\n */\nexport interface AIBaseAttributes {}\n\n/**\n * Agent Run attributes\n */\nexport interface AgentRunAttributes extends AIBaseAttributes {\n  /** Agent identifier */\n  agentId: string;\n  /** Agent Instructions **/\n  instructions?: string;\n  /** Agent Prompt **/\n  prompt?: string;\n  /** Available tools for this execution */\n  availableTools?: string[];\n  /** Maximum steps allowed */\n  maxSteps?: number;\n}\n\n/**\n * LLM Generation attributes\n */\nexport interface LLMGenerationAttributes extends AIBaseAttributes {\n  /** Model name (e.g., 'gpt-4', 'claude-3') */\n  model?: string;\n  /** Model provider (e.g., 'openai', 'anthropic') */\n  provider?: string;\n  /** Type of result/output this LLM call produced */\n  resultType?: 'tool_selection' | 'response_generation' | 'reasoning' | 'planning';\n  /** Token usage statistics - supports both v5 and legacy formats */\n  usage?: {\n    // VNext paths\n    inputTokens?: number;\n    outputTokens?: number;\n    // Legacy format (for backward compatibility)\n    promptTokens?: number;\n    completionTokens?: number;\n    // Common fields\n    totalTokens?: number;\n    reasoningTokens?: number;\n    cachedInputTokens?: number;\n    promptCacheHitTokens?: number;\n    promptCacheMissTokens?: number;\n  };\n  /** Model parameters */\n  parameters?: {\n    maxOutputTokens?: number;\n    temperature?: number;\n    topP?: number;\n    topK?: number;\n    presencePenalty?: number;\n    frequencyPenalty?: number;\n    stopSequences?: string[];\n    seed?: number;\n    maxRetries?: number;\n    abortSignal?: any;\n    headers?: Record<string, string | undefined>;\n  };\n  /** Whether this was a streaming response */\n  streaming?: boolean;\n  /** Reason the generation finished */\n  finishReason?: string;\n}\n\n/**\n * LLM Chunk attributes - for individual streaming chunks/events\n */\nexport interface LLMChunkAttributes extends AIBaseAttributes {\n  /** Type of chunk (text-delta, reasoning-delta, tool-call, etc.) */\n  chunkType?: string;\n  /** Sequence number of this chunk in the stream */\n  sequenceNumber?: number;\n}\n\n/**\n * Tool Call attributes\n */\nexport interface ToolCallAttributes extends AIBaseAttributes {\n  toolId?: string;\n  toolType?: string;\n  toolDescription?: string;\n  success?: boolean;\n}\n\n/**\n * MCP Tool Call attributes\n */\nexport interface MCPToolCallAttributes extends AIBaseAttributes {\n  /** Id of the MCP tool/function */\n  toolId: string;\n  /** MCP server identifier */\n  mcpServer: string;\n  /** MCP server version */\n  serverVersion?: string;\n  /** Whether tool execution was successful */\n  success?: boolean;\n}\n\n/**\n * Processor attributes\n */\nexport interface ProcessorRunAttributes extends AIBaseAttributes {\n  /** Name of the Processor */\n  processorName: string;\n  /** Processor type (input or output) */\n  processorType: 'input' | 'output';\n  /** Processor index in the agent */\n  processorIndex?: number;\n}\n\n/**\n * Workflow Run attributes\n */\nexport interface WorkflowRunAttributes extends AIBaseAttributes {\n  /** Workflow identifier */\n  workflowId: string;\n  /** Workflow status */\n  status?: WorkflowRunStatus;\n}\n\n/**\n * Workflow Step attributes\n */\nexport interface WorkflowStepAttributes extends AIBaseAttributes {\n  /** Step identifier */\n  stepId: string;\n  /** Step status */\n  status?: WorkflowStepStatus;\n}\n\n/**\n * Workflow Conditional attributes\n */\nexport interface WorkflowConditionalAttributes extends AIBaseAttributes {\n  /** Number of conditions evaluated */\n  conditionCount: number;\n  /** Which condition indexes evaluated to true */\n  truthyIndexes?: number[];\n  /** Which steps will be executed */\n  selectedSteps?: string[];\n}\n\n/**\n * Workflow Conditional Evaluation attributes\n */\nexport interface WorkflowConditionalEvalAttributes extends AIBaseAttributes {\n  /** Index of this condition in the conditional */\n  conditionIndex: number;\n  /** Result of condition evaluation */\n  result?: boolean;\n}\n\n/**\n * Workflow Parallel attributes\n */\nexport interface WorkflowParallelAttributes extends AIBaseAttributes {\n  /** Number of parallel branches */\n  branchCount: number;\n  /** Step IDs being executed in parallel */\n  parallelSteps?: string[];\n}\n\n/**\n * Workflow Loop attributes\n */\nexport interface WorkflowLoopAttributes extends AIBaseAttributes {\n  /** Type of loop (foreach, dowhile, dountil) */\n  loopType?: 'foreach' | 'dowhile' | 'dountil';\n  /** Current iteration number (for individual iterations) */\n  iteration?: number;\n  /** Total iterations (if known) */\n  totalIterations?: number;\n  /** Number of steps to run concurrently in foreach loop */\n  concurrency?: number;\n}\n\n/**\n * Workflow Sleep attributes\n */\nexport interface WorkflowSleepAttributes extends AIBaseAttributes {\n  /** Sleep duration in milliseconds */\n  durationMs?: number;\n  /** Sleep until date */\n  untilDate?: Date;\n  /** Sleep type */\n  sleepType?: 'fixed' | 'dynamic';\n}\n\n/**\n * Workflow Wait Event attributes\n */\nexport interface WorkflowWaitEventAttributes extends AIBaseAttributes {\n  /** Event name being waited for */\n  eventName?: string;\n  /** Timeout in milliseconds */\n  timeoutMs?: number;\n  /** Whether event was received or timed out */\n  eventReceived?: boolean;\n  /** Wait duration in milliseconds */\n  waitDurationMs?: number;\n}\n\n/**\n * AI-specific span types mapped to their attributes\n */\nexport interface AISpanTypeMap {\n  [AISpanType.AGENT_RUN]: AgentRunAttributes;\n  [AISpanType.WORKFLOW_RUN]: WorkflowRunAttributes;\n  [AISpanType.LLM_GENERATION]: LLMGenerationAttributes;\n  [AISpanType.LLM_CHUNK]: LLMChunkAttributes;\n  [AISpanType.TOOL_CALL]: ToolCallAttributes;\n  [AISpanType.MCP_TOOL_CALL]: MCPToolCallAttributes;\n  [AISpanType.PROCESSOR_RUN]: ProcessorRunAttributes;\n  [AISpanType.WORKFLOW_STEP]: WorkflowStepAttributes;\n  [AISpanType.WORKFLOW_CONDITIONAL]: WorkflowConditionalAttributes;\n  [AISpanType.WORKFLOW_CONDITIONAL_EVAL]: WorkflowConditionalEvalAttributes;\n  [AISpanType.WORKFLOW_PARALLEL]: WorkflowParallelAttributes;\n  [AISpanType.WORKFLOW_LOOP]: WorkflowLoopAttributes;\n  [AISpanType.WORKFLOW_SLEEP]: WorkflowSleepAttributes;\n  [AISpanType.WORKFLOW_WAIT_EVENT]: WorkflowWaitEventAttributes;\n  [AISpanType.GENERIC]: AIBaseAttributes;\n}\n\n/**\n * Union type for cases that need to handle any span type\n */\nexport type AnyAISpanAttributes = AISpanTypeMap[keyof AISpanTypeMap];\n\n// ============================================================================\n// Span Interfaces\n// ============================================================================\n\n/**\n * Base Span interface\n */\ninterface BaseSpan<TType extends AISpanType> {\n  /** Unique span identifier */\n  id: string;\n  /** OpenTelemetry-compatible trace ID (32 hex chars) - present on all spans */\n  traceId: string;\n  /** Name of the span */\n  name: string;\n  /** Type of the span */\n  type: TType;\n  /** When span started */\n  startTime: Date;\n  /** When span ended */\n  endTime?: Date;\n  /** Is an internal span? (spans internal to the operation of mastra) */\n  attributes?: AISpanTypeMap[TType];\n  /** User-defined metadata */\n  metadata?: Record<string, any>;\n  /** Input passed at the start of the span */\n  input?: any;\n  /** Output generated at the end of the span */\n  output?: any;\n  /** Error information if span failed */\n  errorInfo?: {\n    message: string;\n    id?: string;\n    domain?: string;\n    category?: string;\n    details?: Record<string, any>;\n  };\n  /** Is an event span? (event occurs at startTime, has no endTime) */\n  isEvent: boolean;\n}\n\n/**\n * AI Span interface, used internally for tracing\n */\nexport interface AISpan<TType extends AISpanType> extends BaseSpan<TType> {\n  /** Is an internal span? (spans internal to the operation of mastra) */\n  isInternal: boolean;\n  /** Parent span reference (undefined for root spans) */\n  parent?: AnyAISpan;\n  /** Pointer to the AITracing instance */\n  aiTracing: AITracing;\n\n  // Methods for span lifecycle\n  /** End the span */\n  end(options?: EndSpanOptions<TType>): void;\n\n  /** Record an error for the span, optionally end the span as well */\n  error(options: ErrorSpanOptions<TType>): void;\n\n  /** Update span attributes */\n  update(options: UpdateSpanOptions<TType>): void;\n\n  /** Create child span - can be any span type independent of parent */\n  createChildSpan<TChildType extends AISpanType>(options: ChildSpanOptions<TChildType>): AISpan<TChildType>;\n\n  /** Create event span - can be any span type independent of parent */\n  createEventSpan<TChildType extends AISpanType>(options: ChildEventOptions<TChildType>): AISpan<TChildType>;\n\n  /** Returns `TRUE` if the span is the root span of a trace */\n  get isRootSpan(): boolean;\n\n  /** Returns `TRUE` if the span is a valid span (not a NO-OP Span) */\n  get isValid(): boolean;\n\n  /** Get the closest parent spanId that isn't an internal span */\n  getParentSpanId(includeInternalSpans?: boolean): string | undefined;\n\n  /** Find the closest parent span of a specific type by walking up the parent chain */\n  findParent<T extends AISpanType>(spanType: T): AISpan<T> | undefined;\n\n  /** Returns a lightweight span ready for export */\n  exportSpan(includeInternalSpans?: boolean): ExportedAISpan<TType> | undefined;\n}\n\n/**\n * Exported AI Span interface, used for tracing exporters\n */\nexport interface ExportedAISpan<TType extends AISpanType> extends BaseSpan<TType> {\n  /** Parent span id reference (undefined for root spans) */\n  parentSpanId?: string;\n  /** `TRUE` if the span is the root span of a trace */\n  isRootSpan: boolean;\n}\n\n/**\n * Union type for cases that need to handle any span\n */\nexport type AnyAISpan = AISpan<keyof AISpanTypeMap>;\n\n/**\n * Union type for cases that need to handle any exported span\n */\nexport type AnyExportedAISpan = ExportedAISpan<keyof AISpanTypeMap>;\n\n// ============================================================================\n// Tracing Interfaces\n// ============================================================================\n\n/**\n * Primary interface for AI Tracing\n */\nexport interface AITracing {\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<Required<TracingConfig>>;\n\n  /**\n   * Get all exporters\n   */\n  getExporters(): readonly AITracingExporter[];\n\n  /**\n   * Get all processors\n   */\n  getProcessors(): readonly AISpanProcessor[];\n\n  /**\n   * Get the logger instance (for exporters and other components)\n   */\n  getLogger(): IMastraLogger;\n\n  /**\n   * Start a new span of a specific AISpanType\n   */\n  startSpan<TType extends AISpanType>(options: StartSpanOptions<TType>): AISpan<TType>;\n\n  /**\n   * Shutdown AI tracing and clean up resources\n   */\n  shutdown(): Promise<void>;\n\n  /**\n   * Override setLogger to add AI tracing specific initialization log\n   */\n  __setLogger(logger: IMastraLogger): void;\n}\n\n// ============================================================================\n// Span Create/Update/Error Option Types\n// ============================================================================\n\ninterface CreateBaseOptions<TType extends AISpanType> {\n  /** Span attributes */\n  attributes?: AISpanTypeMap[TType];\n  /** Span metadata */\n  metadata?: Record<string, any>;\n  /** Span name */\n  name: string;\n  /** Span type */\n  type: TType;\n  /** Policy-level tracing configuration */\n  tracingPolicy?: TracingPolicy;\n}\n\n/**\n * Options for creating new spans\n */\nexport interface CreateSpanOptions<TType extends AISpanType> extends CreateBaseOptions<TType> {\n  /** Input data */\n  input?: any;\n  /** Output data (for event spans) */\n  output?: any;\n  /** Parent span */\n  parent?: AnyAISpan;\n  /** Is an event span? */\n  isEvent?: boolean;\n}\n\n/**\n * Options for starting new spans\n */\nexport interface StartSpanOptions<TType extends AISpanType> extends CreateSpanOptions<TType> {\n  /**\n   * Options passed when using a custom sampler strategy\n   */\n  customSamplerOptions?: CustomSamplerOptions;\n}\n\n/**\n * Options for new child spans\n */\nexport interface ChildSpanOptions<TType extends AISpanType> extends CreateBaseOptions<TType> {\n  /** Input data */\n  input?: any;\n}\n\n/**\n * Options for new child events\n * Event spans have no input, and no endTime\n */\nexport interface ChildEventOptions<TType extends AISpanType> extends CreateBaseOptions<TType> {\n  /** Output data */\n  output?: any;\n}\n\ninterface UpdateBaseOptions<TType extends AISpanType> {\n  /** Span attributes */\n  attributes?: Partial<AISpanTypeMap[TType]>;\n  /** Span metadata */\n  metadata?: Record<string, any>;\n}\n\nexport interface EndSpanOptions<TType extends AISpanType> extends UpdateBaseOptions<TType> {\n  /** Output data */\n  output?: any;\n}\n\nexport interface UpdateSpanOptions<TType extends AISpanType> extends UpdateBaseOptions<TType> {\n  /** Input data */\n  input?: any;\n  /** Output data */\n  output?: any;\n}\n\nexport interface ErrorSpanOptions<TType extends AISpanType> extends UpdateBaseOptions<TType> {\n  /** The error associated with the issue */\n  error: MastraError | Error;\n  /** End the span when true */\n  endSpan?: boolean;\n}\n\n// ============================================================================\n// Lifecycle Types\n// ============================================================================\n\n/**\n * Bitwise options to set different types of spans as internal in\n * a workflow or agent execution.\n */\nexport enum InternalSpans {\n  /** No spans are marked internal */\n  NONE = 0,\n  /** Workflow spans are marked internal */\n  WORKFLOW = 1 << 0, // 0001\n  /** Agent spans are marked internal */\n  AGENT = 1 << 1, // 0010\n  /** Tool spans are marked internal */\n  TOOL = 1 << 2, // 0100\n  /** LLM spans are marked internal */\n  LLM = 1 << 3, // 1000\n\n  /** All spans are marked internal */\n  ALL = (1 << 4) - 1, // 1111 (all bits set up to 3)\n}\n\n/**\n * Policy-level tracing configuration applied when creating\n * a workflow or agent. Unlike TracingOptions, which are\n * provided at execution time, policies define persistent rules\n * for how spans are treated across all executions of the\n * workflow/agent.\n */\nexport interface TracingPolicy {\n  /**\n   * Bitwise options to set different types of spans as Internal in\n   * a workflow or agent execution. Internal spans are hidden by\n   * default in exported traces.\n   */\n  internal?: InternalSpans;\n}\n\n/**\n * Options passed when starting a new agent or workflow execution\n */\nexport interface TracingOptions {\n  /** Metadata to add to the root trace span */\n  metadata?: Record<string, any>;\n}\n\n/**\n * Context for AI tracing that flows through workflow and agent execution\n */\nexport interface TracingContext {\n  /** Current AI span for creating child spans and adding metadata */\n  currentSpan?: AnyAISpan;\n}\n\n/**\n * Properties returned to the user for working with traces externally.\n */\nexport type TracingProperties = {\n  /** Trace ID used on the execution (if the execution was traced). */\n  traceId?: string;\n};\n\n// ============================================================================\n// Registry Config Interfaces\n// ============================================================================\n\n/**\n * Configuration for a single tracing instance\n */\nexport interface TracingConfig {\n  /** Unique identifier for this config in the ai tracing registry */\n  name: string;\n  /** Service name for tracing */\n  serviceName: string;\n  /** Sampling strategy - controls whether tracing is collected (defaults to ALWAYS) */\n  sampling?: SamplingStrategy;\n  /** Custom exporters */\n  exporters?: AITracingExporter[];\n  /** Custom processors */\n  processors?: AISpanProcessor[];\n  /** Set to `true` if you want to see spans internal to the operation of mastra */\n  includeInternalSpans?: boolean;\n}\n\n/**\n * Complete AI Tracing registry configuration\n */\nexport interface ObservabilityRegistryConfig {\n  /** Enables default exporters, with sampling: always, and sensitive data filtering */\n  default?: {\n    enabled?: boolean;\n  };\n  /** Map of tracing instance names to their configurations or pre-instantiated instances */\n  configs?: Record<string, Omit<TracingConfig, 'name'> | AITracing>;\n  /** Optional selector function to choose which tracing instance to use */\n  configSelector?: ConfigSelector;\n}\n\n// ============================================================================\n// Sampling Strategy Interfaces\n// ============================================================================\n\n/**\n * Sampling strategy types\n */\nexport enum SamplingStrategyType {\n  ALWAYS = 'always',\n  NEVER = 'never',\n  RATIO = 'ratio',\n  CUSTOM = 'custom',\n}\n\n/**\n * Sampling strategy configuration\n */\nexport type SamplingStrategy =\n  | { type: SamplingStrategyType.ALWAYS }\n  | { type: SamplingStrategyType.NEVER }\n  | { type: SamplingStrategyType.RATIO; probability: number }\n  | { type: SamplingStrategyType.CUSTOM; sampler: (options?: CustomSamplerOptions) => boolean };\n\n/**\n * Options passed when using a custom sampler strategy\n */\nexport interface CustomSamplerOptions {\n  runtimeContext?: RuntimeContext;\n  metadata?: Record<string, any>;\n}\n\n// ============================================================================\n// Exporter and Processor Interfaces\n// ============================================================================\n\n/**\n * AI Tracing event types\n */\nexport enum AITracingEventType {\n  SPAN_STARTED = 'span_started',\n  SPAN_UPDATED = 'span_updated',\n  SPAN_ENDED = 'span_ended',\n}\n\n/**\n * Tracing events that can be exported\n */\nexport type AITracingEvent =\n  | { type: AITracingEventType.SPAN_STARTED; exportedSpan: AnyExportedAISpan }\n  | { type: AITracingEventType.SPAN_UPDATED; exportedSpan: AnyExportedAISpan }\n  | { type: AITracingEventType.SPAN_ENDED; exportedSpan: AnyExportedAISpan };\n\n/**\n * Interface for tracing exporters\n */\nexport interface AITracingExporter {\n  /** Exporter name */\n  name: string;\n\n  /** Initialize exporter with tracing configuration */\n  init?(config: TracingConfig): void;\n\n  /** Export tracing events */\n  exportEvent(event: AITracingEvent): Promise<void>;\n\n  addScoreToTrace?({\n    traceId,\n    spanId,\n    score,\n    reason,\n    scorerName,\n    metadata,\n  }: {\n    traceId: string;\n    spanId?: string;\n    score: number;\n    reason?: string;\n    scorerName: string;\n    metadata?: Record<string, any>;\n  }): Promise<void>;\n\n  /** Shutdown exporter */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Interface for span processors\n */\nexport interface AISpanProcessor {\n  /** Processor name */\n  name: string;\n  /** Process span before export */\n  process(span?: AnyAISpan): AnyAISpan | undefined;\n  /** Shutdown processor */\n  shutdown(): Promise<void>;\n}\n\n// ============================================================================\n// Tracing Config Selector Interfaces\n// ============================================================================\n\n/**\n *  Options passed when using a custom tracing config selector\n */\nexport interface ConfigSelectorOptions {\n  /** Runtime context */\n  runtimeContext?: RuntimeContext;\n}\n\n/**\n * Function to select which AI tracing instance to use for a given span\n * Returns the name of the tracing instance, or undefined to use default\n */\nexport type ConfigSelector = (\n  options: ConfigSelectorOptions,\n  availableConfigs: ReadonlyMap<string, AITracing>,\n) => string | undefined;\n\n// ============================================================================\n// Tracing Storage Interfaces\n// ============================================================================\n\nexport type TracingStrategy = 'realtime' | 'batch-with-updates' | 'insert-only';\n","import type {\n  AISpan,\n  AISpanTypeMap,\n  AnyAISpan,\n  ChildSpanOptions,\n  ChildEventOptions,\n  EndSpanOptions,\n  ErrorSpanOptions,\n  UpdateSpanOptions,\n  CreateSpanOptions,\n  AITracing,\n  ExportedAISpan,\n} from '../types';\n\nimport { AISpanType, InternalSpans } from '../types';\n\n/**\n * Determines if a span type should be considered internal based on flags.\n * Returns false if flags are undefined.\n */\nfunction isSpanInternal(spanType: AISpanType, flags?: InternalSpans): boolean {\n  if (flags === undefined || flags === InternalSpans.NONE) {\n    return false;\n  }\n\n  switch (spanType) {\n    // Workflow-related spans\n    case AISpanType.WORKFLOW_RUN:\n    case AISpanType.WORKFLOW_STEP:\n    case AISpanType.WORKFLOW_CONDITIONAL:\n    case AISpanType.WORKFLOW_CONDITIONAL_EVAL:\n    case AISpanType.WORKFLOW_PARALLEL:\n    case AISpanType.WORKFLOW_LOOP:\n    case AISpanType.WORKFLOW_SLEEP:\n    case AISpanType.WORKFLOW_WAIT_EVENT:\n      return (flags & InternalSpans.WORKFLOW) !== 0;\n\n    // Agent-related spans\n    case AISpanType.AGENT_RUN:\n      return (flags & InternalSpans.AGENT) !== 0;\n\n    // Tool-related spans\n    case AISpanType.TOOL_CALL:\n    case AISpanType.MCP_TOOL_CALL:\n      return (flags & InternalSpans.TOOL) !== 0;\n\n    // LLM-related spans\n    case AISpanType.LLM_GENERATION:\n    case AISpanType.LLM_CHUNK:\n      return (flags & InternalSpans.LLM) !== 0;\n\n    // Default: never internal\n    default:\n      return false;\n  }\n}\n\nexport abstract class BaseAISpan<TType extends AISpanType = any> implements AISpan<TType> {\n  public abstract id: string;\n  public abstract traceId: string;\n\n  public name: string;\n  public type: TType;\n  public attributes: AISpanTypeMap[TType];\n  public parent?: AnyAISpan;\n  public startTime: Date;\n  public endTime?: Date;\n  public isEvent: boolean;\n  public isInternal: boolean;\n  public aiTracing: AITracing;\n  public input?: any;\n  public output?: any;\n  public errorInfo?: {\n    message: string;\n    id?: string;\n    domain?: string;\n    category?: string;\n    details?: Record<string, any>;\n  };\n  public metadata?: Record<string, any>;\n\n  constructor(options: CreateSpanOptions<TType>, aiTracing: AITracing) {\n    this.name = options.name;\n    this.type = options.type;\n    this.attributes = deepClean(options.attributes) || ({} as AISpanTypeMap[TType]);\n    this.metadata = deepClean(options.metadata);\n    this.parent = options.parent;\n    this.startTime = new Date();\n    this.aiTracing = aiTracing;\n    this.isEvent = options.isEvent ?? false;\n    this.isInternal = isSpanInternal(this.type, options.tracingPolicy?.internal);\n\n    if (this.isEvent) {\n      // Event spans don't have endTime or input.\n      // Event spans are immediately emitted by the BaseAITracing class via the end() event.\n      this.output = deepClean(options.output);\n    } else {\n      this.input = deepClean(options.input);\n    }\n  }\n\n  // Methods for span lifecycle\n  /** End the span */\n  abstract end(options?: EndSpanOptions<TType>): void;\n\n  /** Record an error for the span, optionally end the span as well */\n  abstract error(options: ErrorSpanOptions<TType>): void;\n\n  /** Update span attributes */\n  abstract update(options: UpdateSpanOptions<TType>): void;\n\n  createChildSpan<TChildType extends AISpanType>(options: ChildSpanOptions<TChildType>): AISpan<TChildType> {\n    return this.aiTracing.startSpan<TChildType>({ ...options, parent: this, isEvent: false });\n  }\n\n  createEventSpan<TChildType extends AISpanType>(options: ChildEventOptions<TChildType>): AISpan<TChildType> {\n    return this.aiTracing.startSpan<TChildType>({ ...options, parent: this, isEvent: true });\n  }\n\n  /** Returns `TRUE` if the span is the root span of a trace */\n  get isRootSpan(): boolean {\n    return !this.parent;\n  }\n\n  /** Returns `TRUE` if the span is a valid span (not a NO-OP Span) */\n  abstract get isValid(): boolean;\n\n  /** Get the closest parent spanId that isn't an internal span */\n  public getParentSpanId(includeInternalSpans?: boolean): string | undefined {\n    if (!this.parent) return undefined; // no parent at all\n    if (includeInternalSpans) return this.parent.id;\n    if (this.parent.isInternal) return this.parent.getParentSpanId(includeInternalSpans);\n\n    return this.parent.id;\n  }\n\n  /** Find the closest parent span of a specific type by walking up the parent chain */\n  public findParent<T extends AISpanType>(spanType: T): AISpan<T> | undefined {\n    let current: AnyAISpan | undefined = this.parent;\n\n    while (current) {\n      if (current.type === spanType) {\n        return current as AISpan<T>;\n      }\n      current = current.parent;\n    }\n\n    return undefined;\n  }\n\n  /** Returns a lightweight span ready for export */\n  public exportSpan(includeInternalSpans?: boolean): ExportedAISpan<TType> {\n    return {\n      id: this.id,\n      traceId: this.traceId,\n      name: this.name,\n      type: this.type,\n      attributes: this.attributes,\n      metadata: this.metadata,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      input: this.input,\n      output: this.output,\n      errorInfo: this.errorInfo,\n      isEvent: this.isEvent,\n      isRootSpan: this.isRootSpan,\n      parentSpanId: this.getParentSpanId(includeInternalSpans),\n    };\n  }\n}\n\nconst DEFAULT_KEYS_TO_STRIP = new Set([\n  'logger',\n  'experimental_providerMetadata',\n  'providerMetadata',\n  'steps',\n  'tracingContext',\n]);\nexport interface DeepCleanOptions {\n  keysToStrip?: Set<string>;\n  maxDepth?: number;\n}\n\n/**\n * Recursively cleans a value by removing circular references and stripping problematic or sensitive keys.\n * Circular references are replaced with \"[Circular]\". Unserializable values are replaced with error messages.\n * Keys like \"logger\" and \"tracingContext\" are stripped by default.\n * A maximum recursion depth is enforced to avoid stack overflow or excessive memory usage.\n *\n * @param value - The value to clean (object, array, primitive, etc.)\n * @param options - Optional configuration:\n *   - keysToStrip: Set of keys to remove from objects (default: logger, tracingContext)\n *   - maxDepth: Maximum recursion depth before values are replaced with \"[MaxDepth]\" (default: 10)\n * @returns A cleaned version of the input with circular references, specified keys, and overly deep values handled\n */\nexport function deepClean(\n  value: any,\n  options: DeepCleanOptions = {},\n  _seen: WeakSet<any> = new WeakSet(),\n  _depth: number = 0,\n): any {\n  const { keysToStrip = DEFAULT_KEYS_TO_STRIP, maxDepth = 10 } = options;\n\n  if (_depth > maxDepth) {\n    return '[MaxDepth]';\n  }\n\n  if (value === null || typeof value !== 'object') {\n    try {\n      JSON.stringify(value);\n      return value;\n    } catch (error) {\n      return `[${error instanceof Error ? error.message : String(error)}]`;\n    }\n  }\n\n  if (_seen.has(value)) {\n    return '[Circular]';\n  }\n\n  _seen.add(value);\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClean(item, options, _seen, _depth + 1));\n  }\n\n  const cleaned: Record<string, any> = {};\n  for (const [key, val] of Object.entries(value)) {\n    if (keysToStrip.has(key)) {\n      continue;\n    }\n\n    try {\n      cleaned[key] = deepClean(val, options, _seen, _depth + 1);\n    } catch (error) {\n      cleaned[key] = `[${error instanceof Error ? error.message : String(error)}]`;\n    }\n  }\n\n  return cleaned;\n}\n","import { MastraError } from '../../error';\nimport type {\n  AISpanType,\n  AITracing,\n  EndSpanOptions,\n  ErrorSpanOptions,\n  UpdateSpanOptions,\n  CreateSpanOptions,\n} from '../types';\nimport { BaseAISpan, deepClean } from './base';\n\nexport class DefaultAISpan<TType extends AISpanType> extends BaseAISpan<TType> {\n  public id: string;\n  public traceId: string;\n\n  constructor(options: CreateSpanOptions<TType>, aiTracing: AITracing) {\n    super(options, aiTracing);\n    this.id = generateSpanId();\n\n    // Set trace ID: generate new for root spans, inherit for child spans\n    if (!options.parent) {\n      // This is a root span, so it becomes its own trace with a new trace ID\n      this.traceId = generateTraceId();\n    } else {\n      // Child span inherits trace ID from root span\n      this.traceId = options.parent.traceId;\n    }\n  }\n\n  end(options?: EndSpanOptions<TType>): void {\n    if (this.isEvent) {\n      return;\n    }\n    this.endTime = new Date();\n    if (options?.output !== undefined) {\n      this.output = deepClean(options.output);\n    }\n    if (options?.attributes) {\n      this.attributes = { ...this.attributes, ...deepClean(options.attributes) };\n    }\n    if (options?.metadata) {\n      this.metadata = { ...this.metadata, ...deepClean(options.metadata) };\n    }\n    // Tracing events automatically handled by base class\n  }\n\n  error(options: ErrorSpanOptions<TType>): void {\n    if (this.isEvent) {\n      return;\n    }\n\n    const { error, endSpan = true, attributes, metadata } = options;\n\n    this.errorInfo =\n      error instanceof MastraError\n        ? {\n            id: error.id,\n            details: error.details,\n            category: error.category,\n            domain: error.domain,\n            message: error.message,\n          }\n        : {\n            message: error.message,\n          };\n\n    // Update attributes if provided\n    if (attributes) {\n      this.attributes = { ...this.attributes, ...deepClean(attributes) };\n    }\n    if (metadata) {\n      this.metadata = { ...this.metadata, ...deepClean(metadata) };\n    }\n\n    if (endSpan) {\n      this.end();\n    } else {\n      // Trigger span update event when not ending the span\n      this.update({});\n    }\n  }\n\n  update(options: UpdateSpanOptions<TType>): void {\n    if (this.isEvent) {\n      return;\n    }\n\n    if (options.input !== undefined) {\n      this.input = deepClean(options.input);\n    }\n    if (options.output !== undefined) {\n      this.output = deepClean(options.output);\n    }\n    if (options.attributes) {\n      this.attributes = { ...this.attributes, ...deepClean(options.attributes) };\n    }\n    if (options.metadata) {\n      this.metadata = { ...this.metadata, ...deepClean(options.metadata) };\n    }\n    // Tracing events automatically handled by base class\n  }\n\n  get isValid(): boolean {\n    return true;\n  }\n\n  async export(): Promise<string> {\n    return JSON.stringify({\n      spanId: this.id,\n      traceId: this.traceId,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      attributes: this.attributes,\n      metadata: this.metadata,\n    });\n  }\n}\n\n/**\n * Generate OpenTelemetry-compatible span ID (64-bit, 16 hex chars)\n */\nfunction generateSpanId(): string {\n  // Generate 8 random bytes (64 bits) in hex format\n  const bytes = new Uint8Array(8);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Fallback for environments without crypto.getRandomValues\n    for (let i = 0; i < 8; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Generate OpenTelemetry-compatible trace ID (128-bit, 32 hex chars)\n */\nfunction generateTraceId(): string {\n  // Generate 16 random bytes (128 bits) in hex format\n  const bytes = new Uint8Array(16);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Fallback for environments without crypto.getRandomValues\n    for (let i = 0; i < 16; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n","/**\n * No Op Implementation for MastraAITracing\n */\n\nimport type {\n  AITracing,\n  AISpanType,\n  CreateSpanOptions,\n  EndSpanOptions,\n  UpdateSpanOptions,\n  ErrorSpanOptions,\n} from '../types';\nimport { BaseAISpan } from './base';\n\nexport class NoOpAISpan<TType extends AISpanType = any> extends BaseAISpan<TType> {\n  public id: string;\n  public traceId: string;\n\n  constructor(options: CreateSpanOptions<TType>, aiTracing: AITracing) {\n    super(options, aiTracing);\n    this.id = 'no-op';\n    this.traceId = 'no-op-trace';\n  }\n\n  end(_options?: EndSpanOptions<TType>): void {}\n\n  error(_options: ErrorSpanOptions<TType>): void {}\n\n  update(_options: UpdateSpanOptions<TType>): void {}\n\n  get isValid(): boolean {\n    return false;\n  }\n}\n","/**\n * MastraAITracing - Abstract base class for AI Tracing implementations\n */\n\nimport { MastraBase } from '../../base';\nimport type { IMastraLogger } from '../../logger';\nimport { RegisteredLogger } from '../../logger/constants';\nimport { NoOpAISpan } from '../spans/no-op';\nimport type {\n  TracingConfig,\n  AISpan,\n  AISpanType,\n  AITracingExporter,\n  AISpanProcessor,\n  AITracingEvent,\n  AnyAISpan,\n  EndSpanOptions,\n  UpdateSpanOptions,\n  StartSpanOptions,\n  CreateSpanOptions,\n  AITracing,\n  CustomSamplerOptions,\n  AnyExportedAISpan,\n} from '../types';\nimport { SamplingStrategyType, AITracingEventType } from '../types';\n\n// ============================================================================\n// Abstract Base Class\n// ============================================================================\n\n/**\n * Abstract base class for all AI Tracing implementations in Mastra.\n */\nexport abstract class BaseAITracing extends MastraBase implements AITracing {\n  protected config: Required<TracingConfig>;\n\n  constructor(config: TracingConfig) {\n    super({ component: RegisteredLogger.AI_TRACING, name: config.serviceName });\n\n    // Apply defaults for optional fields\n    this.config = {\n      serviceName: config.serviceName,\n      name: config.name,\n      sampling: config.sampling ?? { type: SamplingStrategyType.ALWAYS },\n      exporters: config.exporters ?? [],\n      processors: config.processors ?? [],\n      includeInternalSpans: config.includeInternalSpans ?? false,\n    };\n  }\n\n  /**\n   * Override setLogger to add AI tracing specific initialization log\n   */\n  __setLogger(logger: IMastraLogger) {\n    super.__setLogger(logger);\n    // Log AI tracing initialization details after logger is properly set\n    this.logger.debug(\n      `[AI Tracing] Initialized [service=${this.config.serviceName}] [instance=${this.config.name}] [sampling=${this.config.sampling.type}]`,\n    );\n  }\n\n  // ============================================================================\n  // Protected getters for clean config access\n  // ============================================================================\n\n  protected get exporters(): AITracingExporter[] {\n    return this.config.exporters || [];\n  }\n\n  protected get processors(): AISpanProcessor[] {\n    return this.config.processors || [];\n  }\n\n  // ============================================================================\n  // Public API - Single type-safe span creation method\n  // ============================================================================\n\n  /**\n   * Start a new span of a specific AISpanType\n   */\n  startSpan<TType extends AISpanType>(options: StartSpanOptions<TType>): AISpan<TType> {\n    const { customSamplerOptions, ...createSpanOptions } = options;\n\n    if (!this.shouldSample(customSamplerOptions)) {\n      return new NoOpAISpan<TType>(createSpanOptions, this);\n    }\n\n    const span = this.createSpan<TType>(createSpanOptions);\n\n    if (span.isEvent) {\n      this.emitSpanEnded(span);\n    } else {\n      // Automatically wire up tracing lifecycle\n      this.wireSpanLifecycle(span);\n\n      // Emit span started event\n      this.emitSpanStarted(span);\n    }\n\n    return span;\n  }\n\n  // ============================================================================\n  // Abstract Methods - Must be implemented by concrete classes\n  // ============================================================================\n\n  /**\n   * Create a new span (called after sampling)\n   *\n   * Implementations should:\n   * 1. Create a plain span with the provided attributes\n   * 2. Return the span - base class handles all tracing lifecycle automatically\n   *\n   * The base class will automatically:\n   * - Set trace relationships\n   * - Wire span lifecycle callbacks\n   * - Emit span_started event\n   */\n  protected abstract createSpan<TType extends AISpanType>(options: CreateSpanOptions<TType>): AISpan<TType>;\n\n  // ============================================================================\n  // Configuration Management\n  // ============================================================================\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<Required<TracingConfig>> {\n    return { ...this.config };\n  }\n\n  // ============================================================================\n  // Plugin Access\n  // ============================================================================\n\n  /**\n   * Get all exporters\n   */\n  getExporters(): readonly AITracingExporter[] {\n    return [...this.exporters];\n  }\n\n  /**\n   * Get all processors\n   */\n  getProcessors(): readonly AISpanProcessor[] {\n    return [...this.processors];\n  }\n\n  /**\n   * Get the logger instance (for exporters and other components)\n   */\n  getLogger() {\n    return this.logger;\n  }\n\n  // ============================================================================\n  // Span Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Automatically wires up AI tracing lifecycle events for any span\n   * This ensures all spans emit events regardless of implementation\n   */\n  private wireSpanLifecycle<TType extends AISpanType>(span: AISpan<TType>): void {\n    // bypass wire up if internal span and not includeInternalSpans\n    if (!this.config.includeInternalSpans && span.isInternal) {\n      return;\n    }\n\n    // Store original methods\n    const originalEnd = span.end.bind(span);\n    const originalUpdate = span.update.bind(span);\n\n    // Wrap methods to automatically emit tracing events\n    span.end = (options?: EndSpanOptions<TType>) => {\n      if (span.isEvent) {\n        this.logger.warn(`End event is not available on event spans`);\n        return;\n      }\n      originalEnd(options);\n      this.emitSpanEnded(span);\n    };\n\n    span.update = (options: UpdateSpanOptions<TType>) => {\n      if (span.isEvent) {\n        this.logger.warn(`Update() is not available on event spans`);\n        return;\n      }\n      originalUpdate(options);\n      this.emitSpanUpdated(span);\n    };\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Check if an AI trace should be sampled\n   */\n  protected shouldSample(options?: CustomSamplerOptions): boolean {\n    // Check built-in sampling strategy\n    const { sampling } = this.config;\n\n    switch (sampling.type) {\n      case SamplingStrategyType.ALWAYS:\n        return true;\n      case SamplingStrategyType.NEVER:\n        return false;\n      case SamplingStrategyType.RATIO:\n        if (sampling.probability === undefined || sampling.probability < 0 || sampling.probability > 1) {\n          this.logger.warn(\n            `Invalid sampling probability: ${sampling.probability}. Expected value between 0 and 1. Defaulting to no sampling.`,\n          );\n          return false;\n        }\n        return Math.random() < sampling.probability;\n      case SamplingStrategyType.CUSTOM:\n        return sampling.sampler(options);\n      default:\n        throw new Error(`Sampling strategy type not implemented: ${(sampling as any).type}`);\n    }\n  }\n\n  /**\n   * Process a span through all processors\n   */\n  private processSpan(span?: AnyAISpan): AnyAISpan | undefined {\n    for (const processor of this.processors) {\n      if (!span) {\n        break;\n      }\n\n      try {\n        span = processor.process(span);\n      } catch (error) {\n        this.logger.error(`[AI Tracing] Processor error [name=${processor.name}]`, error);\n        // Continue with other processors\n      }\n    }\n\n    return span;\n  }\n\n  // ============================================================================\n  // Event-driven Export Methods\n  // ============================================================================\n\n  getSpanForExport(span: AnyAISpan): AnyExportedAISpan | undefined {\n    if (!span.isValid) return undefined;\n    if (span.isInternal && !this.config.includeInternalSpans) return undefined;\n\n    const processedSpan = this.processSpan(span);\n    return processedSpan?.exportSpan(this.config.includeInternalSpans);\n  }\n\n  /**\n   * Emit a span started event\n   */\n  protected emitSpanStarted(span: AnyAISpan): void {\n    const exportedSpan = this.getSpanForExport(span);\n    if (exportedSpan) {\n      this.exportEvent({ type: AITracingEventType.SPAN_STARTED, exportedSpan }).catch(error => {\n        this.logger.error('[AI Tracing] Failed to export span_started event', error);\n      });\n    }\n  }\n\n  /**\n   * Emit a span ended event (called automatically when spans end)\n   */\n  protected emitSpanEnded(span: AnyAISpan): void {\n    const exportedSpan = this.getSpanForExport(span);\n    if (exportedSpan) {\n      this.exportEvent({ type: AITracingEventType.SPAN_ENDED, exportedSpan }).catch(error => {\n        this.logger.error('[AI Tracing] Failed to export span_ended event', error);\n      });\n    }\n  }\n\n  /**\n   * Emit a span updated event\n   */\n  protected emitSpanUpdated(span: AnyAISpan): void {\n    const exportedSpan = this.getSpanForExport(span);\n    if (exportedSpan) {\n      this.exportEvent({ type: AITracingEventType.SPAN_UPDATED, exportedSpan }).catch(error => {\n        this.logger.error('[AI Tracing] Failed to export span_updated event', error);\n      });\n    }\n  }\n\n  /**\n   * Export tracing event through all exporters (realtime mode)\n   */\n  protected async exportEvent(event: AITracingEvent): Promise<void> {\n    const exportPromises = this.exporters.map(async exporter => {\n      try {\n        if (exporter.exportEvent) {\n          await exporter.exportEvent(event);\n          this.logger.debug(`[AI Tracing] Event exported [exporter=${exporter.name}] [type=${event.type}]`);\n        }\n      } catch (error) {\n        this.logger.error(`[AI Tracing] Export error [exporter=${exporter.name}]`, error);\n        // Don't rethrow - continue with other exporters\n      }\n    });\n\n    await Promise.allSettled(exportPromises);\n  }\n\n  // ============================================================================\n  // Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Initialize AI tracing (called by Mastra during component registration)\n   */\n  init(): void {\n    this.logger.debug(`[AI Tracing] Initialization started [name=${this.name}]`);\n\n    // Any initialization logic for the AI tracing system\n    // This could include setting up queues, starting background processes, etc.\n\n    this.logger.info(`[AI Tracing] Initialized successfully [name=${this.name}]`);\n  }\n\n  /**\n   * Shutdown AI tracing and clean up resources\n   */\n  async shutdown(): Promise<void> {\n    this.logger.debug(`[AI Tracing] Shutdown started [name=${this.name}]`);\n\n    // Shutdown all components\n    const shutdownPromises = [...this.exporters.map(e => e.shutdown()), ...this.processors.map(p => p.shutdown())];\n\n    await Promise.allSettled(shutdownPromises);\n\n    this.logger.info(`[AI Tracing] Shutdown completed [name=${this.name}]`);\n  }\n}\n","import { DefaultAISpan } from '../spans';\nimport type { AISpanType, AISpan, TracingConfig, CreateSpanOptions } from '../types';\nimport { BaseAITracing } from './base';\n\nexport class DefaultAITracing extends BaseAITracing {\n  constructor(config: TracingConfig) {\n    super(config);\n  }\n\n  protected createSpan<TType extends AISpanType>(options: CreateSpanOptions<TType>): AISpan<TType> {\n    // Simple span creation - base class handles all tracing lifecycle automatically\n    return new DefaultAISpan<TType>(options, this);\n  }\n}\n","import type { ToolCallOptions } from '@ai-sdk/provider-utils-v5';\nimport {\n  OpenAIReasoningSchemaCompatLayer,\n  OpenAISchemaCompatLayer,\n  GoogleSchemaCompatLayer,\n  AnthropicSchemaCompatLayer,\n  DeepSeekSchemaCompatLayer,\n  MetaSchemaCompatLayer,\n  applyCompatLayer,\n  convertZodSchemaToAISDKSchema,\n} from '@mastra/schema-compat';\nimport type { ToolExecutionOptions } from 'ai';\nimport { z } from 'zod';\nimport { AISpanType, wrapMastra } from '../../ai-tracing';\nimport { MastraBase } from '../../base';\nimport { ErrorCategory, MastraError, ErrorDomain } from '../../error';\nimport { RuntimeContext } from '../../runtime-context';\nimport { isVercelTool } from '../../tools/toolchecks';\nimport type { ToolOptions } from '../../utils';\nimport { ToolStream } from '../stream';\nimport type { CoreTool, ToolAction, ToolInvocationOptions, VercelTool, VercelToolV5 } from '../types';\nimport { validateToolInput } from '../validation';\n\nexport type ToolToConvert = VercelTool | ToolAction<any, any, any> | VercelToolV5;\nexport type LogType = 'tool' | 'toolset' | 'client-tool';\n\ninterface LogOptions {\n  agentName?: string;\n  toolName: string;\n  type?: 'tool' | 'toolset' | 'client-tool';\n}\n\ninterface LogMessageOptions {\n  start: string;\n  error: string;\n}\n\nexport class CoreToolBuilder extends MastraBase {\n  private originalTool: ToolToConvert;\n  private options: ToolOptions;\n  private logType?: LogType;\n\n  constructor(input: { originalTool: ToolToConvert; options: ToolOptions; logType?: LogType }) {\n    super({ name: 'CoreToolBuilder' });\n    this.originalTool = input.originalTool;\n    this.options = input.options;\n    this.logType = input.logType;\n  }\n\n  // Helper to get parameters based on tool type\n  private getParameters = () => {\n    if (isVercelTool(this.originalTool)) {\n      return this.originalTool.parameters ?? z.object({});\n    }\n\n    return this.originalTool.inputSchema ?? z.object({});\n  };\n\n  private getOutputSchema = () => {\n    if ('outputSchema' in this.originalTool) return this.originalTool.outputSchema;\n    return null;\n  };\n\n  // For provider-defined tools, we need to include all required properties\n  private buildProviderTool(tool: ToolToConvert): (CoreTool & { id: `${string}.${string}` }) | undefined {\n    if (\n      'type' in tool &&\n      tool.type === 'provider-defined' &&\n      'id' in tool &&\n      typeof tool.id === 'string' &&\n      tool.id.includes('.')\n    ) {\n      const parameters = this.getParameters();\n      const outputSchema = this.getOutputSchema();\n      return {\n        type: 'provider-defined' as const,\n        id: tool.id,\n        args: ('args' in this.originalTool ? this.originalTool.args : {}) as Record<string, unknown>,\n        description: tool.description,\n        parameters: convertZodSchemaToAISDKSchema(parameters),\n        ...(outputSchema ? { outputSchema: convertZodSchemaToAISDKSchema(outputSchema) } : {}),\n        execute: this.originalTool.execute\n          ? this.createExecute(\n              this.originalTool,\n              { ...this.options, description: this.originalTool.description },\n              this.logType,\n            )\n          : undefined,\n      };\n    }\n\n    return undefined;\n  }\n\n  private createLogMessageOptions({ agentName, toolName, type }: LogOptions): LogMessageOptions {\n    // If no agent name, use default format\n    if (!agentName) {\n      return {\n        start: `Executing tool ${toolName}`,\n        error: `Failed tool execution`,\n      };\n    }\n\n    const prefix = `[Agent:${agentName}]`;\n    const toolType = type === 'toolset' ? 'toolset' : 'tool';\n\n    return {\n      start: `${prefix} - Executing ${toolType} ${toolName}`,\n      error: `${prefix} - Failed ${toolType} execution`,\n    };\n  }\n\n  private createExecute(tool: ToolToConvert, options: ToolOptions, logType?: 'tool' | 'toolset' | 'client-tool') {\n    // dont't add memory or mastra to logging\n    const { logger, mastra: _mastra, memory: _memory, runtimeContext, model, ...rest } = options;\n    const logModelObject = {\n      modelId: model?.modelId,\n      provider: model?.provider,\n      specificationVersion: model?.specificationVersion,\n    };\n\n    const { start, error } = this.createLogMessageOptions({\n      agentName: options.agentName,\n      toolName: options.name,\n      type: logType,\n    });\n\n    const execFunction = async (args: unknown, execOptions: ToolInvocationOptions) => {\n      // Create tool span if we have an current span available\n      const toolSpan = options.tracingContext?.currentSpan?.createChildSpan({\n        type: AISpanType.TOOL_CALL,\n        name: `tool: '${options.name}'`,\n        input: args,\n        attributes: {\n          toolId: options.name,\n          toolDescription: options.description,\n          toolType: logType || 'tool',\n        },\n        tracingPolicy: options.tracingPolicy,\n      });\n\n      try {\n        let result;\n\n        if (isVercelTool(tool)) {\n          // Handle Vercel tools (AI SDK tools)\n          result = await tool?.execute?.(args, execOptions as ToolExecutionOptions);\n        } else {\n          // Handle Mastra tools - wrap mastra instance with tracing context for context propagation\n\n          /**\n           * MASTRA INSTANCE TYPES IN TOOL EXECUTION:\n           *\n           * Full Mastra & MastraPrimitives (has getAgent, getWorkflow, etc.):\n           * - Auto-generated workflow tools from agent.getWorkflows()\n           * - These get this.#mastra directly and can be wrapped\n           *\n           * MastraPrimitives only (limited interface):\n           * - Memory tools (from memory.getTools())\n           * - Assigned tools (agent.tools)\n           * - Toolset tools (from toolsets)\n           * - Client tools (passed as tools in generate/stream options)\n           * - These get mastraProxy and have limited functionality\n           *\n           * TODO: Consider providing full Mastra instance to more tool types for enhanced functionality\n           */\n          // Wrap mastra with tracing context - wrapMastra will handle whether it's a full instance or primitives\n          const wrappedMastra = options.mastra ? wrapMastra(options.mastra, { currentSpan: toolSpan }) : options.mastra;\n\n          result = await tool?.execute?.(\n            {\n              context: args,\n              threadId: options.threadId,\n              resourceId: options.resourceId,\n              mastra: wrappedMastra,\n              memory: options.memory,\n              runId: options.runId,\n              runtimeContext: options.runtimeContext ?? new RuntimeContext(),\n              writer: new ToolStream(\n                {\n                  prefix: 'tool',\n                  callId: execOptions.toolCallId,\n                  name: options.name,\n                  runId: options.runId!,\n                },\n                options.writableStream || (execOptions as any).writableStream,\n              ),\n              tracingContext: { currentSpan: toolSpan },\n            },\n            execOptions as ToolExecutionOptions & ToolCallOptions,\n          );\n        }\n\n        toolSpan?.end({ output: result });\n        return result ?? undefined;\n      } catch (error) {\n        toolSpan?.error({ error: error as Error });\n        throw error;\n      }\n    };\n\n    return async (args: unknown, execOptions?: ToolInvocationOptions) => {\n      let logger = options.logger || this.logger;\n      try {\n        logger.debug(start, { ...rest, model: logModelObject, args });\n\n        // Validate input parameters if schema exists\n        const parameters = this.getParameters();\n        const { data, error } = validateToolInput(parameters, args, options.name);\n        if (error) {\n          logger.warn(`Tool input validation failed for '${options.name}'`, {\n            toolName: options.name,\n            errors: error.validationErrors,\n            args,\n          });\n          return error;\n        }\n        // Use validated/transformed data\n        args = data;\n\n        // there is a small delay in stream output so we add an immediate to ensure the stream is ready\n        return await new Promise((resolve, reject) => {\n          setImmediate(async () => {\n            try {\n              const result = await execFunction(args, execOptions!);\n              resolve(result);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        });\n      } catch (err) {\n        const mastraError = new MastraError(\n          {\n            id: 'TOOL_EXECUTION_FAILED',\n            domain: ErrorDomain.TOOL,\n            category: ErrorCategory.USER,\n            details: {\n              errorMessage: String(error),\n              argsJson: JSON.stringify(args),\n              model: model?.modelId ?? '',\n            },\n          },\n          err,\n        );\n        logger.trackException(mastraError);\n        logger.error(error, { ...rest, model: logModelObject, error: mastraError, args });\n        return mastraError;\n      }\n    };\n  }\n\n  buildV5() {\n    const builtTool = this.build();\n\n    if (!builtTool.parameters) {\n      throw new Error('Tool parameters are required');\n    }\n\n    return {\n      ...builtTool,\n      inputSchema: builtTool.parameters,\n      onInputStart: 'onInputStart' in this.originalTool ? this.originalTool.onInputStart : undefined,\n      onInputDelta: 'onInputDelta' in this.originalTool ? this.originalTool.onInputDelta : undefined,\n      onInputAvailable: 'onInputAvailable' in this.originalTool ? this.originalTool.onInputAvailable : undefined,\n    } as VercelToolV5;\n  }\n\n  build(): CoreTool {\n    const providerTool = this.buildProviderTool(this.originalTool);\n    if (providerTool) {\n      return providerTool;\n    }\n\n    const definition = {\n      type: 'function' as const,\n      description: this.originalTool.description,\n      parameters: this.getParameters(),\n      outputSchema: this.getOutputSchema(),\n      requireApproval: this.options.requireApproval,\n      execute: this.originalTool.execute\n        ? this.createExecute(\n            this.originalTool,\n            { ...this.options, description: this.originalTool.description },\n            this.logType,\n          )\n        : undefined,\n    };\n\n    const model = this.options.model;\n\n    const schemaCompatLayers = [];\n\n    if (model) {\n      const supportsStructuredOutputs =\n        model.specificationVersion !== 'v2' ? (model.supportsStructuredOutputs ?? false) : false;\n\n      const modelInfo = {\n        modelId: model.modelId,\n        supportsStructuredOutputs,\n        provider: model.provider,\n      };\n\n      schemaCompatLayers.push(\n        new OpenAIReasoningSchemaCompatLayer(modelInfo),\n        new OpenAISchemaCompatLayer(modelInfo),\n        new GoogleSchemaCompatLayer(modelInfo),\n        new AnthropicSchemaCompatLayer(modelInfo),\n        new DeepSeekSchemaCompatLayer(modelInfo),\n        new MetaSchemaCompatLayer(modelInfo),\n      );\n    }\n\n    const processedSchema = applyCompatLayer({\n      schema: this.getParameters(),\n      compatLayers: schemaCompatLayers,\n      mode: 'aiSdkSchema',\n    });\n\n    let processedOutputSchema;\n\n    if (this.getOutputSchema()) {\n      processedOutputSchema = applyCompatLayer({\n        schema: this.getOutputSchema(),\n        compatLayers: schemaCompatLayers,\n        mode: 'aiSdkSchema',\n      });\n    }\n\n    return {\n      ...definition,\n      id: 'id' in this.originalTool ? this.originalTool.id : undefined,\n      parameters: processedSchema,\n      outputSchema: processedOutputSchema,\n    };\n  }\n}\n","import { createHash } from 'crypto';\nimport type { WritableStream } from 'stream/web';\nimport type { CoreMessage } from 'ai';\nimport jsonSchemaToZod from 'json-schema-to-zod';\nimport { z } from 'zod';\nimport type { MastraPrimitives } from './action';\nimport type { ToolsInput } from './agent';\nimport type { TracingContext, TracingPolicy } from './ai-tracing';\nimport type { MastraLanguageModel } from './llm/model/shared.types';\nimport type { IMastraLogger } from './logger';\nimport type { Mastra } from './mastra';\nimport type { AiMessageType, MastraMemory } from './memory';\nimport type { RuntimeContext } from './runtime-context';\nimport type { ChunkType } from './stream/types';\nimport type { CoreTool, VercelTool, VercelToolV5 } from './tools';\nimport { CoreToolBuilder } from './tools/tool-builder/builder';\nimport type { ToolToConvert } from './tools/tool-builder/builder';\nimport { isVercelTool } from './tools/toolchecks';\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Deep merges two objects, recursively merging nested objects and arrays\n */\nexport function deepMerge<T extends object = object>(target: T, source: Partial<T>): T {\n  const output = { ...target };\n\n  if (!source) return output;\n\n  Object.keys(source).forEach(key => {\n    const targetValue = output[key as keyof T];\n    const sourceValue = source[key as keyof T];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      (output as any)[key] = sourceValue;\n    } else if (\n      sourceValue instanceof Object &&\n      targetValue instanceof Object &&\n      !Array.isArray(sourceValue) &&\n      !Array.isArray(targetValue)\n    ) {\n      (output as any)[key] = deepMerge(targetValue, sourceValue as T);\n    } else if (sourceValue !== undefined) {\n      (output as any)[key] = sourceValue;\n    }\n  });\n\n  return output;\n}\n\nexport function generateEmptyFromSchema(schema: string) {\n  try {\n    const parsedSchema = JSON.parse(schema);\n    if (!parsedSchema || parsedSchema.type !== 'object' || !parsedSchema.properties) return {};\n    const obj: Record<string, any> = {};\n    const TYPE_DEFAULTS = {\n      string: '',\n      array: [],\n      object: {},\n      number: 0,\n      integer: 0,\n      boolean: false,\n    };\n    for (const [key, prop] of Object.entries<any>(parsedSchema.properties)) {\n      obj[key] = TYPE_DEFAULTS[prop.type as keyof typeof TYPE_DEFAULTS] ?? null;\n    }\n    return obj;\n  } catch {\n    return {};\n  }\n}\n\nexport interface TagMaskOptions {\n  /** Called when masking begins */\n  onStart?: () => void;\n  /** Called when masking ends */\n  onEnd?: () => void;\n  /** Called for each chunk that is masked */\n  onMask?: (chunk: string) => void;\n}\n\n/**\n * Transforms a stream by masking content between XML tags.\n * @param stream Input stream to transform\n * @param tag Tag name to mask between (e.g. for <foo>...</foo>, use 'foo')\n * @param options Optional configuration for masking behavior\n */\nexport async function* maskStreamTags(\n  stream: AsyncIterable<string>,\n  tag: string,\n  options: TagMaskOptions = {},\n): AsyncIterable<string> {\n  const { onStart, onEnd, onMask } = options;\n  const openTag = `<${tag}>`;\n  const closeTag = `</${tag}>`;\n\n  let buffer = '';\n  let fullContent = '';\n  let isMasking = false;\n  let isBuffering = false;\n\n  // used for checking in chunks that include tags or partial tags + some other non-tag text\n  // eg: \"o <tag_name\" or \"name> w\", can trim before-start to get \"<tag_name\" or after-end to get \"name>\"\n  const trimOutsideDelimiter = (text: string, delimiter: string, trim: 'before-start' | 'after-end') => {\n    if (!text.includes(delimiter)) {\n      return text;\n    }\n\n    const parts = text.split(delimiter);\n\n    if (trim === `before-start`) {\n      return `${delimiter}${parts[1]}`;\n    }\n\n    return `${parts[0]}${delimiter}`;\n  };\n\n  // Helper to check if text starts with pattern (ignoring whitespace)\n  // When checking partial tags: startsWith(buffer, openTag) checks if buffer could be start of tag\n  // When checking full tags: startsWith(chunk, openTag) checks if chunk starts with full tag\n  const startsWith = (text: string, pattern: string) => {\n    // check start of opening tag\n    if (pattern.includes(openTag.substring(0, 3))) {\n      // our pattern for checking the start is always based on xml-like tags\n      // if the pattern looks like our opening tag and the pattern also includes\n      // some other chunked text before it, we just wanted to check the xml part of the pattern\n      pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);\n    }\n\n    return text.trim().startsWith(pattern.trim());\n  };\n\n  for await (const chunk of stream) {\n    fullContent += chunk;\n\n    if (isBuffering) buffer += chunk;\n\n    const chunkHasTag = startsWith(chunk, openTag);\n    const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);\n\n    let toYieldBeforeMaskedStartTag = ``;\n    // Check if we should start masking chunks\n    if (!isMasking && (chunkHasTag || bufferHasTag)) {\n      isMasking = true;\n      isBuffering = false;\n\n      // check if the buffered text includes text before the start tag. ex \"o <tag_name\", \"o\" should be yielded and not masked\n      const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);\n      if (taggedTextToMask !== buffer.trim()) {\n        toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);\n      }\n\n      buffer = '';\n      onStart?.();\n    }\n\n    // Check if we should start buffering (looks like part of the opening tag but it's not the full <tag> yet eg <ta - could be <table> but we don't know yet)\n    if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== '') {\n      isBuffering = true;\n      buffer += chunk;\n      continue;\n    }\n\n    // We're buffering, need to check again if our buffer has deviated from the opening <tag> eg <tag2>\n    if (isBuffering && buffer && !startsWith(openTag, buffer)) {\n      yield buffer;\n      buffer = '';\n      isBuffering = false;\n      continue;\n    }\n\n    // Check if we should stop masking chunks (since the content includes the closing </tag>)\n    if (isMasking && fullContent.includes(closeTag)) {\n      onMask?.(chunk);\n      onEnd?.();\n      isMasking = false;\n      const lastFullContent = fullContent;\n      fullContent = ``; // reset to handle streams with multiple full tags that have text inbetween\n\n      // check to see if we have a partial chunk outside the close tag. if we do we need to yield it so it isn't swallowed with the masked text\n      const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, 'after-end');\n      if (textUntilEndTag !== lastFullContent) {\n        yield lastFullContent.replace(textUntilEndTag, ``);\n      }\n\n      continue;\n    }\n\n    // We're currently masking chunks inside a <tag>\n    if (isMasking) {\n      onMask?.(chunk);\n      // in the case that there was a chunk that included a tag to mask and some other text, ex \"o <tag_name\" we need to still yield the\n      // text before the tag (\"o \") so it's not swallowed with the masked text\n      if (toYieldBeforeMaskedStartTag) {\n        yield toYieldBeforeMaskedStartTag;\n      }\n      continue;\n    }\n\n    // default yield the chunk\n    yield chunk;\n  }\n}\n\n/**\n * Resolve serialized zod output - This function takes the string output ot the `jsonSchemaToZod` function\n * and instantiates the zod object correctly.\n *\n * @param schema - serialized zod object\n * @returns resolved zod object\n */\nexport function resolveSerializedZodOutput(schema: string): z.ZodType {\n  // Creates and immediately executes a new function that takes 'z' as a parameter\n  // The function body is a string that returns the serialized zod schema\n  // When executed with the 'z' parameter, it reconstructs the zod schema in the current context\n  return Function('z', `\"use strict\";return (${schema});`)(z);\n}\n\nexport interface ToolOptions {\n  name: string;\n  runId?: string;\n  threadId?: string;\n  resourceId?: string;\n  logger?: IMastraLogger;\n  description?: string;\n  mastra?: (Mastra & MastraPrimitives) | MastraPrimitives;\n  runtimeContext: RuntimeContext;\n  tracingContext?: TracingContext;\n  tracingPolicy?: TracingPolicy;\n  memory?: MastraMemory;\n  agentName?: string;\n  model?: MastraLanguageModel;\n  writableStream?: WritableStream<ChunkType>;\n  requireApproval?: boolean;\n}\n\n/**\n * Checks if a value is a Zod type\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n */\nexport function isZodType(value: unknown): value is z.ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n// Helper function to create a deterministic hash\nfunction createDeterministicId(input: string): string {\n  return createHash('sha256').update(input).digest('hex').slice(0, 8); // Take first 8 characters for a shorter but still unique ID\n}\n\n/**\n * Sets the properties for a Vercel Tool, including an ID and inputSchema\n * @param tool - The tool to set the properties for\n * @returns The tool with the properties set\n */\nfunction setVercelToolProperties(tool: VercelTool) {\n  const inputSchema = convertVercelToolParameters(tool);\n  const toolId = !('id' in tool)\n    ? tool.description\n      ? `tool-${createDeterministicId(tool.description)}`\n      : `tool-${Math.random().toString(36).substring(2, 9)}`\n    : tool.id;\n  return {\n    ...tool,\n    id: toolId,\n    inputSchema,\n  };\n}\n\n/**\n * Ensures a tool has an ID and inputSchema by generating one if not present\n * @param tool - The tool to ensure has an ID and inputSchema\n * @returns The tool with an ID and inputSchema\n */\nexport function ensureToolProperties(tools: ToolsInput): ToolsInput {\n  const toolsWithProperties = Object.keys(tools).reduce<ToolsInput>((acc, key) => {\n    const tool = tools?.[key];\n    if (tool) {\n      if (isVercelTool(tool)) {\n        acc[key] = setVercelToolProperties(tool) as VercelTool;\n      } else {\n        acc[key] = tool;\n      }\n    }\n    return acc;\n  }, {});\n\n  return toolsWithProperties;\n}\n\nfunction convertVercelToolParameters(tool: VercelTool): z.ZodType {\n  // If the tool is a Vercel Tool, check if the parameters are already a zod object\n  // If not, convert the parameters to a zod object using jsonSchemaToZod\n  const schema = tool.parameters ?? z.object({});\n  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));\n}\n\n/**\n * Converts a Vercel Tool or Mastra Tool into a CoreTool format\n * @param originalTool - The tool to convert (either VercelTool or ToolAction)\n * @param options - Tool options including Mastra-specific settings\n * @param logType - Type of tool to log (tool or toolset)\n * @returns A CoreTool that can be used by the system\n */\nexport function makeCoreTool(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n): CoreTool {\n  return new CoreToolBuilder({ originalTool, options, logType }).build();\n}\n\nexport function makeCoreToolV5(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n): VercelToolV5 {\n  return new CoreToolBuilder({ originalTool, options, logType }).buildV5();\n}\n\n/**\n * Creates a proxy for a Mastra instance to handle deprecated properties\n * @param mastra - The Mastra instance to proxy\n * @param logger - The logger to use for warnings\n * @returns A proxy for the Mastra instance\n */\nexport function createMastraProxy({ mastra, logger }: { mastra: Mastra; logger: IMastraLogger }) {\n  return new Proxy(mastra, {\n    get(target, prop) {\n      const hasProp = Reflect.has(target, prop);\n\n      if (hasProp) {\n        const value = Reflect.get(target, prop);\n        const isFunction = typeof value === 'function';\n        if (isFunction) {\n          return value.bind(target);\n        }\n        return value;\n      }\n\n      if (prop === 'logger') {\n        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);\n        return Reflect.apply(target.getLogger, target, []);\n      }\n\n      if (prop === 'telemetry') {\n        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);\n        return Reflect.apply(target.getTelemetry, target, []);\n      }\n\n      if (prop === 'storage') {\n        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);\n        return Reflect.get(target, 'storage');\n      }\n\n      if (prop === 'agents') {\n        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);\n        return Reflect.apply(target.getAgents, target, []);\n      }\n\n      if (prop === 'tts') {\n        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);\n        return Reflect.apply(target.getTTS, target, []);\n      }\n\n      if (prop === 'vectors') {\n        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);\n        return Reflect.apply(target.getVectors, target, []);\n      }\n\n      if (prop === 'memory') {\n        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);\n        return Reflect.get(target, 'memory');\n      }\n\n      return Reflect.get(target, prop);\n    },\n  });\n}\n\nexport function checkEvalStorageFields(traceObject: any, logger?: IMastraLogger) {\n  const missingFields = [];\n  if (!traceObject.input) missingFields.push('input');\n  if (!traceObject.output) missingFields.push('output');\n  if (!traceObject.agentName) missingFields.push('agent_name');\n  if (!traceObject.metricName) missingFields.push('metric_name');\n  if (!traceObject.instructions) missingFields.push('instructions');\n  if (!traceObject.globalRunId) missingFields.push('global_run_id');\n  if (!traceObject.runId) missingFields.push('run_id');\n\n  if (missingFields.length > 0) {\n    if (logger) {\n      logger.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    } else {\n      console.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// lifted from https://github.com/vercel/ai/blob/main/packages/ai/core/prompt/detect-prompt-type.ts#L27\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n\nexport function isUiMessage(message: CoreMessage | AiMessageType): message is AiMessageType {\n  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;\n}\nexport function isCoreMessage(message: CoreMessage | AiMessageType): message is CoreMessage {\n  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));\n}\n\n/** Represents a validated SQL identifier (e.g., table or column name). */\ntype SqlIdentifier = string & { __brand: 'SqlIdentifier' };\n/** Represents a validated dot-separated SQL field key. */\ntype FieldKey = string & { __brand: 'FieldKey' };\n\nconst SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\n/**\n * Parses and returns a valid SQL identifier (such as a table or column name).\n * The identifier must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param name - The identifier string to parse.\n * @param kind - Optional label for error messages (e.g., 'table name').\n * @returns The validated identifier as a branded type.\n * @throws {Error} If the identifier does not conform to SQL naming rules.\n *\n * @example\n * const id = parseSqlIdentifier('my_table'); // Ok\n * parseSqlIdentifier('123table'); // Throws error\n */\nexport function parseSqlIdentifier(name: string, kind = 'identifier'): SqlIdentifier {\n  if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {\n    throw new Error(\n      `Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`,\n    );\n  }\n  return name as SqlIdentifier;\n}\n\n/**\n * Parses and returns a valid dot-separated SQL field key (e.g., 'user.profile.name').\n * Each segment must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param key - The dot-separated field key string to parse.\n * @returns The validated field key as a branded type.\n * @throws {Error} If any segment of the key is invalid.\n *\n * @example\n * const key = parseFieldKey('user_profile.name'); // Ok\n * parseFieldKey('user..name'); // Throws error\n * parseFieldKey('user.123name'); // Throws error\n */\nexport function parseFieldKey(key: string): FieldKey {\n  if (!key) throw new Error('Field key cannot be empty');\n  const segments = key.split('.');\n  for (const segment of segments) {\n    if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {\n      throw new Error(`Invalid field key segment: ${segment} in ${key}`);\n    }\n  }\n  return key as FieldKey;\n}\n\n/**\n * Performs a fetch request with automatic retries using exponential backoff\n * @param url The URL to fetch from\n * @param options Standard fetch options\n * @param maxRetries Maximum number of retry attempts\n * @param validateResponse Optional function to validate the response beyond HTTP status\n * @returns The fetch Response if successful\n */\nexport async function fetchWithRetry(\n  url: string,\n  options: RequestInit = {},\n  maxRetries: number = 3,\n): Promise<Response> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n\n  while (retryCount < maxRetries) {\n    try {\n      const response = await fetch(url, options);\n\n      if (!response.ok) {\n        throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);\n      }\n\n      return response;\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      retryCount++;\n\n      if (retryCount >= maxRetries) {\n        break;\n      }\n\n      const delay = Math.min(1000 * Math.pow(2, retryCount) * 1000, 10000);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError || new Error('Request failed after multiple retry attempts');\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../error';\nimport { ConsoleLogger, LogLevel } from '../../logger';\nimport type { IMastraLogger } from '../../logger';\nimport { fetchWithRetry } from '../../utils';\nimport { AITracingEventType } from '../types';\nimport type { AITracingEvent, AITracingExporter, AnyExportedAISpan } from '../types';\n\nexport interface CloudExporterConfig {\n  maxBatchSize?: number; // Default: 1000 spans\n  maxBatchWaitMs?: number; // Default: 5000ms\n  maxRetries?: number; // Default: 3\n\n  // Cloud-specific configuration\n  accessToken?: string; // Cloud access token (from env or config)\n  endpoint?: string; // Cloud AI tracing endpoint\n  logger?: IMastraLogger; // Optional logger\n}\n\ninterface MastraCloudBuffer {\n  spans: MastraCloudSpanRecord[];\n  firstEventTime?: Date;\n  totalSize: number;\n}\n\ninterface MastraCloudSpanRecord {\n  traceId: string;\n  spanId: string;\n  parentSpanId: string | null;\n  name: string;\n  spanType: string;\n  attributes: Record<string, any> | null;\n  metadata: Record<string, any> | null;\n  startedAt: Date;\n  endedAt: Date | null;\n  input: any;\n  output: any;\n  error: any;\n  isEvent: boolean;\n  createdAt: Date;\n  updatedAt: Date | null;\n}\n\nexport class CloudExporter implements AITracingExporter {\n  name = 'mastra-cloud-ai-tracing-exporter';\n\n  private config: Required<CloudExporterConfig>;\n  private buffer: MastraCloudBuffer;\n  private flushTimer: NodeJS.Timeout | null = null;\n  private logger: IMastraLogger;\n  private isDisabled: boolean = false;\n\n  constructor(config: CloudExporterConfig = {}) {\n    this.logger = config.logger ?? new ConsoleLogger({ level: LogLevel.INFO });\n\n    const accessToken = config.accessToken ?? process.env.MASTRA_CLOUD_ACCESS_TOKEN;\n    if (!accessToken) {\n      this.logger.debug(\n        'CloudExporter disabled: MASTRA_CLOUD_ACCESS_TOKEN environment variable not set. ' +\n          '🚀 Sign up for Mastra Cloud at https://cloud.mastra.ai to see your AI traces online and obtain your access token.',\n      );\n      this.isDisabled = true;\n    }\n\n    const endpoint =\n      config.endpoint ?? process.env.MASTRA_CLOUD_AI_TRACES_ENDPOINT ?? 'https://api.mastra.ai/ai/spans/publish';\n\n    this.config = {\n      maxBatchSize: config.maxBatchSize ?? 1000,\n      maxBatchWaitMs: config.maxBatchWaitMs ?? 5000,\n      maxRetries: config.maxRetries ?? 3,\n      accessToken: accessToken || '', // Empty string if no token\n      endpoint,\n      logger: this.logger,\n    };\n\n    this.buffer = {\n      spans: [],\n      totalSize: 0,\n    };\n  }\n\n  async exportEvent(event: AITracingEvent): Promise<void> {\n    // Skip if disabled due to missing token\n    if (this.isDisabled) {\n      return;\n    }\n\n    // Cloud AI Observability only process SPAN_ENDED events\n    if (event.type !== AITracingEventType.SPAN_ENDED) {\n      return;\n    }\n\n    this.addToBuffer(event);\n\n    if (this.shouldFlush()) {\n      this.flush().catch(error => {\n        this.logger.error('Batch flush failed', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      });\n    } else if (this.buffer.totalSize === 1) {\n      this.scheduleFlush();\n    }\n  }\n\n  private addToBuffer(event: AITracingEvent): void {\n    // Set first event time if buffer is empty\n    if (this.buffer.totalSize === 0) {\n      this.buffer.firstEventTime = new Date();\n    }\n\n    const spanRecord = this.formatSpan(event.exportedSpan);\n\n    this.buffer.spans.push(spanRecord);\n    this.buffer.totalSize++;\n  }\n\n  private formatSpan(span: AnyExportedAISpan): MastraCloudSpanRecord {\n    const spanRecord: MastraCloudSpanRecord = {\n      traceId: span.traceId,\n      spanId: span.id,\n      parentSpanId: span.parentSpanId ?? null,\n      name: span.name,\n      spanType: span.type,\n      attributes: span.attributes ?? null,\n      metadata: span.metadata ?? null,\n      startedAt: span.startTime,\n      endedAt: span.endTime ?? null,\n      input: span.input ?? null,\n      output: span.output ?? null,\n      error: span.errorInfo,\n      isEvent: span.isEvent,\n      createdAt: new Date(),\n      updatedAt: null,\n    };\n\n    return spanRecord;\n  }\n\n  private shouldFlush(): boolean {\n    // Size-based flush\n    if (this.buffer.totalSize >= this.config.maxBatchSize) {\n      return true;\n    }\n\n    // Time-based flush\n    if (this.buffer.firstEventTime && this.buffer.totalSize > 0) {\n      const elapsed = Date.now() - this.buffer.firstEventTime.getTime();\n      if (elapsed >= this.config.maxBatchWaitMs) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private scheduleFlush(): void {\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n    }\n    this.flushTimer = setTimeout(() => {\n      this.flush().catch(error => {\n        const mastraError = new MastraError(\n          {\n            id: `CLOUD_AI_TRACING_FAILED_TO_SCHEDULE_FLUSH`,\n            domain: ErrorDomain.MASTRA_OBSERVABILITY,\n            category: ErrorCategory.USER,\n          },\n          error,\n        );\n        this.logger.trackException(mastraError);\n        this.logger.error('Scheduled flush failed', mastraError);\n      });\n    }, this.config.maxBatchWaitMs);\n  }\n\n  private async flush(): Promise<void> {\n    // Clear timer since we're flushing\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    if (this.buffer.totalSize === 0) {\n      return; // Nothing to flush\n    }\n\n    const startTime = Date.now();\n    const spansCopy = [...this.buffer.spans];\n    const flushReason = this.buffer.totalSize >= this.config.maxBatchSize ? 'size' : 'time';\n\n    // Reset buffer immediately to prevent blocking new events\n    this.resetBuffer();\n\n    try {\n      // Use fetchWithRetry for all retry logic\n      await this.batchUpload(spansCopy);\n\n      const elapsed = Date.now() - startTime;\n      this.logger.debug('Batch flushed successfully', {\n        batchSize: spansCopy.length,\n        flushReason,\n        durationMs: elapsed,\n      });\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: `CLOUD_AI_TRACING_FAILED_TO_BATCH_UPLOAD`,\n          domain: ErrorDomain.MASTRA_OBSERVABILITY,\n          category: ErrorCategory.USER,\n          details: {\n            droppedBatchSize: spansCopy.length,\n          },\n        },\n        error,\n      );\n      this.logger.trackException(mastraError);\n      this.logger.error('Batch upload failed after all retries, dropping batch', mastraError);\n      // Don't re-throw - we want to continue processing new events\n    }\n  }\n\n  /**\n   * Uploads spans to cloud API using fetchWithRetry for all retry logic\n   */\n  private async batchUpload(spans: MastraCloudSpanRecord[]): Promise<void> {\n    const url = `${this.config.endpoint}`;\n\n    const headers = {\n      Authorization: `Bearer ${this.config.accessToken}`,\n      'Content-Type': 'application/json',\n    };\n\n    const options: RequestInit = {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({ spans }),\n    };\n\n    await fetchWithRetry(url, options, this.config.maxRetries);\n  }\n\n  private resetBuffer(): void {\n    this.buffer.spans = [];\n    this.buffer.firstEventTime = undefined;\n    this.buffer.totalSize = 0;\n  }\n\n  async shutdown(): Promise<void> {\n    // Skip if disabled\n    if (this.isDisabled) {\n      return;\n    }\n\n    // Clear any pending timer\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    // Flush any remaining events\n    if (this.buffer.totalSize > 0) {\n      this.logger.info('Flushing remaining events on shutdown', {\n        remainingEvents: this.buffer.totalSize,\n      });\n      try {\n        await this.flush();\n      } catch (error) {\n        const mastraError = new MastraError(\n          {\n            id: `CLOUD_AI_TRACING_FAILED_TO_FLUSH_REMAINING_EVENTS_DURING_SHUTDOWN`,\n            domain: ErrorDomain.MASTRA_OBSERVABILITY,\n            category: ErrorCategory.USER,\n            details: {\n              remainingEvents: this.buffer.totalSize,\n            },\n          },\n          error,\n        );\n\n        this.logger.trackException(mastraError);\n        this.logger.error('Failed to flush remaining events during shutdown', mastraError);\n      }\n    }\n\n    this.logger.info('CloudExporter shutdown complete');\n  }\n}\n","import { ConsoleLogger, LogLevel } from '../../logger';\nimport type { IMastraLogger } from '../../logger';\nimport { AITracingEventType } from '../types';\nimport type { AITracingEvent, AITracingExporter } from '../types';\n\nexport class ConsoleExporter implements AITracingExporter {\n  name = 'tracing-console-exporter';\n  private logger: IMastraLogger;\n\n  constructor(logger?: IMastraLogger) {\n    if (logger) {\n      this.logger = logger;\n    } else {\n      // Fallback: create a direct ConsoleLogger instance if none provided\n      this.logger = new ConsoleLogger({ level: LogLevel.INFO });\n    }\n  }\n\n  async exportEvent(event: AITracingEvent): Promise<void> {\n    const span = event.exportedSpan;\n\n    // Helper to safely stringify attributes (filtering already done by processor)\n    const formatAttributes = (attributes: any) => {\n      try {\n        return JSON.stringify(attributes, null, 2);\n      } catch (error) {\n        const errMsg = error instanceof Error ? error.message : 'Unknown formatting error';\n        return `[Unable to serialize attributes: ${errMsg}]`;\n      }\n    };\n\n    // Helper to format duration\n    const formatDuration = (startTime: Date, endTime?: Date) => {\n      if (!endTime) return 'N/A';\n      const duration = endTime.getTime() - startTime.getTime();\n      return `${duration}ms`;\n    };\n\n    switch (event.type) {\n      case AITracingEventType.SPAN_STARTED:\n        this.logger.info(`🚀 SPAN_STARTED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        if (span.input !== undefined) {\n          this.logger.info(`   Input: ${formatAttributes(span.input)}`);\n        }\n        this.logger.info(`   Attributes: ${formatAttributes(span.attributes)}`);\n        this.logger.info('─'.repeat(80));\n        break;\n\n      case AITracingEventType.SPAN_ENDED:\n        const duration = formatDuration(span.startTime, span.endTime);\n        this.logger.info(`✅ SPAN_ENDED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Duration: ${duration}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        if (span.input !== undefined) {\n          this.logger.info(`   Input: ${formatAttributes(span.input)}`);\n        }\n        if (span.output !== undefined) {\n          this.logger.info(`   Output: ${formatAttributes(span.output)}`);\n        }\n        if (span.errorInfo) {\n          this.logger.info(`   Error: ${formatAttributes(span.errorInfo)}`);\n        }\n        this.logger.info(`   Attributes: ${formatAttributes(span.attributes)}`);\n        this.logger.info('─'.repeat(80));\n        break;\n\n      case AITracingEventType.SPAN_UPDATED:\n        this.logger.info(`📝 SPAN_UPDATED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        if (span.input !== undefined) {\n          this.logger.info(`   Input: ${formatAttributes(span.input)}`);\n        }\n        if (span.output !== undefined) {\n          this.logger.info(`   Output: ${formatAttributes(span.output)}`);\n        }\n        if (span.errorInfo) {\n          this.logger.info(`   Error: ${formatAttributes(span.errorInfo)}`);\n        }\n        this.logger.info(`   Updated Attributes: ${formatAttributes(span.attributes)}`);\n        this.logger.info('─'.repeat(80));\n        break;\n\n      default:\n        this.logger.warn(`Tracing event type not implemented: ${(event as any).type}`);\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('ConsoleExporter shutdown');\n  }\n}\n","import { ConsoleLogger, LogLevel } from '../../logger';\nimport type { IMastraLogger } from '../../logger';\nimport type { Mastra } from '../../mastra';\nimport type { MastraStorage } from '../../storage/base';\nimport type { CreateAISpanRecord, UpdateAISpanRecord } from '../../storage/types';\nimport { AITracingEventType } from '../types';\nimport type { AITracingEvent, AITracingExporter, AnyExportedAISpan, TracingConfig, TracingStrategy } from '../types';\n\ninterface BatchingConfig {\n  maxBatchSize?: number; // Default: 1000 spans\n  maxBufferSize?: number; // Default: 10000 spans\n  maxBatchWaitMs?: number; // Default: 5000ms\n  maxRetries?: number; // Default: 4\n  retryDelayMs?: number; // Default: 500ms (base delay for exponential backoff)\n\n  // Strategy selection (optional)\n  strategy?: TracingStrategy | 'auto';\n}\n\ninterface BatchBuffer {\n  // For batch-with-updates strategy\n  creates: CreateAISpanRecord[];\n  updates: UpdateRecord[];\n\n  // For insert-only strategy\n  insertOnly: CreateAISpanRecord[];\n\n  // Ordering enforcement (batch-with-updates only)\n  seenSpans: Set<string>; // \"traceId:spanId\" combinations we've seen creates for\n  spanSequences: Map<string, number>; // \"traceId:spanId\" -> next sequence number\n\n  // Track completed spans for cleanup\n  completedSpans: Set<string>; // Spans that have received SPAN_ENDED\n\n  // Metrics\n  outOfOrderCount: number;\n\n  // Metadata\n  firstEventTime?: Date;\n  totalSize: number;\n}\n\ninterface UpdateRecord {\n  traceId: string;\n  spanId: string;\n  updates: Partial<UpdateAISpanRecord>;\n  sequenceNumber: number; // For ordering updates to same span\n}\n\n/**\n * Resolves the final strategy based on user config and storage hints\n */\nfunction resolveStrategy(userConfig: BatchingConfig, storage: MastraStorage, logger: IMastraLogger): TracingStrategy {\n  if (userConfig.strategy && userConfig.strategy !== 'auto') {\n    const hints = storage.aiTracingStrategy;\n    if (hints.supported.includes(userConfig.strategy)) {\n      return userConfig.strategy;\n    }\n    // Log warning and fall through to auto-selection\n    logger.warn('User-specified AI tracing strategy not supported by storage adapter, falling back to auto-selection', {\n      userStrategy: userConfig.strategy,\n      storageAdapter: storage.constructor.name,\n      supportedStrategies: hints.supported,\n      fallbackStrategy: hints.preferred,\n    });\n  }\n  return storage.aiTracingStrategy.preferred;\n}\n\nexport class DefaultExporter implements AITracingExporter {\n  name = 'tracing-default-exporter';\n  private logger: IMastraLogger;\n  private mastra: Mastra | null = null;\n  private config: Required<BatchingConfig>;\n  private resolvedStrategy: TracingStrategy;\n  private buffer: BatchBuffer;\n  private flushTimer: NodeJS.Timeout | null = null;\n\n  // Track all spans that have been created, persists across flushes\n  private allCreatedSpans: Set<string> = new Set();\n\n  constructor(config: BatchingConfig = {}, logger?: IMastraLogger) {\n    if (logger) {\n      this.logger = logger;\n    } else {\n      // Fallback: create a direct ConsoleLogger instance if none provided\n      this.logger = new ConsoleLogger({ level: LogLevel.INFO });\n    }\n\n    // Set default configuration\n    this.config = {\n      maxBatchSize: config.maxBatchSize ?? 1000,\n      maxBufferSize: config.maxBufferSize ?? 10000,\n      maxBatchWaitMs: config.maxBatchWaitMs ?? 5000,\n      maxRetries: config.maxRetries ?? 4,\n      retryDelayMs: config.retryDelayMs ?? 500,\n      strategy: config.strategy ?? 'auto',\n    };\n\n    // Initialize buffer\n    this.buffer = {\n      creates: [],\n      updates: [],\n      insertOnly: [],\n      seenSpans: new Set(),\n      spanSequences: new Map(),\n      completedSpans: new Set(),\n      outOfOrderCount: 0,\n      totalSize: 0,\n    };\n\n    // Resolve strategy - we'll do this lazily on first export since we need storage\n    this.resolvedStrategy = 'batch-with-updates'; // temporary default\n  }\n\n  private strategyInitialized = false;\n\n  /**\n   * Register the Mastra instance (called after Mastra construction is complete)\n   */\n  __registerMastra(mastra: Mastra): void {\n    this.mastra = mastra;\n  }\n\n  /**\n   * Initialize the exporter (called after all dependencies are ready)\n   */\n  init(_config?: TracingConfig): void {\n    if (!this.mastra) {\n      throw new Error('DefaultExporter: init() called before __registerMastra()');\n    }\n\n    const storage = this.mastra.getStorage();\n    if (!storage) {\n      this.logger.warn('DefaultExporter disabled: Storage not available. Traces will not be persisted.');\n      return;\n    }\n\n    this.initializeStrategy(storage);\n  }\n\n  /**\n   * Initialize the resolved strategy once storage is available\n   */\n  private initializeStrategy(storage: MastraStorage): void {\n    if (this.strategyInitialized) return;\n\n    this.resolvedStrategy = resolveStrategy(this.config, storage, this.logger);\n    this.strategyInitialized = true;\n\n    this.logger.debug('AI tracing exporter initialized', {\n      strategy: this.resolvedStrategy,\n      source: this.config.strategy !== 'auto' ? 'user' : 'auto',\n      storageAdapter: storage.constructor.name,\n      maxBatchSize: this.config.maxBatchSize,\n      maxBatchWaitMs: this.config.maxBatchWaitMs,\n    });\n  }\n\n  /**\n   * Builds a unique span key for tracking\n   */\n  private buildSpanKey(traceId: string, spanId: string): string {\n    return `${traceId}:${spanId}`;\n  }\n\n  /**\n   * Gets the next sequence number for a span\n   */\n  private getNextSequence(spanKey: string): number {\n    const current = this.buffer.spanSequences.get(spanKey) || 0;\n    const next = current + 1;\n    this.buffer.spanSequences.set(spanKey, next);\n    return next;\n  }\n\n  /**\n   * Handles out-of-order span updates by logging and skipping\n   */\n  private handleOutOfOrderUpdate(event: AITracingEvent): void {\n    this.logger.warn('Out-of-order span update detected - skipping event', {\n      spanId: event.exportedSpan.id,\n      traceId: event.exportedSpan.traceId,\n      spanName: event.exportedSpan.name,\n      eventType: event.type,\n    });\n  }\n\n  /**\n   * Adds an event to the appropriate buffer based on strategy\n   */\n  private addToBuffer(event: AITracingEvent): void {\n    const spanKey = this.buildSpanKey(event.exportedSpan.traceId, event.exportedSpan.id);\n\n    // Set first event time if buffer is empty\n    if (this.buffer.totalSize === 0) {\n      this.buffer.firstEventTime = new Date();\n    }\n\n    switch (event.type) {\n      case AITracingEventType.SPAN_STARTED:\n        if (this.resolvedStrategy === 'batch-with-updates') {\n          const createRecord = this.buildCreateRecord(event.exportedSpan);\n          this.buffer.creates.push(createRecord);\n          this.buffer.seenSpans.add(spanKey);\n          // Track this span as created persistently\n          this.allCreatedSpans.add(spanKey);\n        }\n        // insert-only ignores SPAN_STARTED\n        break;\n\n      case AITracingEventType.SPAN_UPDATED:\n        if (this.resolvedStrategy === 'batch-with-updates') {\n          if (this.allCreatedSpans.has(spanKey)) {\n            // Span was created previously (possibly in a prior batch)\n            this.buffer.updates.push({\n              traceId: event.exportedSpan.traceId,\n              spanId: event.exportedSpan.id,\n              updates: this.buildUpdateRecord(event.exportedSpan),\n              sequenceNumber: this.getNextSequence(spanKey),\n            });\n          } else {\n            // Out-of-order case: log and skip\n            this.handleOutOfOrderUpdate(event);\n            this.buffer.outOfOrderCount++;\n          }\n        }\n        // insert-only ignores SPAN_UPDATED\n        break;\n\n      case AITracingEventType.SPAN_ENDED:\n        if (this.resolvedStrategy === 'batch-with-updates') {\n          if (this.allCreatedSpans.has(spanKey)) {\n            // Span was created previously (possibly in a prior batch)\n            this.buffer.updates.push({\n              traceId: event.exportedSpan.traceId,\n              spanId: event.exportedSpan.id,\n              updates: this.buildUpdateRecord(event.exportedSpan),\n              sequenceNumber: this.getNextSequence(spanKey),\n            });\n            // Mark this span as completed\n            this.buffer.completedSpans.add(spanKey);\n          } else if (event.exportedSpan.isEvent) {\n            // Event-type spans only emit SPAN_ENDED (no prior SPAN_STARTED)\n            const createRecord = this.buildCreateRecord(event.exportedSpan);\n            this.buffer.creates.push(createRecord);\n            this.buffer.seenSpans.add(spanKey);\n            // Track this span as created persistently\n            this.allCreatedSpans.add(spanKey);\n            // Event spans are immediately complete\n            this.buffer.completedSpans.add(spanKey);\n          } else {\n            // Out-of-order case: log and skip\n            this.handleOutOfOrderUpdate(event);\n            this.buffer.outOfOrderCount++;\n          }\n        } else if (this.resolvedStrategy === 'insert-only') {\n          // Only process SPAN_ENDED for insert-only strategy\n          const createRecord = this.buildCreateRecord(event.exportedSpan);\n          this.buffer.insertOnly.push(createRecord);\n          // Mark as completed for insert-only strategy\n          this.buffer.completedSpans.add(spanKey);\n          this.allCreatedSpans.add(spanKey);\n        }\n        break;\n    }\n\n    // Update total size\n    this.buffer.totalSize = this.buffer.creates.length + this.buffer.updates.length + this.buffer.insertOnly.length;\n  }\n\n  /**\n   * Checks if buffer should be flushed based on size or time triggers\n   */\n  private shouldFlush(): boolean {\n    // Emergency flush - buffer overflow\n    if (this.buffer.totalSize >= this.config.maxBufferSize) {\n      return true;\n    }\n\n    // Size-based flush\n    if (this.buffer.totalSize >= this.config.maxBatchSize) {\n      return true;\n    }\n\n    // Time-based flush\n    if (this.buffer.firstEventTime && this.buffer.totalSize > 0) {\n      const elapsed = Date.now() - this.buffer.firstEventTime.getTime();\n      if (elapsed >= this.config.maxBatchWaitMs) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Resets the buffer after successful flush\n   */\n  private resetBuffer(completedSpansToCleanup: Set<string> = new Set()): void {\n    this.buffer.creates = [];\n    this.buffer.updates = [];\n    this.buffer.insertOnly = [];\n    this.buffer.seenSpans.clear();\n    this.buffer.spanSequences.clear();\n    this.buffer.completedSpans.clear();\n    this.buffer.outOfOrderCount = 0;\n    this.buffer.firstEventTime = undefined;\n    this.buffer.totalSize = 0;\n\n    // Clean up completed spans from persistent tracking\n    for (const spanKey of completedSpansToCleanup) {\n      this.allCreatedSpans.delete(spanKey);\n    }\n  }\n\n  /**\n   * Schedules a flush using setTimeout\n   */\n  private scheduleFlush(): void {\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n    }\n    this.flushTimer = setTimeout(() => {\n      this.flush().catch(error => {\n        this.logger.error('Scheduled flush failed', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      });\n    }, this.config.maxBatchWaitMs);\n  }\n\n  /**\n   * Serializes span attributes to storage record format\n   * Handles all AI span types and their specific attributes\n   */\n  private serializeAttributes(span: AnyExportedAISpan): Record<string, any> | null {\n    if (!span.attributes) {\n      return null;\n    }\n\n    try {\n      // Convert the typed attributes to a plain object\n      // This handles nested objects, dates, and other complex types\n      return JSON.parse(\n        JSON.stringify(span.attributes, (_key, value) => {\n          // Handle Date objects\n          if (value instanceof Date) {\n            return value.toISOString();\n          }\n          // Handle other objects that might not serialize properly\n          if (typeof value === 'object' && value !== null) {\n            // For arrays and plain objects, let JSON.stringify handle them\n            return value;\n          }\n          // For primitives, return as-is\n          return value;\n        }),\n      );\n    } catch (error) {\n      this.logger.warn('Failed to serialize span attributes, storing as null', {\n        spanId: span.id,\n        spanType: span.type,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      return null;\n    }\n  }\n\n  private buildCreateRecord(span: AnyExportedAISpan): CreateAISpanRecord {\n    return {\n      traceId: span.traceId,\n      spanId: span.id,\n      parentSpanId: span.parentSpanId ?? null,\n      name: span.name,\n      scope: null,\n      spanType: span.type,\n      attributes: this.serializeAttributes(span),\n      metadata: span.metadata ?? null,\n      links: null,\n      startedAt: span.startTime,\n      endedAt: span.endTime ?? null,\n      input: span.input,\n      output: span.output,\n      error: span.errorInfo,\n      isEvent: span.isEvent,\n    };\n  }\n\n  private buildUpdateRecord(span: AnyExportedAISpan): Partial<UpdateAISpanRecord> {\n    return {\n      name: span.name,\n      scope: null,\n      attributes: this.serializeAttributes(span),\n      metadata: span.metadata ?? null,\n      links: null,\n      endedAt: span.endTime ?? null,\n      input: span.input,\n      output: span.output,\n      error: span.errorInfo,\n    };\n  }\n\n  /**\n   * Handles realtime strategy - processes each event immediately\n   */\n  private async handleRealtimeEvent(event: AITracingEvent, storage: MastraStorage): Promise<void> {\n    const span = event.exportedSpan;\n    const spanKey = this.buildSpanKey(span.traceId, span.id);\n\n    // Event spans only have an end event\n    if (span.isEvent) {\n      if (event.type === AITracingEventType.SPAN_ENDED) {\n        await storage.createAISpan(this.buildCreateRecord(event.exportedSpan));\n        // For event spans in realtime, we don't need to track them since they're immediately complete\n      } else {\n        this.logger.warn(`Tracing event type not implemented for event spans: ${event.type}`);\n      }\n    } else {\n      switch (event.type) {\n        case AITracingEventType.SPAN_STARTED:\n          await storage.createAISpan(this.buildCreateRecord(event.exportedSpan));\n          // Track this span as created persistently\n          this.allCreatedSpans.add(spanKey);\n          break;\n        case AITracingEventType.SPAN_UPDATED:\n          await storage.updateAISpan({\n            traceId: span.traceId,\n            spanId: span.id,\n            updates: this.buildUpdateRecord(span),\n          });\n          break;\n        case AITracingEventType.SPAN_ENDED:\n          await storage.updateAISpan({\n            traceId: span.traceId,\n            spanId: span.id,\n            updates: this.buildUpdateRecord(span),\n          });\n          // Clean up immediately for realtime strategy\n          this.allCreatedSpans.delete(spanKey);\n          break;\n        default:\n          this.logger.warn(`Tracing event type not implemented for span spans: ${(event as any).type}`);\n      }\n    }\n  }\n\n  /**\n   * Handles batch-with-updates strategy - buffers events and processes in batches\n   */\n  private handleBatchWithUpdatesEvent(event: AITracingEvent): void {\n    this.addToBuffer(event);\n\n    if (this.shouldFlush()) {\n      // Immediate flush for size/emergency triggers\n      this.flush().catch(error => {\n        this.logger.error('Batch flush failed', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      });\n    } else if (this.buffer.totalSize === 1) {\n      // Schedule flush for the first event in buffer\n      this.scheduleFlush();\n    }\n  }\n\n  /**\n   * Handles insert-only strategy - only processes SPAN_ENDED events in batches\n   */\n  private handleInsertOnlyEvent(event: AITracingEvent): void {\n    // Only process SPAN_ENDED events for insert-only strategy\n    if (event.type === AITracingEventType.SPAN_ENDED) {\n      this.addToBuffer(event);\n\n      if (this.shouldFlush()) {\n        // Immediate flush for size/emergency triggers\n        this.flush().catch(error => {\n          this.logger.error('Batch flush failed', {\n            error: error instanceof Error ? error.message : String(error),\n          });\n        });\n      } else if (this.buffer.totalSize === 1) {\n        // Schedule flush for the first event in buffer\n        this.scheduleFlush();\n      }\n    }\n    // Ignore SPAN_STARTED and SPAN_UPDATED events\n  }\n\n  /**\n   * Calculates retry delay using exponential backoff\n   */\n  private calculateRetryDelay(attempt: number): number {\n    return this.config.retryDelayMs * Math.pow(2, attempt);\n  }\n\n  /**\n   * Flushes the current buffer to storage with retry logic\n   */\n  private async flush(): Promise<void> {\n    if (!this.mastra) {\n      this.logger.debug('Cannot flush traces. Mastra instance not registered yet.');\n      return;\n    }\n\n    const storage = this.mastra.getStorage();\n    if (!storage) {\n      this.logger.debug('Cannot flush traces. Mastra storage is not initialized');\n      return;\n    }\n\n    // Clear timer since we're flushing\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    if (this.buffer.totalSize === 0) {\n      return; // Nothing to flush\n    }\n\n    const startTime = Date.now();\n    const flushReason =\n      this.buffer.totalSize >= this.config.maxBufferSize\n        ? 'overflow'\n        : this.buffer.totalSize >= this.config.maxBatchSize\n          ? 'size'\n          : 'time';\n\n    // Create a copy of the buffer to work with\n    const bufferCopy: BatchBuffer = {\n      creates: [...this.buffer.creates],\n      updates: [...this.buffer.updates],\n      insertOnly: [...this.buffer.insertOnly],\n      seenSpans: new Set(this.buffer.seenSpans),\n      spanSequences: new Map(this.buffer.spanSequences),\n      completedSpans: new Set(this.buffer.completedSpans),\n      outOfOrderCount: this.buffer.outOfOrderCount,\n      firstEventTime: this.buffer.firstEventTime,\n      totalSize: this.buffer.totalSize,\n    };\n\n    // Reset buffer immediately to prevent blocking new events\n    // Note: We don't clean up completed spans yet - we'll do that after successful flush\n    this.resetBuffer();\n\n    // Attempt to flush with retry logic\n    await this.flushWithRetries(storage, bufferCopy, 0);\n\n    const elapsed = Date.now() - startTime;\n    this.logger.debug('Batch flushed', {\n      strategy: this.resolvedStrategy,\n      batchSize: bufferCopy.totalSize,\n      flushReason,\n      durationMs: elapsed,\n      outOfOrderCount: bufferCopy.outOfOrderCount > 0 ? bufferCopy.outOfOrderCount : undefined,\n    });\n  }\n\n  /**\n   * Attempts to flush with exponential backoff retry logic\n   */\n  private async flushWithRetries(storage: MastraStorage, buffer: BatchBuffer, attempt: number): Promise<void> {\n    try {\n      if (this.resolvedStrategy === 'batch-with-updates') {\n        // Process creates first (always safe)\n        if (buffer.creates.length > 0) {\n          await storage.batchCreateAISpans({ records: buffer.creates });\n        }\n\n        // Sort updates by span, then by sequence number\n        if (buffer.updates.length > 0) {\n          const sortedUpdates = buffer.updates.sort((a, b) => {\n            const spanCompare = this.buildSpanKey(a.traceId, a.spanId).localeCompare(\n              this.buildSpanKey(b.traceId, b.spanId),\n            );\n            if (spanCompare !== 0) return spanCompare;\n            return a.sequenceNumber - b.sequenceNumber;\n          });\n\n          await storage.batchUpdateAISpans({ records: sortedUpdates });\n        }\n      } else if (this.resolvedStrategy === 'insert-only') {\n        // Simple batch insert for insert-only strategy\n        if (buffer.insertOnly.length > 0) {\n          await storage.batchCreateAISpans({ records: buffer.insertOnly });\n        }\n      }\n\n      // Success! Clean up completed spans from persistent tracking\n      for (const spanKey of buffer.completedSpans) {\n        this.allCreatedSpans.delete(spanKey);\n      }\n    } catch (error) {\n      if (attempt < this.config.maxRetries) {\n        const retryDelay = this.calculateRetryDelay(attempt);\n        this.logger.warn('Batch flush failed, retrying', {\n          attempt: attempt + 1,\n          maxRetries: this.config.maxRetries,\n          nextRetryInMs: retryDelay,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        await new Promise(resolve => setTimeout(resolve, retryDelay));\n        return this.flushWithRetries(storage, buffer, attempt + 1);\n      } else {\n        this.logger.error('Batch flush failed after all retries, dropping batch', {\n          finalAttempt: attempt + 1,\n          maxRetries: this.config.maxRetries,\n          droppedBatchSize: buffer.totalSize,\n          error: error instanceof Error ? error.message : String(error),\n        });\n        // Even on failure, we should clean up completed spans to avoid memory leak\n        // These spans will be lost but at least we prevent memory issues\n        for (const spanKey of buffer.completedSpans) {\n          this.allCreatedSpans.delete(spanKey);\n        }\n      }\n    }\n  }\n\n  async exportEvent(event: AITracingEvent): Promise<void> {\n    if (!this.mastra) {\n      this.logger.debug('Cannot export AI tracing event. Mastra instance not registered yet.');\n      return;\n    }\n\n    const storage = this.mastra.getStorage();\n    if (!storage) {\n      this.logger.debug('Cannot store traces. Mastra storage is not initialized');\n      return;\n    }\n\n    // Initialize strategy if not already done (fallback for edge cases)\n    if (!this.strategyInitialized) {\n      this.initializeStrategy(storage);\n    }\n\n    // Clear strategy routing - explicit and readable\n    switch (this.resolvedStrategy) {\n      case 'realtime':\n        await this.handleRealtimeEvent(event, storage);\n        break;\n      case 'batch-with-updates':\n        this.handleBatchWithUpdatesEvent(event);\n        break;\n      case 'insert-only':\n        this.handleInsertOnlyEvent(event);\n        break;\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    // Clear any pending timer\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n\n    // Flush any remaining events\n    if (this.buffer.totalSize > 0) {\n      this.logger.info('Flushing remaining events on shutdown', {\n        remainingEvents: this.buffer.totalSize,\n      });\n      try {\n        await this.flush();\n      } catch (error) {\n        this.logger.error('Failed to flush remaining events during shutdown', {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    this.logger.info('DefaultExporter shutdown complete');\n  }\n}\n","import type { AISpanProcessor, AnyAISpan } from '../types';\n\nexport type RedactionStyle = 'full' | 'partial';\n\n/**\n * Options for configuring the SensitiveDataFilter.\n */\nexport interface SensitiveDataFilterOptions {\n  /**\n   * List of sensitive field names to redact.\n   * Matching is case-insensitive and normalizes separators (`api-key`, `api_key`, `Api Key` → `apikey`).\n   *\n   * Defaults include: password, token, secret, key, apikey, auth, authorization,\n   * bearer, bearertoken, jwt, credential, clientsecret, privatekey, refresh, ssn.\n   */\n  sensitiveFields?: string[];\n\n  /**\n   * The token used for full redaction.\n   * Default: \"[REDACTED]\"\n   */\n  redactionToken?: string;\n\n  /**\n   * Style of redaction to use:\n   * - \"full\": always replace with redactionToken.\n   * - \"partial\": show 3 characters from the start and end, redact the middle.\n   *\n   * Default: \"full\"\n   */\n  redactionStyle?: RedactionStyle;\n}\n\n/**\n * SensitiveDataFilter\n *\n * An AISpanProcessor that redacts sensitive information from span fields.\n *\n * - Sensitive keys are matched case-insensitively, normalized to remove separators.\n * - Sensitive values are redacted using either full or partial redaction.\n * - Partial redaction always keeps 3 chars at the start and end.\n * - If filtering a field fails, the field is replaced with:\n *   `{ error: { processor: \"sensitive-data-filter\" } }`\n */\nexport class SensitiveDataFilter implements AISpanProcessor {\n  name = 'sensitive-data-filter';\n  private sensitiveFields: string[];\n  private redactionToken: string;\n  private redactionStyle: RedactionStyle;\n\n  constructor(options: SensitiveDataFilterOptions = {}) {\n    this.sensitiveFields = (\n      options.sensitiveFields || [\n        'password',\n        'token',\n        'secret',\n        'key',\n        'apikey',\n        'auth',\n        'authorization',\n        'bearer',\n        'bearertoken',\n        'jwt',\n        'credential',\n        'clientsecret',\n        'privatekey',\n        'refresh',\n        'ssn',\n      ]\n    ).map(f => this.normalizeKey(f));\n\n    this.redactionToken = options.redactionToken ?? '[REDACTED]';\n    this.redactionStyle = options.redactionStyle ?? 'full';\n  }\n\n  /**\n   * Process a span by filtering sensitive data across its key fields.\n   * Fields processed: attributes, metadata, input, output, errorInfo.\n   *\n   * @param span - The input span to filter\n   * @returns A new span with sensitive values redacted\n   */\n  process(span: AnyAISpan): AnyAISpan {\n    span.attributes = this.tryFilter(span.attributes);\n    span.metadata = this.tryFilter(span.metadata);\n    span.input = this.tryFilter(span.input);\n    span.output = this.tryFilter(span.output);\n    span.errorInfo = this.tryFilter(span.errorInfo);\n    return span;\n  }\n\n  /**\n   * Recursively filter objects/arrays for sensitive keys.\n   * Handles circular references by replacing with a marker.\n   */\n  private deepFilter(obj: any, seen = new WeakSet()): any {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    if (seen.has(obj)) {\n      return '[Circular Reference]';\n    }\n    seen.add(obj);\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.deepFilter(item, seen));\n    }\n\n    const filtered: any = {};\n    for (const key of Object.keys(obj)) {\n      const normKey = this.normalizeKey(key);\n\n      if (this.isSensitive(normKey)) {\n        if (obj[key] && typeof obj[key] === 'object') {\n          filtered[key] = this.deepFilter(obj[key], seen);\n        } else {\n          filtered[key] = this.redactValue(obj[key]);\n        }\n      } else {\n        filtered[key] = this.deepFilter(obj[key], seen);\n      }\n    }\n\n    return filtered;\n  }\n\n  private tryFilter(value: any): any {\n    try {\n      return this.deepFilter(value);\n    } catch {\n      return { error: { processor: this.name } };\n    }\n  }\n\n  /**\n   * Normalize keys by lowercasing and stripping non-alphanumeric characters.\n   * Ensures consistent matching for variants like \"api-key\", \"api_key\", \"Api Key\".\n   */\n  private normalizeKey(key: string): string {\n    return key.toLowerCase().replace(/[^a-z0-9]/g, '');\n  }\n\n  /**\n   * Check whether a normalized key exactly matches any sensitive field.\n   * Both key and sensitive fields are normalized by removing all non-alphanumeric\n   * characters and converting to lowercase before comparison.\n   *\n   * Examples:\n   * - \"api_key\", \"api-key\", \"ApiKey\" all normalize to \"apikey\" → MATCHES \"apikey\"\n   * - \"promptTokens\", \"prompt_tokens\" normalize to \"prompttokens\" → DOES NOT MATCH \"token\"\n   */\n  private isSensitive(normalizedKey: string): boolean {\n    return this.sensitiveFields.some(sensitiveField => {\n      // Simple case-insensitive match after normalization\n      return normalizedKey === sensitiveField;\n    });\n  }\n\n  /**\n   * Redact a sensitive value.\n   * - Full style: replaces with a fixed token.\n   * - Partial style: shows 3 chars at start and end, hides the middle.\n   *\n   * Non-string values are converted to strings before partial redaction.\n   */\n  private redactValue(value: any): string {\n    if (this.redactionStyle === 'full') {\n      return this.redactionToken;\n    }\n\n    const str = String(value);\n    const len = str.length;\n    if (len <= 6) {\n      return this.redactionToken; // too short, redact fully\n    }\n    return str.slice(0, 3) + '…' + str.slice(len - 3);\n  }\n\n  async shutdown(): Promise<void> {\n    // No cleanup needed\n  }\n}\n","/**\n * AI Tracing Registry for Mastra\n *\n * Provides a global registry for AI tracing instances.\n */\n\nimport { CloudExporter, DefaultExporter } from './exporters';\nimport { SensitiveDataFilter } from './span_processors';\nimport { BaseAITracing, DefaultAITracing } from './tracers';\nimport { SamplingStrategyType } from './types';\nimport type {\n  AITracing,\n  ConfigSelectorOptions,\n  ConfigSelector,\n  TracingConfig,\n  ObservabilityRegistryConfig,\n} from './types';\n\n// ============================================================================\n// Global AI Tracing Registry\n// ============================================================================\n\n/**\n * Global registry for AI Tracing instances.\n */\nclass AITracingRegistry {\n  private instances = new Map<string, AITracing>();\n  private defaultInstance?: AITracing;\n  private configSelector?: ConfigSelector;\n\n  /**\n   * Register a tracing instance\n   */\n  register(name: string, instance: AITracing, isDefault = false): void {\n    if (this.instances.has(name)) {\n      throw new Error(`AI Tracing instance '${name}' already registered`);\n    }\n\n    this.instances.set(name, instance);\n\n    // Set as default if explicitly marked or if it's the first instance\n    if (isDefault || !this.defaultInstance) {\n      this.defaultInstance = instance;\n    }\n  }\n\n  /**\n   * Get a tracing instance by name\n   */\n  get(name: string): AITracing | undefined {\n    return this.instances.get(name);\n  }\n\n  /**\n   * Get the default tracing instance\n   */\n  getDefault(): AITracing | undefined {\n    return this.defaultInstance;\n  }\n\n  /**\n   * Set the tracing selector function\n   */\n  setSelector(selector: ConfigSelector): void {\n    this.configSelector = selector;\n  }\n\n  /**\n   * Get the selected tracing instance based on context\n   */\n  getSelected(options: ConfigSelectorOptions): AITracing | undefined {\n    // 1. Try selector function if provided\n    if (this.configSelector) {\n      const selected = this.configSelector(options, this.instances);\n      if (selected && this.instances.has(selected)) {\n        return this.instances.get(selected);\n      }\n    }\n\n    // 2. Fall back to default\n    return this.defaultInstance;\n  }\n\n  /**\n   * Unregister a tracing instance\n   */\n  unregister(name: string): boolean {\n    return this.instances.delete(name);\n  }\n\n  /**\n   * Shutdown all instances and clear the registry\n   */\n  async shutdown(): Promise<void> {\n    const shutdownPromises = Array.from(this.instances.values()).map(instance => instance.shutdown());\n\n    await Promise.allSettled(shutdownPromises);\n    this.instances.clear();\n  }\n\n  /**\n   * Clear all instances without shutdown\n   */\n  clear(): void {\n    this.instances.clear();\n    this.defaultInstance = undefined;\n    this.configSelector = undefined;\n  }\n\n  /**\n   * Get all registered instances\n   */\n  getAll(): ReadonlyMap<string, AITracing> {\n    return new Map(this.instances);\n  }\n}\n\nconst aiTracingRegistry = new AITracingRegistry();\n\n// ============================================================================\n// Registry Management Functions\n// ============================================================================\n\n/**\n * Register an AI tracing instance globally\n */\nexport function registerAITracing(name: string, instance: AITracing, isDefault = false): void {\n  aiTracingRegistry.register(name, instance, isDefault);\n}\n\n/**\n * Get an AI tracing instance from the registry\n */\nexport function getAITracing(name: string): AITracing | undefined {\n  return aiTracingRegistry.get(name);\n}\n\n/**\n * Get the default AI tracing instance\n */\nexport function getDefaultAITracing(): AITracing | undefined {\n  return aiTracingRegistry.getDefault();\n}\n\n/**\n * Set the AI tracing config selector\n */\nexport function setSelector(selector: ConfigSelector): void {\n  aiTracingRegistry.setSelector(selector);\n}\n\n/**\n * Get the selected AI tracing instance based on options\n */\nexport function getSelectedAITracing(options: ConfigSelectorOptions): AITracing | undefined {\n  return aiTracingRegistry.getSelected(options);\n}\n\n/**\n * Unregister an AI tracing instance\n */\nexport function unregisterAITracing(name: string): boolean {\n  return aiTracingRegistry.unregister(name);\n}\n\n/**\n * Shutdown all AI tracing instances and clear the registry\n */\nexport async function shutdownAITracingRegistry(): Promise<void> {\n  await aiTracingRegistry.shutdown();\n}\n\n/**\n * Clear all AI tracing instances without shutdown\n */\nexport function clearAITracingRegistry(): void {\n  aiTracingRegistry.clear();\n}\n\n/**\n * Get all registered AI tracing instances\n */\nexport function getAllAITracing(): ReadonlyMap<string, AITracing> {\n  return aiTracingRegistry.getAll();\n}\n\n/**\n * Check if AI tracing is available and enabled\n */\nexport function hasAITracing(name: string): boolean {\n  const tracing = getAITracing(name);\n  if (!tracing) return false;\n\n  const config = tracing.getConfig();\n  const sampling = config.sampling;\n\n  // Check if sampling allows tracing\n  return sampling.type !== SamplingStrategyType.NEVER;\n}\n\n/**\n * Type guard to check if an object is a BaseAITracing instance\n */\nfunction isAITracingInstance(obj: Omit<TracingConfig, 'name'> | AITracing): obj is AITracing {\n  return obj instanceof BaseAITracing;\n}\n\n/**\n * Setup AI tracing from the ObservabilityRegistryConfig\n */\nexport function setupAITracing(config: ObservabilityRegistryConfig): void {\n  // Handle undefined/null config\n  if (!config) {\n    return;\n  }\n\n  // Check for naming conflict if default is enabled\n  if (config.default?.enabled && config.configs?.['default']) {\n    throw new Error(\n      \"Cannot use 'default' as a custom config name when default tracing is enabled. \" +\n        'Please rename your custom config to avoid conflicts.',\n    );\n  }\n\n  // Setup default config if enabled\n  if (config.default?.enabled) {\n    const defaultInstance = new DefaultAITracing({\n      serviceName: 'mastra',\n      name: 'default',\n      sampling: { type: SamplingStrategyType.ALWAYS },\n      exporters: [new DefaultExporter(), new CloudExporter()],\n      processors: [new SensitiveDataFilter()],\n    });\n\n    // Register as default with high priority\n    registerAITracing('default', defaultInstance, true);\n  }\n\n  if (config.configs) {\n    // Process user-provided configs\n    const instances = Object.entries(config.configs);\n\n    instances.forEach(([name, tracingDef], index) => {\n      const instance = isAITracingInstance(tracingDef)\n        ? tracingDef // Pre-instantiated custom implementation\n        : new DefaultAITracing({ ...tracingDef, name }); // Config -> DefaultAITracing with instance name\n\n      // First user-provided instance becomes default only if no default config\n      const isDefault = !config.default?.enabled && index === 0;\n      registerAITracing(name, instance, isDefault);\n    });\n  }\n\n  // Set selector function if provided\n  if (config.configSelector) {\n    setSelector(config.configSelector);\n  }\n}\n","/**\n * Utility functions for cleaning and manipulating metadata objects\n * used in AI tracing and observability.\n */\n\nimport type { RuntimeContext } from '../runtime-context';\nimport { getSelectedAITracing } from './registry';\nimport type {\n  AISpan,\n  AISpanTypeMap,\n  AnyAISpan,\n  TracingContext,\n  TracingOptions,\n  TracingPolicy,\n  AISpanType,\n} from './types';\n\n/**\n * Removes specific keys from an object.\n * @param obj - The original object\n * @param keysToOmit - Keys to exclude from the returned object\n * @returns A new object with the specified keys removed\n */\nexport function omitKeys<T extends Record<string, any>>(obj: T, keysToOmit: string[]): Partial<T> {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => !keysToOmit.includes(key))) as Partial<T>;\n}\n\n/**\n * Selectively extracts specific fields from an object using dot notation.\n * Does not error if fields don't exist - simply omits them from the result.\n * @param obj - The source object to extract fields from\n * @param fields - Array of field paths (supports dot notation like 'output.text')\n * @returns New object containing only the specified fields\n */\nexport function selectFields(obj: any, fields: string[]): any {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  const result: any = {};\n\n  for (const field of fields) {\n    const value = getNestedValue(obj, field);\n    if (value !== undefined) {\n      setNestedValue(result, field, value);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Gets a nested value from an object using dot notation\n * @param obj - Source object\n * @param path - Dot notation path (e.g., 'output.text')\n * @returns The value at the path, or undefined if not found\n */\nfunction getNestedValue(obj: any, path: string): any {\n  return path.split('.').reduce((current, key) => {\n    return current && typeof current === 'object' ? current[key] : undefined;\n  }, obj);\n}\n\n/**\n * Sets a nested value in an object using dot notation\n * @param obj - Target object\n * @param path - Dot notation path (e.g., 'output.text')\n * @param value - Value to set\n */\nfunction setNestedValue(obj: any, path: string, value: any): void {\n  const keys = path.split('.');\n  const lastKey = keys.pop();\n  if (!lastKey) {\n    return;\n  }\n\n  const target = keys.reduce((current, key) => {\n    if (!current[key] || typeof current[key] !== 'object') {\n      current[key] = {};\n    }\n    return current[key];\n  }, obj);\n\n  target[lastKey] = value;\n}\n\n/**\n * Extracts the trace ID from a span if it is valid.\n *\n * This helper is typically used to safely retrieve the `traceId` from a span object,\n * while gracefully handling invalid spans — such as no-op spans — by returning `undefined`.\n *\n * A span is considered valid if `span.isValid` is `true`.\n *\n * @param span - The span object to extract the trace ID from. May be `undefined`.\n * @returns The `traceId` if the span is valid, otherwise `undefined`.\n */\nexport function getValidTraceId(span?: AnyAISpan): string | undefined {\n  return span?.isValid ? span.traceId : undefined;\n}\n\n/**\n * Creates or gets a child span from existing tracing context or starts a new trace.\n * This helper consolidates the common pattern of creating spans that can either be:\n * 1. Children of an existing span (when tracingContext.currentSpan exists)\n * 2. New root spans (when no current span exists)\n *\n * @param options - Configuration object for span creation\n * @returns The created AI span or undefined if tracing is disabled\n */\nexport function getOrCreateSpan<T extends AISpanType>(options: {\n  type: T;\n  name: string;\n  input?: any;\n  attributes?: AISpanTypeMap[T];\n  metadata?: Record<string, any>;\n  tracingPolicy?: TracingPolicy;\n  tracingOptions?: TracingOptions;\n  tracingContext?: TracingContext;\n  runtimeContext?: RuntimeContext;\n}): AISpan<T> | undefined {\n  const { type, attributes, tracingContext, runtimeContext, ...rest } = options;\n\n  const metadata = {\n    ...(rest.metadata ?? {}),\n    ...(rest.tracingOptions?.metadata ?? {}),\n  };\n\n  // If we have a current span, create a child span\n  if (tracingContext?.currentSpan) {\n    return tracingContext.currentSpan.createChildSpan({\n      type,\n      attributes,\n      ...rest,\n      metadata,\n    });\n  }\n\n  // Otherwise, try to create a new root span\n  const aiTracing = getSelectedAITracing({\n    runtimeContext: runtimeContext,\n  });\n\n  return aiTracing?.startSpan<T>({\n    type,\n    attributes,\n    ...rest,\n    metadata,\n    customSamplerOptions: {\n      runtimeContext,\n      metadata,\n    },\n  });\n}\n","/**\n * AI Tracing Context Integration\n *\n * This module provides automatic AI tracing context propagation throughout Mastra's execution contexts.\n * It uses JavaScript Proxies to transparently wrap Mastra, Agent, and Workflow instances so that\n * tracing context is automatically injected without requiring manual passing by users.\n */\n\nimport type { MastraPrimitives } from '../action';\nimport type { Agent } from '../agent';\nimport type { Mastra } from '../mastra';\nimport type { Workflow } from '../workflows';\nimport type { TracingContext, AnyAISpan } from './types';\n\nconst AGENT_GETTERS = ['getAgent', 'getAgentById'];\nconst AGENT_METHODS_TO_WRAP = ['generate', 'stream', 'generateLegacy', 'streamLegacy'];\n\nconst WORKFLOW_GETTERS = ['getWorkflow', 'getWorkflowById'];\nconst WORKFLOW_METHODS_TO_WRAP = ['execute', 'createRun', 'createRunAsync'];\n\n/**\n * Helper function to detect NoOp spans to avoid unnecessary wrapping\n */\nfunction isNoOpSpan(span: AnyAISpan): boolean {\n  // Check if this is a NoOp span implementation\n  return span.constructor.name === 'NoOpAISpan' || (span as any).__isNoOp === true;\n}\n\n/**\n * Checks to see if a passed object is an actual instance of Mastra\n * (for the purposes of wrapping it for AI Tracing)\n */\nexport function isMastra<T extends Mastra | (Mastra & MastraPrimitives) | MastraPrimitives>(mastra: T): boolean {\n  const hasAgentGetters = AGENT_GETTERS.every(method => typeof (mastra as any)?.[method] === 'function');\n  const hasWorkflowGetters = WORKFLOW_GETTERS.every(method => typeof (mastra as any)?.[method] === 'function');\n\n  return hasAgentGetters && hasWorkflowGetters;\n}\n\n/**\n * Creates a tracing-aware Mastra proxy that automatically injects\n * AI tracing context into agent and workflow method calls\n */\nexport function wrapMastra<T extends Mastra | (Mastra & MastraPrimitives) | MastraPrimitives>(\n  mastra: T,\n  tracingContext: TracingContext,\n): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return mastra;\n  }\n\n  // Check if this object has the methods we want to wrap - if not, return as is\n  if (!isMastra(mastra)) {\n    return mastra;\n  }\n\n  try {\n    return new Proxy(mastra, {\n      get(target, prop) {\n        try {\n          if (AGENT_GETTERS.includes(prop as string)) {\n            return (...args: any[]) => {\n              const agent = (target as any)[prop](...args);\n              return wrapAgent(agent, tracingContext);\n            };\n          }\n\n          // Wrap workflow getters\n          if (WORKFLOW_GETTERS.includes(prop as string)) {\n            return (...args: any[]) => {\n              const workflow = (target as any)[prop](...args);\n              return wrapWorkflow(workflow, tracingContext);\n            };\n          }\n\n          // Pass through all other methods unchanged - bind functions to preserve 'this' context\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('AI Tracing: Failed to wrap method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('AI Tracing: Failed to create proxy, using original Mastra instance', error);\n    return mastra;\n  }\n}\n\n/**\n * Creates a tracing-aware Agent proxy that automatically injects\n * AI tracing context into generation method calls\n */\nfunction wrapAgent<T extends Agent>(agent: T, tracingContext: TracingContext): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return agent;\n  }\n\n  try {\n    return new Proxy(agent, {\n      get(target, prop) {\n        try {\n          if (AGENT_METHODS_TO_WRAP.includes(prop as string)) {\n            return (input: any, options: any = {}) => {\n              return (target as any)[prop](input, {\n                ...options,\n                tracingContext,\n              });\n            };\n          }\n\n          // Bind functions to preserve 'this' context for private member access\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('AI Tracing: Failed to wrap agent method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('AI Tracing: Failed to create agent proxy, using original instance', error);\n    return agent;\n  }\n}\n\n/**\n * Creates a tracing-aware Workflow proxy that automatically injects\n * AI tracing context into execution method calls\n */\nfunction wrapWorkflow<T extends Workflow>(workflow: T, tracingContext: TracingContext): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return workflow;\n  }\n\n  try {\n    return new Proxy(workflow, {\n      get(target, prop) {\n        try {\n          // Wrap workflow execution methods with tracing context\n          if (WORKFLOW_METHODS_TO_WRAP.includes(prop as string)) {\n            // Handle createRun and createRunAsync methods differently\n            if (prop === 'createRun' || prop === 'createRunAsync') {\n              return async (options: any = {}) => {\n                const run = await (target as any)[prop](options);\n                return run ? wrapRun(run, tracingContext) : run;\n              };\n            }\n\n            // Handle other methods like execute\n            return (input: any, options: any = {}) => {\n              return (target as any)[prop](input, {\n                ...options,\n                tracingContext,\n              });\n            };\n          }\n\n          // Bind functions to preserve 'this' context for private member access\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('AI Tracing: Failed to wrap workflow method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('AI Tracing: Failed to create workflow proxy, using original instance', error);\n    return workflow;\n  }\n}\n\n/**\n * Creates a tracing-aware Run proxy that automatically injects\n * AI tracing context into start method calls\n */\nfunction wrapRun<T extends object>(run: T, tracingContext: TracingContext): T {\n  // Don't wrap if no current span or if using NoOp span\n  if (!tracingContext.currentSpan || isNoOpSpan(tracingContext.currentSpan)) {\n    return run;\n  }\n\n  try {\n    return new Proxy(run, {\n      get(target, prop) {\n        try {\n          if (prop === 'start') {\n            return (startOptions: any = {}) => {\n              return (target as any).start({\n                ...startOptions,\n                tracingContext: startOptions.tracingContext ?? tracingContext,\n              });\n            };\n          }\n\n          // Pass through all other properties and methods unchanged\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        } catch (error) {\n          console.warn('AI Tracing: Failed to wrap run method, falling back to original', error);\n          const value = (target as any)[prop];\n          return typeof value === 'function' ? value.bind(target) : value;\n        }\n      },\n    });\n  } catch (error) {\n    console.warn('AI Tracing: Failed to create run proxy, using original instance', error);\n    return run;\n  }\n}\n"]}