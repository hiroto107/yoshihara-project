{"version":3,"sources":["../src/llm/model/registry-generator.ts"],"names":[],"mappings":"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","file":"registry-generator-DXRSYYYT.js","sourcesContent":["/**\n * Shared provider registry generation logic\n * Used by both the CLI generation script and runtime refresh\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { MastraModelGateway, ProviderConfig } from './gateways/base.js';\n\n/**\n * Fetch providers from all gateways with retry logic\n * @param gateways - Array of gateway instances to fetch from\n * @returns Object containing providers and models records\n */\nexport async function fetchProvidersFromGateways(\n  gateways: MastraModelGateway[],\n): Promise<{ providers: Record<string, ProviderConfig>; models: Record<string, string[]> }> {\n  const allProviders: Record<string, ProviderConfig> = {};\n  const allModels: Record<string, string[]> = {};\n\n  const maxRetries = 3;\n\n  for (const gateway of gateways) {\n    let lastError: Error | null = null;\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const providers = await gateway.fetchProviders();\n\n        for (const [providerId, config] of Object.entries(providers)) {\n          allProviders[providerId] = config;\n          // Sort models alphabetically for consistent ordering\n          allModels[providerId] = config.models.sort();\n        }\n\n        lastError = null;\n        break; // Success, exit retry loop\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < maxRetries) {\n          // Wait before retrying (exponential backoff)\n          const delayMs = Math.min(1000 * Math.pow(2, attempt - 1), 5000);\n          await new Promise(resolve => setTimeout(resolve, delayMs));\n        }\n      }\n    }\n\n    // If all retries failed, throw the last error\n    if (lastError) {\n      throw lastError;\n    }\n  }\n\n  return { providers: allProviders, models: allModels };\n}\n\n/**\n * Generate TypeScript type definitions content\n * @param models - Record of provider IDs to model arrays\n * @returns Generated TypeScript type definitions as a string\n */\nexport function generateTypesContent(models: Record<string, string[]>): string {\n  const providerModelsEntries = Object.entries(models)\n    .map(([provider, modelList]) => {\n      const modelsList = modelList.map(m => `'${m}'`);\n\n      // Only quote provider key if it contains special characters (like dashes)\n      const needsQuotes = /[^a-zA-Z0-9_$]/.test(provider);\n      const providerKey = needsQuotes ? `'${provider}'` : provider;\n\n      // Format array based on length (prettier printWidth: 120)\n      const singleLine = `  readonly ${providerKey}: readonly [${modelsList.join(', ')}];`;\n\n      // If single line exceeds 120 chars, format as multi-line\n      if (singleLine.length > 120) {\n        const formattedModels = modelList.map(m => `    '${m}',`).join('\\n');\n        return `  readonly ${providerKey}: readonly [\\n${formattedModels}\\n  ];`;\n      }\n\n      return singleLine;\n    })\n    .join('\\n');\n\n  return `/**\n * THIS FILE IS AUTO-GENERATED - DO NOT EDIT\n * Generated from model gateway providers\n */\n\n/**\n * Provider models mapping type\n * This is derived from the JSON data and provides type-safe access\n */\nexport type ProviderModelsMap = {\n${providerModelsEntries}\n};\n\n/**\n * Union type of all registered provider IDs\n */\nexport type Provider = keyof ProviderModelsMap;\n\n/**\n * Provider models mapping interface\n */\nexport interface ProviderModels {\n  [key: string]: string[];\n}\n\n/**\n * OpenAI-compatible model ID type\n * Dynamically derived from ProviderModelsMap\n * Full provider/model paths (e.g., \"openai/gpt-4o\", \"anthropic/claude-3-5-sonnet-20241022\")\n */\nexport type ModelRouterModelId =\n  | {\n      [P in Provider]: \\`\\${P}/\\${ProviderModelsMap[P][number]}\\`;\n    }[Provider]\n  | (string & {});\n\n/**\n * Extract the model part from a ModelRouterModelId for a specific provider\n * Dynamically derived from ProviderModelsMap\n * Example: ModelForProvider<'openai'> = 'gpt-4o' | 'gpt-4-turbo' | ...\n */\nexport type ModelForProvider<P extends Provider> = ProviderModelsMap[P][number];\n`;\n}\n\n/**\n * Write registry files to disk (JSON and .d.ts)\n * @param jsonPath - Path to write the JSON file\n * @param typesPath - Path to write the .d.ts file\n * @param providers - Provider configurations\n * @param models - Model lists by provider\n */\nexport async function writeRegistryFiles(\n  jsonPath: string,\n  typesPath: string,\n  providers: Record<string, ProviderConfig>,\n  models: Record<string, string[]>,\n): Promise<void> {\n  // 0. Ensure directories exist\n  const jsonDir = path.dirname(jsonPath);\n  const typesDir = path.dirname(typesPath);\n  await fs.mkdir(jsonDir, { recursive: true });\n  await fs.mkdir(typesDir, { recursive: true });\n\n  // 1. Write JSON file\n  const registryData = {\n    providers,\n    models,\n    version: '1.0.0',\n  };\n\n  await fs.writeFile(jsonPath, JSON.stringify(registryData, null, 2), 'utf-8');\n\n  // 2. Generate .d.ts file with type-only declarations\n  const typeContent = generateTypesContent(models);\n  await fs.writeFile(typesPath, typeContent, 'utf-8');\n}\n"]}