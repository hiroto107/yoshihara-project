{"version":3,"sources":["../src/eval/metric.ts","../src/eval/evaluation.ts"],"names":[],"mappings":";;;;AAKO,IAAe,SAAf,MAAsB;AAE7B;;;ACDA,eAAsB,QAAA,CAA0B;AAAA,EAC9C,SAAA;AAAA,EACA,KAAA;AAAA,EACA,MAAA;AAAA,EACA,MAAA;AAAA,EACA,KAAA;AAAA,EACA,WAAA;AAAA,EACA,QAAA;AAAA,EACA;AACF,CAAA,EAS8B;AAC5B,EAAA,MAAM,UAAA,GAAa,KAAA,IAAS,MAAA,CAAO,UAAA,EAAW;AAE9C,EAAA,IAAI,YAAA;AACJ,EAAA,IAAI,UAAA,GAAa,OAAO,WAAA,CAAY,IAAA;AACpC,EAAA,IAAI;AACF,IAAA,YAAA,GAAe,MAAM,MAAA,CAAO,OAAA,CAAQ,KAAA,CAAM,QAAA,IAAY,MAAM,CAAA;AAAA,EAC9D,SAAS,CAAA,EAAY;AACnB,IAAA,MAAM,IAAI,WAAA;AAAA,MACR;AAAA,QACE,EAAA,EAAI,sCAAA;AAAA,QACJ,MAAA,EAAA,MAAA;AAAA,QACA,QAAA,EAAA,MAAA;AAAA,QACA,OAAA,EAAS;AAAA,UACP,SAAA;AAAA,UACA,UAAA;AAAA,UACA;AAAA;AACF,OACF;AAAA,MACA;AAAA,KACF;AAAA,EACF;AACA,EAAA,MAAM,WAAA,GAAc;AAAA,IAClB,KAAA,EAAO,MAAM,QAAA,EAAS;AAAA,IACtB,MAAA;AAAA,IACA,MAAA,EAAQ,YAAA;AAAA,IACR,SAAA;AAAA,IACA,UAAA;AAAA,IACA,YAAA;AAAA,IACA,WAAA;AAAA,IACA,KAAA,EAAO,UAAA;AAAA,IACP;AAAA,GACF;AAEA,EAAA,IAAI;AACF,IAAA,WAAA,CAAA,cAAA,sBAA0C,WAAW,CAAA;AAAA,EACvD,SAAS,CAAA,EAAY;AACnB,IAAA,MAAM,IAAI,WAAA;AAAA,MACR;AAAA,QACE,EAAA,EAAI,4BAAA;AAAA,QACJ,MAAA,EAAA,MAAA;AAAA,QACA,QAAA,EAAA,MAAA;AAAA,QACA,OAAA,EAAS;AAAA,UACP,SAAA;AAAA,UACA,UAAA;AAAA,UACA;AAAA;AACF,OACF;AAAA,MACA;AAAA,KACF;AAAA,EACF;AAEA,EAAA,OAAO,EAAE,GAAG,YAAA,EAAc,MAAA,EAAO;AACnC","file":"chunk-M4AX46DS.js","sourcesContent":["export interface MetricResult {\n  score: number;\n  info?: Record<string, any>;\n}\n\nexport abstract class Metric {\n  abstract measure(input: string, output: string): Promise<MetricResult>;\n}\n","import type { Agent } from '../agent';\nimport { MastraError, ErrorCategory, ErrorDomain } from '../error';\nimport { AvailableHooks, executeHook } from '../hooks';\nimport type { Metric } from './metric';\nimport type { TestInfo, EvaluationResult } from './types';\n\nexport async function evaluate<T extends Agent>({\n  agentName,\n  input,\n  metric,\n  output,\n  runId,\n  globalRunId,\n  testInfo,\n  instructions,\n}: {\n  agentName: string;\n  input: Parameters<T['generate']>[0];\n  metric: Metric;\n  output: string;\n  globalRunId: string;\n  runId?: string;\n  testInfo?: TestInfo;\n  instructions: string;\n}): Promise<EvaluationResult> {\n  const runIdToUse = runId || crypto.randomUUID();\n\n  let metricResult;\n  let metricName = metric.constructor.name;\n  try {\n    metricResult = await metric.measure(input.toString(), output);\n  } catch (e: unknown) {\n    throw new MastraError(\n      {\n        id: 'EVAL_METRIC_MEASURE_EXECUTION_FAILED',\n        domain: ErrorDomain.EVAL,\n        category: ErrorCategory.USER,\n        details: {\n          agentName,\n          metricName,\n          globalRunId,\n        },\n      },\n      e,\n    );\n  }\n  const traceObject = {\n    input: input.toString(),\n    output: output,\n    result: metricResult,\n    agentName,\n    metricName,\n    instructions,\n    globalRunId,\n    runId: runIdToUse,\n    testInfo,\n  };\n\n  try {\n    executeHook(AvailableHooks.ON_EVALUATION, traceObject);\n  } catch (e: unknown) {\n    throw new MastraError(\n      {\n        id: 'EVAL_HOOK_EXECUTION_FAILED',\n        domain: ErrorDomain.EVAL,\n        category: ErrorCategory.USER,\n        details: {\n          agentName,\n          metricName,\n          globalRunId,\n        },\n      },\n      e,\n    );\n  }\n\n  return { ...metricResult, output };\n}\n"]}