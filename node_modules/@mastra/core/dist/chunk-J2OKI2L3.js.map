{"version":3,"sources":["../src/memory/memory.ts"],"names":[],"mappings":"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","file":"chunk-J2OKI2L3.js","sourcesContent":["import type { EmbeddingModelV2 } from '@ai-sdk/provider-v5';\nimport type { AssistantContent, UserContent, CoreMessage, EmbeddingModel } from 'ai';\nimport { MessageList } from '../agent/message-list';\nimport type { MastraMessageV2, UIMessageWithMetadata } from '../agent/message-list';\nimport { MastraBase } from '../base';\nimport type { Mastra } from '../mastra';\nimport type { MastraStorage, PaginationInfo, StorageGetMessagesArg, ThreadSortOptions } from '../storage';\nimport { augmentWithInit } from '../storage/storageWithInit';\nimport type { ToolAction } from '../tools';\nimport { deepMerge } from '../utils';\nimport type { MastraVector } from '../vector';\n\nimport type {\n  SharedMemoryConfig,\n  StorageThreadType,\n  MemoryConfig,\n  MastraMessageV1,\n  WorkingMemoryTemplate,\n} from './types';\n\nexport type MemoryProcessorOpts = {\n  systemMessage?: string;\n  memorySystemMessage?: string;\n  newMessages?: CoreMessage[];\n};\n/**\n * Interface for message processors that can filter or transform messages\n * before they're sent to the LLM.\n */\nexport abstract class MemoryProcessor extends MastraBase {\n  /**\n   * Process a list of messages and return a filtered or transformed list.\n   * @param messages The messages to process\n   * @returns The processed messages\n   */\n  process(messages: CoreMessage[], _opts: MemoryProcessorOpts): CoreMessage[] | Promise<CoreMessage[]> {\n    return messages;\n  }\n}\n\nexport const memoryDefaultOptions = {\n  lastMessages: 10,\n  semanticRecall: false,\n  threads: {\n    generateTitle: true,\n  },\n  workingMemory: {\n    enabled: false,\n    template: `\n# User Information\n- **First Name**: \n- **Last Name**: \n- **Location**: \n- **Occupation**: \n- **Interests**: \n- **Goals**: \n- **Events**: \n- **Facts**: \n- **Projects**: \n`,\n  },\n} satisfies MemoryConfig;\n\n/**\n * Abstract base class for implementing conversation memory systems.\n *\n * Key features:\n * - Thread-based conversation organization with resource association\n * - Optional vector database integration for semantic similarity search\n * - Working memory templates for structured conversation state\n * - Handles memory processors to manipulate messages before they are sent to the LLM\n */\nexport abstract class MastraMemory extends MastraBase {\n  MAX_CONTEXT_TOKENS?: number;\n\n  protected _storage?: MastraStorage;\n  vector?: MastraVector;\n  embedder?: EmbeddingModel<string> | EmbeddingModelV2<string>;\n  private processors: MemoryProcessor[] = [];\n  protected threadConfig: MemoryConfig = { ...memoryDefaultOptions };\n  #mastra?: Mastra;\n\n  constructor(config: { name: string } & SharedMemoryConfig) {\n    super({ component: 'MEMORY', name: config.name });\n\n    if (config.options) this.threadConfig = this.getMergedThreadConfig(config.options);\n    if (config.processors) this.processors = config.processors;\n    if (config.storage) {\n      this._storage = augmentWithInit(config.storage);\n      this._hasOwnStorage = true;\n    }\n\n    if (this.threadConfig.semanticRecall) {\n      if (!config.vector) {\n        throw new Error(\n          `Semantic recall requires a vector store to be configured.\\n\\nhttps://mastra.ai/en/docs/memory/semantic-recall`,\n        );\n      }\n      this.vector = config.vector;\n\n      if (!config.embedder) {\n        throw new Error(\n          `Semantic recall requires an embedder to be configured.\\n\\nhttps://mastra.ai/en/docs/memory/semantic-recall`,\n        );\n      }\n      this.embedder = config.embedder;\n    }\n  }\n\n  /**\n   * Internal method used by Mastra to register itself with the memory.\n   * @param mastra The Mastra instance.\n   * @internal\n   */\n  __registerMastra(mastra: Mastra): void {\n    this.#mastra = mastra;\n  }\n\n  protected _hasOwnStorage = false;\n  get hasOwnStorage() {\n    return this._hasOwnStorage;\n  }\n\n  get storage() {\n    if (!this._storage) {\n      throw new Error(\n        `Memory requires a storage provider to function. Add a storage configuration to Memory or to your Mastra instance.\\n\\nhttps://mastra.ai/en/docs/memory/overview`,\n      );\n    }\n    return this._storage;\n  }\n\n  public setStorage(storage: MastraStorage) {\n    this._storage = augmentWithInit(storage);\n  }\n\n  public setVector(vector: MastraVector) {\n    this.vector = vector;\n  }\n\n  public setEmbedder(embedder: EmbeddingModel<string>) {\n    this.embedder = embedder;\n  }\n\n  /**\n   * Get a system message to inject into the conversation.\n   * This will be called before each conversation turn.\n   * Implementations can override this to inject custom system messages.\n   */\n  public async getSystemMessage(_input: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null> {\n    return null;\n  }\n\n  /**\n   * Get tools that should be available to the agent.\n   * This will be called when converting tools for the agent.\n   * Implementations can override this to provide additional tools.\n   */\n  public getTools(_config?: MemoryConfig): Record<string, ToolAction<any, any, any>> {\n    return {};\n  }\n\n  protected async createEmbeddingIndex(dimensions?: number, config?: MemoryConfig): Promise<{ indexName: string }> {\n    const defaultDimensions = 1536;\n    const isDefault = dimensions === defaultDimensions;\n    const usedDimensions = dimensions ?? defaultDimensions;\n    const separator = this.vector?.indexSeparator ?? '_';\n    const indexName = isDefault\n      ? `memory${separator}messages`\n      : `memory${separator}messages${separator}${usedDimensions}`;\n\n    if (typeof this.vector === `undefined`) {\n      throw new Error(`Tried to create embedding index but no vector db is attached to this Memory instance.`);\n    }\n\n    // Get index configuration from memory config\n    const semanticConfig = typeof config?.semanticRecall === 'object' ? config.semanticRecall : undefined;\n    const indexConfig = semanticConfig?.indexConfig;\n\n    // Base parameters that all vector stores support\n    const createParams: any = {\n      indexName,\n      dimension: usedDimensions,\n      ...(indexConfig?.metric && { metric: indexConfig.metric }),\n    };\n\n    // Add PG-specific configuration if provided\n    // Only PG vector store will use these parameters\n    if (indexConfig && (indexConfig.type || indexConfig.ivf || indexConfig.hnsw)) {\n      createParams.indexConfig = {};\n      if (indexConfig.type) createParams.indexConfig.type = indexConfig.type;\n      if (indexConfig.ivf) createParams.indexConfig.ivf = indexConfig.ivf;\n      if (indexConfig.hnsw) createParams.indexConfig.hnsw = indexConfig.hnsw;\n    }\n\n    await this.vector.createIndex(createParams);\n    return { indexName };\n  }\n\n  public getMergedThreadConfig(config?: MemoryConfig): MemoryConfig {\n    if (config?.workingMemory && 'use' in config.workingMemory) {\n      throw new Error('The workingMemory.use option has been removed. Working memory always uses tool-call mode.');\n    }\n    const mergedConfig = deepMerge(this.threadConfig, config || {});\n\n    if (config?.workingMemory?.schema) {\n      if (mergedConfig.workingMemory) {\n        mergedConfig.workingMemory.schema = config.workingMemory.schema;\n      }\n    }\n\n    return mergedConfig;\n  }\n\n  /**\n   * Apply all configured message processors to a list of messages.\n   * @param messages The messages to process\n   * @returns The processed messages\n   */\n  protected async applyProcessors(\n    messages: CoreMessage[],\n    opts: {\n      processors?: MemoryProcessor[];\n    } & MemoryProcessorOpts,\n  ): Promise<CoreMessage[]> {\n    const processors = opts.processors || this.processors;\n    if (!processors || processors.length === 0) {\n      return messages;\n    }\n\n    let processedMessages = [...messages];\n\n    for (const processor of processors) {\n      processedMessages = await processor.process(processedMessages, {\n        systemMessage: opts.systemMessage,\n        newMessages: opts.newMessages,\n        memorySystemMessage: opts.memorySystemMessage,\n      });\n    }\n\n    return processedMessages;\n  }\n\n  processMessages({\n    messages,\n    processors,\n    ...opts\n  }: {\n    messages: CoreMessage[];\n    processors?: MemoryProcessor[];\n  } & MemoryProcessorOpts) {\n    return this.applyProcessors(messages, { processors: processors || this.processors, ...opts });\n  }\n\n  abstract rememberMessages({\n    threadId,\n    resourceId,\n    vectorMessageSearch,\n    config,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    vectorMessageSearch?: string;\n    config?: MemoryConfig;\n  }): Promise<{ messages: MastraMessageV1[]; messagesV2: MastraMessageV2[] }>;\n\n  estimateTokens(text: string): number {\n    return Math.ceil(text.split(' ').length * 1.3);\n  }\n\n  /**\n   * Retrieves a specific thread by its ID\n   * @param threadId - The unique identifier of the thread\n   * @returns Promise resolving to the thread or null if not found\n   */\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  /**\n   * Retrieves all threads that belong to the specified resource.\n   * @param resourceId - The unique identifier of the resource\n   * @param orderBy - Which timestamp field to sort by (`'createdAt'` or `'updatedAt'`);\n   *                  defaults to `'createdAt'`\n   * @param sortDirection - Sort order for the results (`'ASC'` or `'DESC'`);\n   *                        defaults to `'DESC'`\n   * @returns Promise resolving to an array of matching threads; resolves to an empty array\n   *          if the resource has no threads\n   */\n  abstract getThreadsByResourceId({\n    resourceId,\n    orderBy,\n    sortDirection,\n  }: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]>;\n\n  abstract getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }>;\n\n  /**\n   * Saves or updates a thread\n   * @param thread - The thread data to save\n   * @returns Promise resolving to the saved thread\n   */\n  abstract saveThread({\n    thread,\n    memoryConfig,\n  }: {\n    thread: StorageThreadType;\n    memoryConfig?: MemoryConfig;\n  }): Promise<StorageThreadType>;\n\n  /**\n   * Saves messages to a thread\n   * @param messages - Array of messages to save\n   * @returns Promise resolving to the saved messages\n   */\n  abstract saveMessages(args: {\n    messages: (MastraMessageV1 | MastraMessageV2)[] | MastraMessageV1[] | MastraMessageV2[];\n    memoryConfig?: MemoryConfig | undefined;\n    format?: 'v1';\n  }): Promise<MastraMessageV1[]>;\n  abstract saveMessages(args: {\n    messages: (MastraMessageV1 | MastraMessageV2)[] | MastraMessageV1[] | MastraMessageV2[];\n    memoryConfig?: MemoryConfig | undefined;\n    format: 'v2';\n  }): Promise<MastraMessageV2[]>;\n  abstract saveMessages(args: {\n    messages: (MastraMessageV1 | MastraMessageV2)[] | MastraMessageV1[] | MastraMessageV2[];\n    memoryConfig?: MemoryConfig | undefined;\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV2[] | MastraMessageV1[]>;\n\n  /**\n   * Retrieves all messages for a specific thread\n   * @param threadId - The unique identifier of the thread\n   * @returns Promise resolving to array of messages and uiMessages\n   */\n  abstract query({\n    threadId,\n    resourceId,\n    selectBy,\n  }: StorageGetMessagesArg): Promise<{ messages: CoreMessage[]; uiMessages: UIMessageWithMetadata[] }>;\n\n  /**\n   * Helper method to create a new thread\n   * @param title - Optional title for the thread\n   * @param metadata - Optional metadata for the thread\n   * @returns Promise resolving to the created thread\n   */\n  async createThread({\n    threadId,\n    resourceId,\n    title,\n    metadata,\n    memoryConfig,\n    saveThread = true,\n  }: {\n    resourceId: string;\n    threadId?: string;\n    title?: string;\n    metadata?: Record<string, unknown>;\n    memoryConfig?: MemoryConfig;\n    saveThread?: boolean;\n  }): Promise<StorageThreadType> {\n    const thread: StorageThreadType = {\n      id: threadId || this.generateId(),\n      title: title || `New Thread ${new Date().toISOString()}`,\n      resourceId,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      metadata,\n    };\n\n    return saveThread ? this.saveThread({ thread, memoryConfig }) : thread;\n  }\n\n  /**\n   * Helper method to delete a thread\n   * @param threadId - the id of the thread to delete\n   */\n  abstract deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Helper method to add a single message to a thread\n   * @param threadId - The thread to add the message to\n   * @param content - The message content\n   * @param role - The role of the message sender\n   * @param type - The type of the message\n   * @param toolNames - Optional array of tool names that were called\n   * @param toolCallArgs - Optional array of tool call arguments\n   * @param toolCallIds - Optional array of tool call ids\n   * @returns Promise resolving to the saved message\n   * @deprecated use saveMessages instead\n   */\n  async addMessage({\n    threadId,\n    resourceId,\n    config,\n    content,\n    role,\n    type,\n    toolNames,\n    toolCallArgs,\n    toolCallIds,\n  }: {\n    threadId: string;\n    resourceId: string;\n    config?: MemoryConfig;\n    content: UserContent | AssistantContent;\n    role: 'user' | 'assistant';\n    type: 'text' | 'tool-call' | 'tool-result';\n    toolNames?: string[];\n    toolCallArgs?: Record<string, unknown>[];\n    toolCallIds?: string[];\n  }): Promise<MastraMessageV1> {\n    const message: MastraMessageV1 = {\n      id: this.generateId(),\n      content,\n      role,\n      createdAt: new Date(),\n      threadId,\n      resourceId,\n      type,\n      toolNames,\n      toolCallArgs,\n      toolCallIds,\n    };\n\n    const savedMessages = await this.saveMessages({ messages: [message], memoryConfig: config });\n    const list = new MessageList({ threadId, resourceId }).add(savedMessages[0]!, 'memory');\n    return list.get.all.v1()[0]!;\n  }\n\n  /**\n   * Generates a unique identifier\n   * @returns A unique string ID\n   */\n  public generateId(): string {\n    return this.#mastra?.generateId() || crypto.randomUUID();\n  }\n\n  /**\n   * Retrieves working memory for a specific thread\n   * @param threadId - The unique identifier of the thread\n   * @param resourceId - The unique identifier of the resource\n   * @param memoryConfig - Optional memory configuration\n   * @returns Promise resolving to working memory data or null if not found\n   */\n  abstract getWorkingMemory({\n    threadId,\n    resourceId,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null>;\n\n  /**\n   * Retrieves working memory template for a specific thread\n   * @param memoryConfig - Optional memory configuration\n   * @returns Promise resolving to working memory template or null if not found\n   */\n  abstract getWorkingMemoryTemplate({\n    memoryConfig,\n  }?: {\n    memoryConfig?: MemoryConfig;\n  }): Promise<WorkingMemoryTemplate | null>;\n\n  abstract updateWorkingMemory({\n    threadId,\n    resourceId,\n    workingMemory,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<void>;\n\n  /**\n   * @warning experimental! can be removed or changed at any time\n   */\n  abstract __experimental_updateWorkingMemoryVNext({\n    threadId,\n    resourceId,\n    workingMemory,\n    searchString,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    searchString?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<{ success: boolean; reason: string }>;\n\n  /**\n   * Deletes multiple messages by their IDs\n   * @param messageIds - Array of message IDs to delete\n   * @returns Promise that resolves when all messages are deleted\n   */\n  abstract deleteMessages(messageIds: string[]): Promise<void>;\n}\n"]}