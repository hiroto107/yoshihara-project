import { z } from 'zod';
import type { TracingContext } from '../ai-tracing/index.js';
import type { MastraModelConfig } from '../llm/model/shared.types.js';
import type { ScoringSamplingConfig, ScorerRunInputForAgent, ScorerRunOutputForAgent } from './types.js';
interface ScorerStepDefinition {
    name: string;
    definition: any;
    isPromptObject: boolean;
}
type ScorerTypeShortcuts = {
    agent: {
        input: ScorerRunInputForAgent;
        output: ScorerRunOutputForAgent;
    };
};
interface ScorerConfig<TName extends string = string, TInput = any, TRunOutput = any> {
    name: TName;
    description: string;
    judge?: {
        model: MastraModelConfig;
        instructions: string;
    };
    type?: keyof ScorerTypeShortcuts | {
        input: z.ZodSchema<TInput>;
        output: z.ZodSchema<TRunOutput>;
    };
}
interface ScorerRun<TInput = any, TOutput = any> {
    runId?: string;
    input?: TInput;
    output: TOutput;
    groundTruth?: any;
    runtimeContext?: Record<string, any>;
    tracingContext?: TracingContext;
}
interface PromptObject<TOutput, TAccumulated extends Record<string, any>, TStepName extends string = string, TInput = any, TRunOutput = any> {
    description: string;
    outputSchema: z.ZodSchema<TOutput>;
    judge?: {
        model: MastraModelConfig;
        instructions: string;
    };
    createPrompt: (context: PromptObjectContext<TAccumulated, TStepName, TInput, TRunOutput>) => string | Promise<string>;
}
type StepResultKey<T extends string> = `${T}StepResult`;
type Awaited<T> = T extends Promise<infer U> ? U : T;
type StepContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = {
    run: ScorerRun<TInput, TRunOutput>;
    results: TAccumulated;
};
type AccumulatedResults<T extends Record<string, any>, K extends string, V> = T & Record<StepResultKey<K>, V>;
type GenerateReasonContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = StepContext<TAccumulated, TInput, TRunOutput> & {
    score: TAccumulated extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;
};
type ScorerRunResult<TAccumulatedResults extends Record<string, any>, TInput, TRunOutput> = Promise<ScorerRun<TInput, TRunOutput> & {
    score: TAccumulatedResults extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;
    reason?: TAccumulatedResults extends Record<'generateReasonStepResult', infer TReason> ? TReason : undefined;
    preprocessPrompt?: string;
    analyzePrompt?: string;
    generateScorePrompt?: string;
    generateReasonPrompt?: string;
    preprocessStepResult?: TAccumulatedResults extends Record<'preprocessStepResult', infer TPreprocess> ? TPreprocess : undefined;
    analyzeStepResult?: TAccumulatedResults extends Record<'analyzeStepResult', infer TAnalyze> ? TAnalyze : undefined;
} & {
    runId: string;
}>;
type PromptObjectContext<TAccumulated extends Record<string, any>, TStepName extends string, TInput, TRunOutput> = TStepName extends 'generateReason' ? GenerateReasonContext<TAccumulated, TInput, TRunOutput> : StepContext<TAccumulated, TInput, TRunOutput>;
type FunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput, TOutput> = ((context: StepContext<TAccumulated, TInput, TRunOutput>) => TOutput) | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<TOutput>);
type GenerateReasonFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> = ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => any) | ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => Promise<any>);
type GenerateScoreFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> = ((context: StepContext<TAccumulated, TInput, TRunOutput>) => number) | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<number>);
interface GenerateScorePromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {
    description: string;
    judge?: {
        model: MastraModelConfig;
        instructions: string;
    };
    createPrompt: (context: StepContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;
}
interface GenerateReasonPromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {
    description: string;
    judge?: {
        model: MastraModelConfig;
        instructions: string;
    };
    createPrompt: (context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;
}
type PreprocessStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> = FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput> | PromptObject<TStepOutput, TAccumulated, 'preprocess', TInput, TRunOutput>;
type AnalyzeStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> = FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput> | PromptObject<TStepOutput, TAccumulated, 'analyze', TInput, TRunOutput>;
type GenerateScoreStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> = GenerateScoreFunctionStep<TAccumulated, TInput, TRunOutput> | GenerateScorePromptObject<TAccumulated, TInput, TRunOutput>;
type GenerateReasonStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> = GenerateReasonFunctionStep<TAccumulated, TInput, TRunOutput> | GenerateReasonPromptObject<TAccumulated, TInput, TRunOutput>;
declare class MastraScorer<TName extends string = string, TInput = any, TRunOutput = any, TAccumulatedResults extends Record<string, any> = {}> {
    config: ScorerConfig<TName, TInput, TRunOutput>;
    private steps;
    private originalPromptObjects;
    constructor(config: ScorerConfig<TName, TInput, TRunOutput>, steps?: Array<ScorerStepDefinition>, originalPromptObjects?: Map<string, PromptObject<any, any, any, TInput, TRunOutput> | GenerateReasonPromptObject<any, TInput, TRunOutput> | GenerateScorePromptObject<any, TInput, TRunOutput>>);
    get type(): "agent" | {
        input: z.ZodType<TInput, z.ZodTypeDef, TInput>;
        output: z.ZodType<TRunOutput, z.ZodTypeDef, TRunOutput>;
    } | undefined;
    get name(): TName;
    get description(): string;
    get judge(): {
        model: MastraModelConfig;
        instructions: string;
    } | undefined;
    preprocess<TPreprocessOutput>(stepDef: PreprocessStepDef<TAccumulatedResults, TPreprocessOutput, TInput, TRunOutput>): MastraScorer<TName, TInput, TRunOutput, AccumulatedResults<TAccumulatedResults, 'preprocess', Awaited<TPreprocessOutput>>>;
    analyze<TAnalyzeOutput>(stepDef: AnalyzeStepDef<TAccumulatedResults, TAnalyzeOutput, TInput, TRunOutput>): MastraScorer<TName, TInput, TRunOutput, AccumulatedResults<TAccumulatedResults, 'analyze', Awaited<TAnalyzeOutput>>>;
    generateScore<TScoreOutput extends number = number>(stepDef: GenerateScoreStepDef<TAccumulatedResults, TInput, TRunOutput>): MastraScorer<TName, TInput, TRunOutput, AccumulatedResults<TAccumulatedResults, 'generateScore', Awaited<TScoreOutput>>>;
    generateReason<TReasonOutput = string>(stepDef: GenerateReasonStepDef<TAccumulatedResults, TInput, TRunOutput>): MastraScorer<TName, TInput, TRunOutput, AccumulatedResults<TAccumulatedResults, 'generateReason', Awaited<TReasonOutput>>>;
    private get hasGenerateScore();
    run(input: ScorerRun<TInput, TRunOutput>): ScorerRunResult<TAccumulatedResults, TInput, TRunOutput>;
    private isPromptObject;
    getSteps(): Array<{
        name: string;
        type: 'function' | 'prompt';
        description?: string;
    }>;
    private toMastraWorkflow;
    private createScorerContext;
    private executeFunctionStep;
    private executePromptStep;
    private transformToScorerResult;
}
export declare function createScorer<TName extends string, TType extends keyof ScorerTypeShortcuts>(config: Omit<ScorerConfig<TName, any, any>, 'type'> & {
    type: TType;
}): MastraScorer<TName, ScorerTypeShortcuts[TType]['input'], ScorerTypeShortcuts[TType]['output'], {}>;
export declare function createScorer<TName extends string, TInputSchema extends z.ZodTypeAny, TOutputSchema extends z.ZodTypeAny>(config: Omit<ScorerConfig<TName, z.infer<TInputSchema>, z.infer<TOutputSchema>>, 'type'> & {
    type: {
        input: TInputSchema;
        output: TOutputSchema;
    };
}): MastraScorer<TName, z.infer<TInputSchema>, z.infer<TOutputSchema>, {}>;
export declare function createScorer<TInput = any, TRunOutput = any, TName extends string = string>(config: ScorerConfig<TName, TInput, TRunOutput>): MastraScorer<TName, TInput, TRunOutput, {}>;
export type MastraScorerEntry = {
    scorer: MastraScorer<any, any, any>;
    sampling?: ScoringSamplingConfig;
};
export type MastraScorers = Record<string, MastraScorerEntry>;
export type { ScorerConfig, ScorerRun, PromptObject };
export { MastraScorer };
//# sourceMappingURL=base.d.ts.map