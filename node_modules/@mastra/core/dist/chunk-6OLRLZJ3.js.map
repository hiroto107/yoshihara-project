{"version":3,"sources":["../src/tools/validation.ts","../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":[],"mappings":"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","file":"chunk-6OLRLZJ3.js","sourcesContent":["import type { z } from 'zod';\nimport type { ZodLikeSchema } from '../types/zod-compat';\n\nexport interface ValidationError<T = any> {\n  error: true;\n  message: string;\n  validationErrors: z.ZodFormattedError<T>;\n}\n\n/**\n * Validates input against a Zod schema and returns a structured error if validation fails\n * @param schema The Zod schema to validate against\n * @param input The input to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validation error object if validation fails, undefined if successful\n */\nexport function validateToolInput<T = any>(\n  schema: ZodLikeSchema | undefined,\n  input: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  if (!schema || !('safeParse' in schema)) {\n    return { data: input };\n  }\n\n  // Store validation results to avoid duplicate validation\n  type ValidationAttempt = {\n    result: { success: boolean; data?: any; error?: any };\n    data: unknown;\n    structure: 'direct' | 'context' | 'inputData';\n  };\n\n  const validationAttempts: ValidationAttempt[] = [];\n\n  // Try validating the input directly first\n  const directValidation = schema.safeParse(input);\n  validationAttempts.push({\n    result: directValidation,\n    data: input,\n    structure: 'direct',\n  });\n\n  if (directValidation.success) {\n    return { data: input };\n  }\n\n  // Handle ToolExecutionContext format { context: data, ... }\n  if (input && typeof input === 'object' && 'context' in input) {\n    const contextData = (input as any).context;\n    const contextValidation = schema.safeParse(contextData);\n    validationAttempts.push({\n      result: contextValidation,\n      data: contextData,\n      structure: 'context',\n    });\n\n    if (contextValidation.success) {\n      return { data: { ...(input as object), context: contextValidation.data } };\n    }\n\n    // Handle StepExecutionContext format { context: { inputData: data, ... }, ... }\n    if (contextData && typeof contextData === 'object' && 'inputData' in contextData) {\n      const inputDataValue = (contextData as any).inputData;\n      const inputDataValidation = schema.safeParse(inputDataValue);\n      validationAttempts.push({\n        result: inputDataValidation,\n        data: inputDataValue,\n        structure: 'inputData',\n      });\n\n      if (inputDataValidation.success) {\n        // For inputData unwrapping, preserve the structure if the original context had additional properties\n        // but return just the validated data if it was a pure inputData wrapper\n        const contextKeys = Object.keys(contextData);\n\n        // If context only has inputData, return the full structure with the validated data\n        // Otherwise, return just the validated inputData\n        if (contextKeys.length === 1 && contextKeys[0] === 'inputData') {\n          return { data: { ...(input as object), context: { inputData: inputDataValidation.data } } };\n        } else {\n          // Multiple keys in context, return just the validated data\n          return { data: inputDataValidation.data };\n        }\n      }\n    }\n  }\n\n  // All validations failed, find the best error to return\n  // Prefer the most specific error (deepest unwrapping level that has meaningful errors)\n  let bestAttempt = validationAttempts[0]; // Start with direct validation\n\n  for (const attempt of validationAttempts) {\n    if (!attempt.result.success && attempt.result.error.issues.length > 0) {\n      bestAttempt = attempt;\n    }\n  }\n\n  // Use the best validation attempt for error reporting\n  if (bestAttempt && !bestAttempt.result.success) {\n    const errorMessages = bestAttempt.result.error.issues\n      .map((e: z.ZodIssue) => `- ${e.path?.join('.') || 'root'}: ${e.message}`)\n      .join('\\n');\n\n    const error: ValidationError<T> = {\n      error: true,\n      message: `Tool validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${JSON.stringify(bestAttempt.data, null, 2)}`,\n      validationErrors: bestAttempt.result.error.format() as z.ZodFormattedError<T>,\n    };\n\n    return { data: input, error };\n  }\n\n  // This should not happen since we handle all valid cases above\n  return { data: input };\n}\n","import type { Mastra } from '../mastra';\nimport type { ZodLikeSchema } from '../types/zod-compat';\nimport type { ToolAction, ToolExecutionContext, ToolInvocationOptions } from './types';\nimport { validateToolInput } from './validation';\n\n/**\n * A type-safe tool that agents and workflows can call to perform specific actions.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n *\n * @example Basic tool with validation\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'get-weather',\n *   description: 'Get weather for a location',\n *   inputSchema: z.object({\n *     location: z.string(),\n *     units: z.enum(['celsius', 'fahrenheit']).optional()\n *   }),\n *   execute: async ({ context }) => {\n *     return await fetchWeather(context.location, context.units);\n *   }\n * });\n * ```\n *\n * @example Tool requiring approval\n * ```typescript\n * const deleteFileTool = createTool({\n *   id: 'delete-file',\n *   description: 'Delete a file',\n *   requireApproval: true,\n *   inputSchema: z.object({ filepath: z.string() }),\n *   execute: async ({ context }) => {\n *     await fs.unlink(context.filepath);\n *     return { deleted: true };\n *   }\n * });\n * ```\n *\n * @example Tool with Mastra integration\n * ```typescript\n * const saveTool = createTool({\n *   id: 'save-data',\n *   description: 'Save data to storage',\n *   inputSchema: z.object({ key: z.string(), value: z.any() }),\n *   execute: async ({ context, mastra }) => {\n *     const storage = mastra?.getStorage();\n *     await storage?.set(context.key, context.value);\n *     return { saved: true };\n *   }\n * });\n * ```\n */\nexport class Tool<\n  TSchemaIn extends ZodLikeSchema | undefined = undefined,\n  TSchemaOut extends ZodLikeSchema | undefined = undefined,\n  TSuspendSchema extends ZodLikeSchema = any,\n  TResumeSchema extends ZodLikeSchema = any,\n  TContext extends ToolExecutionContext<TSchemaIn, TSuspendSchema, TResumeSchema> = ToolExecutionContext<\n    TSchemaIn,\n    TSuspendSchema,\n    TResumeSchema\n  >,\n> implements ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>\n{\n  /** Unique identifier for the tool */\n  id: string;\n\n  /** Description of what the tool does */\n  description: string;\n\n  /** Schema for validating input parameters */\n  inputSchema?: TSchemaIn;\n\n  /** Schema for validating output structure */\n  outputSchema?: TSchemaOut;\n\n  /** Schema for suspend operation data */\n  suspendSchema?: TSuspendSchema;\n\n  /** Schema for resume operation data */\n  resumeSchema?: TResumeSchema;\n\n  /**\n   * Function that performs the tool's action\n   * @param context - Execution context with validated input\n   * @param options - Invocation options including suspend/resume data\n   * @returns Promise resolving to tool output\n   */\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>['execute'];\n\n  /** Parent Mastra instance for accessing shared resources */\n  mastra?: Mastra;\n\n  /**\n   * Whether the tool requires explicit user approval before execution\n   * @example\n   * ```typescript\n   * // For destructive operations\n   * requireApproval: true\n   * ```\n   */\n  requireApproval?: boolean;\n\n  /**\n   * Creates a new Tool instance with input validation wrapper.\n   *\n   * @param opts - Tool configuration and execute function\n   * @example\n   * ```typescript\n   * const tool = new Tool({\n   *   id: 'my-tool',\n   *   description: 'Does something useful',\n   *   inputSchema: z.object({ name: z.string() }),\n   *   execute: async ({ context }) => ({ greeting: `Hello ${context.name}` })\n   * });\n   * ```\n   */\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.suspendSchema = opts.suspendSchema;\n    this.resumeSchema = opts.resumeSchema;\n    this.mastra = opts.mastra;\n    this.requireApproval = opts.requireApproval || false;\n\n    // Wrap the execute function with validation if it exists\n    if (opts.execute) {\n      const originalExecute = opts.execute;\n      this.execute = async (context: TContext, options?: ToolInvocationOptions) => {\n        const { resumeData, suspend } = (options ?? {}) as {\n          resumeData?: any;\n          suspend?: (suspendPayload: any) => Promise<any>;\n        };\n        // Validate input if schema exists\n        const { data, error } = validateToolInput(this.inputSchema, context, this.id);\n        if (error) {\n          return error as any;\n        }\n\n        return originalExecute({ ...(data as TContext), suspend, resumeData } as TContext, options);\n      };\n    }\n  }\n}\n\n/**\n * Creates a type-safe tool with automatic input validation.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n * @template TExecute - Execute function type\n *\n * @param opts - Tool configuration including schemas and execute function\n * @returns Type-safe Tool instance with conditional typing based on schemas\n *\n * @example Simple tool\n * ```typescript\n * const greetTool = createTool({\n *   id: 'greet',\n *   description: 'Say hello',\n *   execute: async () => ({ message: 'Hello!' })\n * });\n * ```\n *\n * @example Tool with input validation\n * ```typescript\n * const calculateTool = createTool({\n *   id: 'calculate',\n *   description: 'Perform calculations',\n *   inputSchema: z.object({\n *     operation: z.enum(['add', 'subtract']),\n *     a: z.number(),\n *     b: z.number()\n *   }),\n *   execute: async ({ context }) => {\n *     const result = context.operation === 'add'\n *       ? context.a + context.b\n *       : context.a - context.b;\n *     return { result };\n *   }\n * });\n * ```\n *\n * @example Tool with output schema\n * ```typescript\n * const userTool = createTool({\n *   id: 'get-user',\n *   description: 'Get user data',\n *   inputSchema: z.object({ userId: z.string() }),\n *   outputSchema: z.object({\n *     id: z.string(),\n *     name: z.string(),\n *     email: z.string()\n *   }),\n *   execute: async ({ context }) => {\n *     return await fetchUser(context.userId);\n *   }\n * });\n * ```\n *\n * @example Tool with external API\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'weather',\n *   description: 'Get weather data',\n *   inputSchema: z.object({\n *     city: z.string(),\n *     units: z.enum(['metric', 'imperial']).default('metric')\n *   }),\n *   execute: async ({ context }) => {\n *     const response = await fetch(\n *       `https://api.weather.com/v1/weather?q=${context.city}&units=${context.units}`\n *     );\n *     return response.json();\n *   }\n * });\n * ```\n */\nexport function createTool<\n  TSchemaIn extends ZodLikeSchema | undefined = undefined,\n  TSchemaOut extends ZodLikeSchema | undefined = undefined,\n  TSuspendSchema extends ZodLikeSchema = any,\n  TResumeSchema extends ZodLikeSchema = any,\n  TContext extends ToolExecutionContext<TSchemaIn, TSuspendSchema, TResumeSchema> = ToolExecutionContext<\n    TSchemaIn,\n    TSuspendSchema,\n    TResumeSchema\n  >,\n  TExecute extends ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext>['execute'] = ToolAction<\n    TSchemaIn,\n    TSchemaOut,\n    TSuspendSchema,\n    TResumeSchema,\n    TContext\n  >['execute'],\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext> & {\n    execute?: TExecute;\n  },\n): [TSchemaIn, TSchemaOut, TExecute] extends [ZodLikeSchema, ZodLikeSchema, Function]\n  ? Tool<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext> & {\n      inputSchema: TSchemaIn;\n      outputSchema: TSchemaOut;\n      execute: (context: TContext, options: ToolInvocationOptions) => Promise<any>;\n    }\n  : Tool<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext> {\n  return new Tool(opts) as any;\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Tool\n  return !!(tool && !(tool instanceof Tool) && 'parameters' in tool);\n}\n"]}