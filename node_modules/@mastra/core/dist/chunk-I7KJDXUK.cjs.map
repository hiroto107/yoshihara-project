{"version":3,"sources":["../src/voice/voice.ts","../src/voice/composite-voice.ts","../src/voice/default-voice.ts"],"names":["MastraVoice","__decoratorStart","__decorateElement","__runInitializers","MastraError"],"mappings":"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","file":"chunk-I7KJDXUK.cjs","sourcesContent":["import type { ToolsInput } from '../agent';\nimport { MastraBase } from '../base';\nimport { InstrumentClass } from '../telemetry';\n\nexport type VoiceEventType = 'speaking' | 'writing' | 'error' | string;\n\nexport interface VoiceEventMap {\n  speaker: NodeJS.ReadableStream;\n  speaking: { audio?: string };\n  writing: { text: string; role: 'assistant' | 'user' };\n  error: { message: string; code?: string; details?: unknown };\n  [key: string]: unknown;\n}\n\ninterface BuiltInModelConfig {\n  name: string;\n  apiKey?: string;\n}\n\nexport interface VoiceConfig<T = unknown> {\n  listeningModel?: BuiltInModelConfig;\n  speechModel?: BuiltInModelConfig;\n  speaker?: string;\n  name?: string;\n  realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: T;\n  };\n}\n\n@InstrumentClass({\n  prefix: 'voice',\n  excludeMethods: ['__setTools', '__setLogger', '__setTelemetry', '#log'],\n})\nexport abstract class MastraVoice<\n  TOptions = unknown,\n  TSpeakOptions = unknown,\n  TListenOptions = unknown,\n  TTools extends ToolsInput = ToolsInput,\n  TEventArgs extends VoiceEventMap = VoiceEventMap,\n  TSpeakerMetadata = unknown,\n> extends MastraBase {\n  protected listeningModel?: BuiltInModelConfig;\n  protected speechModel?: BuiltInModelConfig;\n  protected speaker?: string;\n  protected realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: TOptions;\n  };\n\n  constructor({ listeningModel, speechModel, speaker, realtimeConfig, name }: VoiceConfig<TOptions> = {}) {\n    super({\n      component: 'VOICE',\n      name,\n    });\n    this.listeningModel = listeningModel;\n    this.speechModel = speechModel;\n    this.speaker = speaker;\n    this.realtimeConfig = realtimeConfig;\n  }\n\n  traced<T extends Function>(method: T, methodName: string): T {\n    return (\n      this.telemetry?.traceMethod(method, {\n        spanName: `voice.${methodName}`,\n        attributes: {\n          'voice.type': this.speechModel?.name || this.listeningModel?.name || 'unknown',\n        },\n      }) ?? method\n    );\n  }\n\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream\n   */\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in chat mode\n   */\n  abstract speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      speaker?: string;\n    } & TSpeakOptions,\n  ): Promise<NodeJS.ReadableStream | void>;\n\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text or text stream\n   */\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text, text stream, or void if in chat mode\n   */\n  abstract listen(\n    audioStream: NodeJS.ReadableStream | unknown, // Allow other audio input types for OpenAI realtime API\n    options?: TListenOptions,\n  ): Promise<string | NodeJS.ReadableStream | void>;\n\n  updateConfig(_options: Record<string, unknown>): void {\n    this.logger.warn('updateConfig not implemented by this voice provider');\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(_options?: Record<string, unknown>): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('connect not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to relay\n   */\n  send(_audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('relay not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(_options?: Record<string, unknown>): Promise<void> {\n    this.logger.warn('answer not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(_instructions?: string): void {\n    // Default implementation - voice providers can override if they support this feature\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(_tools: TTools): void {\n    // Default implementation - voice providers can override if they support this feature\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('close not implemented by this voice provider');\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('on not implemented by this voice provider');\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('off not implemented by this voice provider');\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getSpeakers(): Promise<\n    Array<\n      {\n        voiceId: string;\n      } & TSpeakerMetadata\n    >\n  > {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getSpeakers not implemented by this voice provider');\n    return Promise.resolve([]);\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getListener(): Promise<{ enabled: boolean }> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getListener not implemented by this voice provider');\n    return Promise.resolve({ enabled: false });\n  }\n}\n","import type { ToolsInput } from '../agent';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport { MastraVoice } from './voice';\nimport type { VoiceEventType, VoiceEventMap } from '.';\n\nexport class CompositeVoice extends MastraVoice<unknown, unknown, unknown, ToolsInput, VoiceEventMap> {\n  protected speakProvider?: MastraVoice;\n  protected listenProvider?: MastraVoice;\n  protected realtimeProvider?: MastraVoice;\n\n  constructor({\n    input,\n    output,\n    realtime,\n    speakProvider,\n    listenProvider,\n    realtimeProvider,\n  }: {\n    /** @deprecated use output instead */\n    speakProvider?: MastraVoice;\n    /** @deprecated use input instead */\n    listenProvider?: MastraVoice;\n    /** @deprecated use realtime instead */\n    realtimeProvider?: MastraVoice;\n\n    input?: MastraVoice;\n    output?: MastraVoice;\n    realtime?: MastraVoice;\n  }) {\n    super();\n    this.speakProvider = output || speakProvider;\n    this.listenProvider = input || listenProvider;\n    this.realtimeProvider = realtime || realtimeProvider;\n  }\n\n  /**\n   * Convert text to speech using the configured provider\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in realtime mode\n   */\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: { speaker?: string } & any,\n  ): Promise<NodeJS.ReadableStream | void> {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.speak(input, options);\n    } else if (this.speakProvider) {\n      return this.speakProvider.speak(input, options);\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_SPEAK_PROVIDER',\n      text: 'No speak provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async listen(audioStream: NodeJS.ReadableStream, options?: any) {\n    if (this.realtimeProvider) {\n      return await this.realtimeProvider.listen(audioStream, options);\n    } else if (this.listenProvider) {\n      return await this.listenProvider.listen(audioStream, options);\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_LISTEN_PROVIDER',\n      text: 'No listen provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getSpeakers() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getSpeakers();\n    } else if (this.speakProvider) {\n      return this.speakProvider.getSpeakers();\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_SPEAKERS_PROVIDER',\n      text: 'No speak provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getListener() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getListener();\n    } else if (this.listenProvider) {\n      return this.listenProvider.getListener();\n    }\n\n    throw new MastraError({\n      id: 'VOICE_COMPOSITE_NO_LISTENER_PROVIDER',\n      text: 'No listener provider or realtime provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  updateConfig(options: Record<string, unknown>): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.updateConfig(options);\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CONNECT',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.connect(options);\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to send\n   */\n  send(audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_SEND',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.send(audioData);\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ANSWER',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    return this.realtimeProvider.answer(options);\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(instructions: string): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addInstructions(instructions);\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(tools: ToolsInput): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addTools(tools);\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_CLOSE',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.close();\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_ON',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.on(event, callback);\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new MastraError({\n        id: 'VOICE_COMPOSITE_NO_REALTIME_PROVIDER_OFF',\n        text: 'No realtime provider configured',\n        domain: ErrorDomain.MASTRA_VOICE,\n        category: ErrorCategory.USER,\n      });\n    }\n    this.realtimeProvider.off(event, callback);\n  }\n}\n","import { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport { MastraVoice } from '.';\n\nexport class DefaultVoice extends MastraVoice {\n  constructor() {\n    super();\n  }\n\n  async speak(_input: string | NodeJS.ReadableStream): Promise<NodeJS.ReadableStream> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_SPEAK_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async listen(_input: string | NodeJS.ReadableStream): Promise<string> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_LISTEN_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getSpeakers(): Promise<{ voiceId: string }[]> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_SPEAKERS_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n\n  async getListener(): Promise<{ enabled: boolean }> {\n    throw new MastraError({\n      id: 'VOICE_DEFAULT_NO_LISTENER_PROVIDER',\n      text: 'No voice provider configured',\n      domain: ErrorDomain.MASTRA_VOICE,\n      category: ErrorCategory.USER,\n    });\n  }\n}\n"]}