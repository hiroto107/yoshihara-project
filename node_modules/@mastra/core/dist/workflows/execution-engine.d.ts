import type { Mastra, SerializedStepFlowEntry } from '..';
import type { AISpan, AISpanType, TracingPolicy } from '../ai-tracing/index.js';
import { MastraBase } from '../base.js';
import type { RuntimeContext } from '../di/index.js';
import type { ChunkType } from '../stream/types.js';
import type { Emitter, StepResult, WorkflowRunStatus } from './types.js';
import type { StepFlowEntry } from '.';
/**
 * Represents an execution graph for a workflow
 */
export interface ExecutionGraph<TEngineType = any> {
    id: string;
    steps: StepFlowEntry<TEngineType>[];
}
export interface ExecutionEngineOptions {
    tracingPolicy?: TracingPolicy;
    validateInputs: boolean;
    shouldPersistSnapshot: (params: {
        stepResults: Record<string, StepResult<any, any, any, any>>;
        workflowStatus: WorkflowRunStatus;
    }) => boolean;
}
/**
 * Execution engine abstract class for building and executing workflow graphs
 * Providers will implement this class to provide their own execution logic
 */
export declare abstract class ExecutionEngine extends MastraBase {
    protected mastra?: Mastra;
    options: ExecutionEngineOptions;
    constructor({ mastra, options }: {
        mastra?: Mastra;
        options: ExecutionEngineOptions;
    });
    __registerMastra(mastra: Mastra): void;
    /**
     * Executes a workflow run with the provided execution graph and input
     * @param graph The execution graph to execute
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    abstract execute<TState, TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        disableScorers?: boolean;
        graph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        input?: TInput;
        initialState?: TState;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        emitter: Emitter;
        runtimeContext: RuntimeContext;
        workflowAISpan?: AISpan<AISpanType.WORKFLOW_RUN>;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        abortController: AbortController;
        writableStream?: WritableStream<ChunkType>;
        format?: 'legacy' | 'vnext' | undefined;
        outputOptions?: {
            includeState?: boolean;
        };
    }): Promise<TOutput>;
}
//# sourceMappingURL=execution-engine.d.ts.map