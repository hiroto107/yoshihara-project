{"version":3,"sources":["../../src/storage/domains/legacy-evals/base.ts","../../src/storage/domains/legacy-evals/inmemory.ts","../../src/storage/domains/memory/base.ts","../../src/storage/domains/memory/inmemory.ts","../../src/storage/domains/observability/base.ts","../../src/storage/domains/observability/inmemory.ts","../../src/storage/domains/operations/base.ts","../../src/storage/domains/operations/inmemory.ts","../../src/storage/domains/scores/base.ts","../../src/storage/domains/scores/inmemory.ts","../../src/storage/domains/traces/base.ts","../../src/storage/domains/traces/inmemory.ts","../../src/storage/domains/workflows/base.ts","../../src/storage/domains/workflows/inmemory.ts","../../src/storage/mock.ts","../../src/storage/utils.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { MastraBase } from '../../../base';\nimport type { EvalRow, PaginationArgs, PaginationInfo } from '../../types';\n\nexport abstract class LegacyEvalsStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'LEGACY_EVALS',\n    });\n  }\n\n  abstract getEvals(\n    options: {\n      agentName?: string;\n      type?: 'test' | 'live';\n    } & PaginationArgs,\n  ): Promise<PaginationInfo & { evals: EvalRow[] }>;\n\n  abstract getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]>;\n}\n","import type { MetricResult, TestInfo } from '../../../eval';\nimport type { EvalRow, PaginationArgs, PaginationInfo, StorageEvalRow } from '../../types';\nimport { LegacyEvalsStorage } from './base';\n\nexport type InMemoryEvals = Map<string, StorageEvalRow>;\n\nexport class InMemoryLegacyEvals extends LegacyEvalsStorage {\n  private collection: InMemoryEvals;\n  constructor({ collection }: { collection: InMemoryEvals }) {\n    super();\n    this.collection = collection;\n  }\n\n  async getEvals(\n    options: { agentName?: string; type?: 'test' | 'live' } & PaginationArgs,\n  ): Promise<PaginationInfo & { evals: EvalRow[] }> {\n    this.logger.debug(`MockStore: getEvals called`, options);\n\n    let evals = Array.from(this.collection.values());\n\n    // Filter by agentName if provided\n    if (options.agentName) {\n      evals = evals.filter(evalR => evalR.agent_name === options.agentName);\n    }\n\n    // Filter by type if provided\n    if (options.type === 'test') {\n      evals = evals.filter(evalR => evalR.test_info && evalR.test_info.testPath);\n    } else if (options.type === 'live') {\n      evals = evals.filter(evalR => !evalR.test_info || !evalR.test_info.testPath);\n    }\n\n    // Filter by date range if provided\n    if (options.dateRange?.start) {\n      evals = evals.filter(evalR => new Date(evalR.created_at) >= options.dateRange!.start!);\n    }\n    if (options.dateRange?.end) {\n      evals = evals.filter(evalR => new Date(evalR.created_at) <= options.dateRange!.end!);\n    }\n\n    // Sort by createdAt (newest first)\n    evals.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\n\n    const total = evals.length;\n    const page = options.page || 0;\n    const perPage = options.perPage || 100;\n    const start = page * perPage;\n    const end = start + perPage;\n\n    return {\n      evals: evals.slice(start, end).map(e => ({\n        agentName: e.agent_name,\n        input: e.input,\n        output: e.output,\n        instructions: e.instructions,\n        result: e.result as MetricResult,\n        createdAt: e.created_at.toISOString(),\n        testInfo: e.test_info as TestInfo,\n        metricName: e.metric_name,\n        runId: e.run_id,\n        globalRunId: e.global_run_id,\n      })),\n      total,\n      page,\n      perPage,\n      hasMore: total > end,\n    };\n  }\n\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    this.logger.debug(`MockStore: getEvalsByAgentName called for ${agentName}`);\n    // Mock implementation - filter evals by agentName and type\n    let evals = Array.from(this.collection.values()).filter((e: StorageEvalRow) => e.agent_name === agentName);\n\n    if (type === 'test') {\n      evals = evals.filter((e: any) => e.test_info && e.test_info.testPath);\n    } else if (type === 'live') {\n      evals = evals.filter((e: any) => !e.test_info || !e.test_info.testPath);\n    }\n\n    return evals\n      .sort(\n        (a: StorageEvalRow, b: StorageEvalRow) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime(),\n      )\n      .map(e => ({\n        agentName: e.agent_name,\n        input: e.input,\n        output: e.output,\n        instructions: e.instructions,\n        result: e.result as MetricResult,\n        createdAt: e.created_at.toISOString(),\n        metricName: e.metric_name,\n        runId: e.run_id,\n        testInfo: e.test_info as TestInfo,\n        globalRunId: e.global_run_id,\n      }));\n  }\n}\n","import type { MastraMessageContentV2 } from '../../../agent';\nimport { MastraBase } from '../../../base';\nimport type { MastraMessageV1, MastraMessageV2, StorageThreadType } from '../../../memory/types';\nimport type {\n  StorageGetMessagesArg,\n  PaginationInfo,\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  ThreadSortOptions,\n} from '../../types';\n\nexport abstract class MemoryStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'MEMORY',\n    });\n  }\n\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract getThreadsByResourceId({\n    resourceId,\n  }: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]>;\n\n  abstract saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType>;\n\n  abstract updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType>;\n\n  abstract deleteThread({ threadId }: { threadId: string }): Promise<void>;\n\n  abstract getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  abstract getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  abstract getMessages({\n    threadId,\n    resourceId,\n    selectBy,\n    format,\n  }: StorageGetMessagesArg & { format?: 'v1' | 'v2' }): Promise<MastraMessageV1[] | MastraMessageV2[]>;\n  abstract getMessagesById({ messageIds }: { messageIds: string[]; format: 'v1' }): Promise<MastraMessageV1[]>;\n  abstract getMessagesById({ messageIds }: { messageIds: string[]; format?: 'v2' }): Promise<MastraMessageV2[]>;\n  abstract getMessagesById({\n    messageIds,\n  }: {\n    messageIds: string[];\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]>;\n\n  abstract saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  abstract saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  abstract saveMessages(\n    args: { messages: MastraMessageV1[]; format?: undefined | 'v1' } | { messages: MastraMessageV2[]; format: 'v2' },\n  ): Promise<MastraMessageV2[] | MastraMessageV1[]>;\n\n  abstract updateMessages(args: {\n    messages: Partial<Omit<MastraMessageV2, 'createdAt'>> &\n      {\n        id: string;\n        content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n      }[];\n  }): Promise<MastraMessageV2[]>;\n\n  async deleteMessages(_messageIds: string[]): Promise<void> {\n    throw new Error(\n      `Message deletion is not supported by this storage adapter (${this.constructor.name}). ` +\n        `The deleteMessages method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  abstract getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }>;\n\n  abstract getMessagesPaginated(\n    args: StorageGetMessagesArg & { format?: 'v1' | 'v2' },\n  ): Promise<PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }>;\n\n  async getResourceById(_: { resourceId: string }): Promise<StorageResourceType | null> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  async saveResource(_: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  async updateResource(_: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not supported by this storage adapter (${this.constructor.name}). ` +\n        `Supported storage adapters: LibSQL (@mastra/libsql), PostgreSQL (@mastra/pg), Upstash (@mastra/upstash). ` +\n        `To use per-resource working memory, switch to one of these supported storage adapters.`,\n    );\n  }\n\n  protected castThreadOrderBy(v: unknown): ThreadOrderBy {\n    return (v as string) in THREAD_ORDER_BY_SET ? (v as ThreadOrderBy) : 'createdAt';\n  }\n\n  protected castThreadSortDirection(v: unknown): ThreadSortDirection {\n    return (v as string) in THREAD_THREAD_SORT_DIRECTION_SET ? (v as ThreadSortDirection) : 'DESC';\n  }\n}\n\nconst THREAD_ORDER_BY_SET: Record<ThreadOrderBy, true> = {\n  createdAt: true,\n  updatedAt: true,\n};\n\nconst THREAD_THREAD_SORT_DIRECTION_SET: Record<ThreadSortDirection, true> = {\n  ASC: true,\n  DESC: true,\n};\n","import { MessageList } from '../../../agent/message-list';\nimport type { MastraMessageV1, MastraMessageV2, StorageThreadType } from '../../../memory/types';\nimport type {\n  PaginationInfo,\n  StorageGetMessagesArg,\n  StorageMessageType,\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  ThreadSortOptions,\n} from '../../types';\nimport type { StoreOperations } from '../operations';\nimport { MemoryStorage } from './base';\n\nexport type InMemoryThreads = Map<string, StorageThreadType>;\nexport type InMemoryResources = Map<string, StorageResourceType>;\nexport type InMemoryMessages = Map<string, StorageMessageType>;\n\nexport class InMemoryMemory extends MemoryStorage {\n  private collection: {\n    threads: InMemoryThreads;\n    resources: InMemoryResources;\n    messages: InMemoryMessages;\n  };\n  private operations: StoreOperations;\n  constructor({\n    collection,\n    operations,\n  }: {\n    collection: {\n      threads: InMemoryThreads;\n      resources: InMemoryResources;\n      messages: InMemoryMessages;\n    };\n    operations: StoreOperations;\n  }) {\n    super();\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    this.logger.debug(`MockStore: getThreadById called for ${threadId}`);\n    const thread = this.collection.threads.get(threadId);\n    return thread ? { ...thread, metadata: thread.metadata ? { ...thread.metadata } : thread.metadata } : null;\n  }\n\n  async getThreadsByResourceId({\n    resourceId,\n    orderBy,\n    sortDirection,\n  }: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    this.logger.debug(`MockStore: getThreadsByResourceId called for ${resourceId}`);\n    // Mock implementation - find threads by resourceId\n    const threads = Array.from(this.collection.threads.values()).filter((t: any) => t.resourceId === resourceId);\n    const sortedThreads = this.sortThreads(\n      threads,\n      this.castThreadOrderBy(orderBy),\n      this.castThreadSortDirection(sortDirection),\n    );\n    return sortedThreads.map(thread => ({\n      ...thread,\n      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata,\n    })) as StorageThreadType[];\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    this.logger.debug(`MockStore: saveThread called for ${thread.id}`);\n    const key = thread.id;\n    this.collection.threads.set(key, thread);\n    return thread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    this.logger.debug(`MockStore: updateThread called for ${id}`);\n    const thread = this.collection.threads.get(id);\n\n    if (!thread) {\n      throw new Error(`Thread with id ${id} not found`);\n    }\n\n    if (thread) {\n      thread.title = title;\n      thread.metadata = { ...thread.metadata, ...metadata };\n      thread.updatedAt = new Date();\n    }\n    return thread;\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    this.logger.debug(`MockStore: deleteThread called for ${threadId}`);\n    this.collection.threads.delete(threadId);\n\n    this.collection.messages.forEach((msg, key) => {\n      if (msg.thread_id === threadId) {\n        this.collection.messages.delete(key);\n      }\n    });\n  }\n\n  async getMessages<T extends MastraMessageV2[]>({ threadId, selectBy }: StorageGetMessagesArg): Promise<T> {\n    this.logger.debug(`MockStore: getMessages called for thread ${threadId}`);\n\n    if (!threadId.trim()) throw new Error('threadId must be a non-empty string');\n\n    // Handle include messages first\n    const messages: MastraMessageV2[] = [];\n\n    if (selectBy?.include && selectBy.include.length > 0) {\n      for (const includeItem of selectBy.include) {\n        const targetMessage = this.collection.messages.get(includeItem.id);\n        if (targetMessage) {\n          // Convert StorageMessageType to MastraMessageV2\n          const convertedMessage = {\n            id: targetMessage.id,\n            threadId: targetMessage.thread_id,\n            content:\n              typeof targetMessage.content === 'string' ? JSON.parse(targetMessage.content) : targetMessage.content,\n            role: targetMessage.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: targetMessage.type,\n            createdAt: targetMessage.createdAt,\n            resourceId: targetMessage.resourceId,\n          } as MastraMessageV2;\n\n          messages.push(convertedMessage);\n\n          // Add previous messages if requested\n          if (includeItem.withPreviousMessages) {\n            const allThreadMessages = Array.from(this.collection.messages.values())\n              .filter((msg: any) => msg.thread_id === includeItem.threadId)\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));\n              for (let i = startIndex; i < targetIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messages.some(m => m.id === message.id)) {\n                  const convertedPrevMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: typeof message.content === 'string' ? JSON.parse(message.content) : message.content,\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraMessageV2;\n                  messages.push(convertedPrevMessage);\n                }\n              }\n            }\n          }\n\n          // Add next messages if requested\n          if (includeItem.withNextMessages) {\n            const allThreadMessages = Array.from(this.collection.messages.values())\n              .filter((msg: any) => msg.thread_id === includeItem.threadId)\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const endIndex = Math.min(\n                allThreadMessages.length,\n                targetIndex + (includeItem.withNextMessages || 0) + 1,\n              );\n              for (let i = targetIndex + 1; i < endIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messages.some(m => m.id === message.id)) {\n                  const convertedNextMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: typeof message.content === 'string' ? JSON.parse(message.content) : message.content,\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraMessageV2;\n                  messages.push(convertedNextMessage);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Get regular messages from the thread only if no include items or if last is specified\n    if (!selectBy?.include || selectBy.include.length === 0 || selectBy?.last) {\n      let threadMessages = Array.from(this.collection.messages.values())\n        .filter((msg: any) => msg.thread_id === threadId)\n        .filter((msg: any) => !messages.some(m => m.id === msg.id)); // Exclude already included messages\n\n      // Apply selectBy logic\n      if (selectBy?.last) {\n        threadMessages.sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n        const lastMessages = threadMessages.slice(-selectBy.last);\n        // Convert and add last messages\n        for (const msg of lastMessages) {\n          const convertedMessage = {\n            id: msg.id,\n            threadId: msg.thread_id,\n            content: typeof msg.content === 'string' ? JSON.parse(msg.content) : msg.content,\n            role: msg.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: msg.type,\n            createdAt: msg.createdAt,\n            resourceId: msg.resourceId,\n          } as MastraMessageV2;\n          messages.push(convertedMessage);\n        }\n      } else if (!selectBy?.include || selectBy.include.length === 0) {\n        // Convert and add all thread messages only if no include items\n        for (const msg of threadMessages) {\n          const convertedMessage = this.parseStoredMessage(msg);\n          messages.push(convertedMessage);\n        }\n      }\n    }\n\n    // Sort by createdAt\n    messages.sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n    return messages as T;\n  }\n\n  protected parseStoredMessage(message: StorageMessageType): MastraMessageV2 {\n    const { resourceId, content, role, thread_id, ...rest } = message;\n    return {\n      ...rest,\n      threadId: thread_id,\n      ...(message.resourceId && { resourceId: message.resourceId }),\n      content: typeof content === 'string' ? content : JSON.parse(content),\n      role: role as MastraMessageV2['role'],\n    } satisfies MastraMessageV2;\n  }\n\n  async getMessagesById({ messageIds, format }: { messageIds: string[]; format: 'v1' }): Promise<MastraMessageV1[]>;\n  async getMessagesById({ messageIds, format }: { messageIds: string[]; format?: 'v2' }): Promise<MastraMessageV2[]>;\n  async getMessagesById({\n    messageIds,\n    format,\n  }: {\n    messageIds: string[];\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    this.logger.debug(`MockStore: getMessagesById called`);\n\n    const rawMessages = messageIds.map(id => this.collection.messages.get(id)).filter(message => !!message);\n\n    const list = new MessageList().add(rawMessages.map(this.parseStoredMessage), 'memory');\n    if (format === 'v1') return list.get.all.v1();\n    return list.get.all.v2();\n  }\n\n  async saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  async saveMessages(\n    args: { messages: MastraMessageV1[]; format?: undefined | 'v1' } | { messages: MastraMessageV2[]; format: 'v2' },\n  ): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    const { messages, format = 'v1' } = args;\n    this.logger.debug(`MockStore: saveMessages called with ${messages.length} messages`);\n    // Simulate error handling for testing - check before saving\n    if (messages.some(msg => msg.id === 'error-message' || msg.resourceId === null)) {\n      throw new Error('Simulated error for testing');\n    }\n\n    // Update thread timestamps for each unique threadId\n    const threadIds = new Set(messages.map(msg => msg.threadId).filter((id): id is string => Boolean(id)));\n    for (const threadId of threadIds) {\n      const thread = this.collection.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = new Date();\n      }\n    }\n\n    for (const message of messages) {\n      const key = message.id;\n      // Convert MastraMessageV2 to StorageMessageType\n      const storageMessage: StorageMessageType = {\n        id: message.id,\n        thread_id: message.threadId || '',\n        content: typeof message.content === 'string' ? message.content : JSON.stringify(message.content),\n        role: message.role || 'user',\n        type: message.type || 'text',\n        createdAt: message.createdAt,\n        resourceId: message.resourceId || null,\n      };\n      this.collection.messages.set(key, storageMessage);\n    }\n\n    const list = new MessageList().add(messages, 'memory');\n    if (format === `v2`) return list.get.all.v2();\n    return list.get.all.v1();\n  }\n\n  async updateMessages(args: { messages: (Partial<MastraMessageV2> & { id: string })[] }): Promise<MastraMessageV2[]> {\n    const updatedMessages: MastraMessageV2[] = [];\n    for (const update of args.messages) {\n      const storageMsg = this.collection.messages.get(update.id);\n      if (!storageMsg) continue;\n\n      // Track old threadId for possible move\n      const oldThreadId = storageMsg.thread_id;\n      const newThreadId = update.threadId || oldThreadId;\n      let threadIdChanged = false;\n      if (update.threadId && update.threadId !== oldThreadId) {\n        threadIdChanged = true;\n      }\n\n      // Update fields\n      if (update.role !== undefined) storageMsg.role = update.role;\n      if (update.type !== undefined) storageMsg.type = update.type;\n      if (update.createdAt !== undefined) storageMsg.createdAt = update.createdAt;\n      if (update.resourceId !== undefined) storageMsg.resourceId = update.resourceId;\n      // Deep merge content if present\n      if (update.content !== undefined) {\n        let oldContent = typeof storageMsg.content === 'string' ? JSON.parse(storageMsg.content) : storageMsg.content;\n        let newContent = update.content;\n        if (typeof newContent === 'object' && typeof oldContent === 'object') {\n          // Deep merge for metadata/content fields\n          newContent = { ...oldContent, ...newContent };\n          if (oldContent.metadata && newContent.metadata) {\n            newContent.metadata = { ...oldContent.metadata, ...newContent.metadata };\n          }\n        }\n        storageMsg.content = JSON.stringify(newContent);\n      }\n      // Handle threadId change\n      if (threadIdChanged) {\n        storageMsg.thread_id = newThreadId;\n        // Update updatedAt for both threads, ensuring strictly greater and not equal\n        const base = Date.now();\n        let oldThreadNewTime: number | undefined;\n        const oldThread = this.collection.threads.get(oldThreadId);\n        if (oldThread) {\n          const prev = new Date(oldThread.updatedAt).getTime();\n          oldThreadNewTime = Math.max(base, prev + 1);\n          oldThread.updatedAt = new Date(oldThreadNewTime);\n        }\n        const newThread = this.collection.threads.get(newThreadId);\n        if (newThread) {\n          const prev = new Date(newThread.updatedAt).getTime();\n          let newThreadNewTime = Math.max(base + 1, prev + 1);\n          if (oldThreadNewTime !== undefined && newThreadNewTime <= oldThreadNewTime) {\n            newThreadNewTime = oldThreadNewTime + 1;\n          }\n          newThread.updatedAt = new Date(newThreadNewTime);\n        }\n      } else {\n        // Only update the thread's updatedAt if not a move\n        const thread = this.collection.threads.get(oldThreadId);\n        if (thread) {\n          const prev = new Date(thread.updatedAt).getTime();\n          let newTime = Date.now();\n          if (newTime <= prev) newTime = prev + 1;\n          thread.updatedAt = new Date(newTime);\n        }\n      }\n      // Save the updated message\n      this.collection.messages.set(update.id, storageMsg);\n      // Return as MastraMessageV2\n      updatedMessages.push({\n        id: storageMsg.id,\n        threadId: storageMsg.thread_id,\n        content: typeof storageMsg.content === 'string' ? JSON.parse(storageMsg.content) : storageMsg.content,\n        role: storageMsg.role === 'user' || storageMsg.role === 'assistant' ? storageMsg.role : 'user',\n        type: storageMsg.type,\n        createdAt: storageMsg.createdAt,\n        resourceId: storageMsg.resourceId === null ? undefined : storageMsg.resourceId,\n      });\n    }\n    return updatedMessages;\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    this.logger.debug(`MockStore: deleteMessages called for ${messageIds.length} messages`);\n\n    // Collect thread IDs to update\n    const threadIds = new Set<string>();\n\n    for (const messageId of messageIds) {\n      const message = this.collection.messages.get(messageId);\n      if (message && message.thread_id) {\n        threadIds.add(message.thread_id);\n      }\n      // Delete the message\n      this.collection.messages.delete(messageId);\n    }\n\n    // Update thread timestamps\n    const now = new Date();\n    for (const threadId of threadIds) {\n      const thread = this.collection.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = now;\n      }\n    }\n  }\n\n  async getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }> {\n    const { resourceId, page, perPage, orderBy, sortDirection } = args;\n    this.logger.debug(`MockStore: getThreadsByResourceIdPaginated called for ${resourceId}`);\n    // Mock implementation - find threads by resourceId\n    const threads = Array.from(this.collection.threads.values()).filter((t: any) => t.resourceId === resourceId);\n    const sortedThreads = this.sortThreads(\n      threads,\n      this.castThreadOrderBy(orderBy),\n      this.castThreadSortDirection(sortDirection),\n    );\n    const clonedThreads = sortedThreads.map(thread => ({\n      ...thread,\n      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata,\n    })) as StorageThreadType[];\n    return {\n      threads: clonedThreads.slice(page * perPage, (page + 1) * perPage),\n      total: clonedThreads.length,\n      page: page,\n      perPage: perPage,\n      hasMore: clonedThreads.length > (page + 1) * perPage,\n    };\n  }\n\n  async getMessagesPaginated({\n    threadId,\n    selectBy,\n  }: StorageGetMessagesArg & { format?: 'v1' | 'v2' }): Promise<\n    PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }\n  > {\n    this.logger.debug(`MockStore: getMessagesPaginated called for thread ${threadId}`);\n\n    if (!threadId.trim()) throw new Error('threadId must be a non-empty string');\n\n    const { page = 0, perPage = 40 } = selectBy?.pagination || {};\n\n    // Handle include messages first\n    const messages: MastraMessageV2[] = [];\n\n    if (selectBy?.include && selectBy.include.length > 0) {\n      for (const includeItem of selectBy.include) {\n        const targetMessage = this.collection.messages.get(includeItem.id);\n        if (targetMessage) {\n          // Convert StorageMessageType to MastraMessageV2\n          const convertedMessage = {\n            id: targetMessage.id,\n            threadId: targetMessage.thread_id,\n            content:\n              typeof targetMessage.content === 'string' ? JSON.parse(targetMessage.content) : targetMessage.content,\n            role: targetMessage.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: targetMessage.type,\n            createdAt: targetMessage.createdAt,\n            resourceId: targetMessage.resourceId,\n          } as MastraMessageV2;\n\n          messages.push(convertedMessage);\n\n          // Add previous messages if requested\n          if (includeItem.withPreviousMessages) {\n            const allThreadMessages = Array.from(this.collection.messages.values())\n              .filter((msg: any) => msg.thread_id === includeItem.threadId)\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));\n              for (let i = startIndex; i < targetIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messages.some(m => m.id === message.id)) {\n                  const convertedPrevMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: typeof message.content === 'string' ? JSON.parse(message.content) : message.content,\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraMessageV2;\n                  messages.push(convertedPrevMessage);\n                }\n              }\n            }\n          }\n\n          // Add next messages if requested\n          if (includeItem.withNextMessages) {\n            const allThreadMessages = Array.from(this.collection.messages.values())\n              .filter((msg: any) => msg.thread_id === includeItem.threadId)\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const endIndex = Math.min(\n                allThreadMessages.length,\n                targetIndex + (includeItem.withNextMessages || 0) + 1,\n              );\n              for (let i = targetIndex + 1; i < endIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messages.some(m => m.id === message.id)) {\n                  const convertedNextMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: typeof message.content === 'string' ? JSON.parse(message.content) : message.content,\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraMessageV2;\n                  messages.push(convertedNextMessage);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Get regular messages from the thread only if no include items or if last is specified\n    if (!selectBy?.include || selectBy.include.length === 0 || selectBy?.last) {\n      let threadMessages = Array.from(this.collection.messages.values())\n        .filter((msg: any) => msg.thread_id === threadId)\n        .filter((msg: any) => !messages.some(m => m.id === msg.id)); // Exclude already included messages\n\n      // Apply date filtering\n      if (selectBy?.pagination?.dateRange) {\n        const { start: from, end: to } = selectBy.pagination.dateRange;\n        threadMessages = threadMessages.filter((msg: any) => {\n          const msgDate = new Date(msg.createdAt);\n          const fromDate = from ? new Date(from) : null;\n          const toDate = to ? new Date(to) : null;\n\n          if (fromDate && msgDate < fromDate) return false;\n          if (toDate && msgDate > toDate) return false;\n          return true;\n        });\n      }\n\n      // Apply selectBy logic\n      if (selectBy?.last) {\n        threadMessages.sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n        const lastMessages = threadMessages.slice(-selectBy.last);\n        // Convert and add last messages\n        for (const msg of lastMessages) {\n          const convertedMessage = {\n            id: msg.id,\n            threadId: msg.thread_id,\n            content: typeof msg.content === 'string' ? JSON.parse(msg.content) : msg.content,\n            role: msg.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: msg.type,\n            createdAt: msg.createdAt,\n            resourceId: msg.resourceId,\n          } as MastraMessageV2;\n          messages.push(convertedMessage);\n        }\n      } else if (!selectBy?.include || selectBy.include.length === 0) {\n        // Convert and add all thread messages only if no include items\n        for (const msg of threadMessages) {\n          const convertedMessage = {\n            id: msg.id,\n            threadId: msg.thread_id,\n            content: typeof msg.content === 'string' ? JSON.parse(msg.content) : msg.content,\n            role: msg.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: msg.type,\n            createdAt: msg.createdAt,\n            resourceId: msg.resourceId,\n          } as MastraMessageV2;\n          messages.push(convertedMessage);\n        }\n      }\n    }\n\n    // Sort by createdAt\n    messages.sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n    const start = page * perPage;\n    const end = start + perPage;\n    return {\n      messages: messages.slice(start, end),\n      total: messages.length,\n      page,\n      perPage,\n      hasMore: messages.length > end,\n    };\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    this.logger.debug(`MockStore: getResourceById called for ${resourceId}`);\n    const resource = this.collection.resources.get(resourceId);\n    return resource\n      ? { ...resource, metadata: resource.metadata ? { ...resource.metadata } : resource.metadata }\n      : null;\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    this.logger.debug(`MockStore: saveResource called for ${resource.id}`);\n    this.collection.resources.set(resource.id, resource);\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    this.logger.debug(`MockStore: updateResource called for ${resourceId}`);\n    let resource = this.collection.resources.get(resourceId);\n\n    if (!resource) {\n      // Create new resource if it doesn't exist\n      resource = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n    } else {\n      resource = {\n        ...resource,\n        workingMemory: workingMemory !== undefined ? workingMemory : resource.workingMemory,\n        metadata: {\n          ...resource.metadata,\n          ...metadata,\n        },\n        updatedAt: new Date(),\n      };\n    }\n\n    this.collection.resources.set(resourceId, resource);\n    return resource;\n  }\n\n  private sortThreads(threads: any[], orderBy: ThreadOrderBy, sortDirection: ThreadSortDirection): any[] {\n    return threads.sort((a, b) => {\n      const aValue = new Date(a[orderBy]).getTime();\n      const bValue = new Date(b[orderBy]).getTime();\n\n      if (sortDirection === 'ASC') {\n        return aValue - bValue;\n      } else {\n        return bValue - aValue;\n      }\n    });\n  }\n}\n","import type { TracingStrategy } from '../../../ai-tracing';\nimport { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type {\n  AISpanRecord,\n  AITraceRecord,\n  AITracesPaginatedArg,\n  CreateAISpanRecord,\n  PaginationInfo,\n  UpdateAISpanRecord,\n} from '../../types';\n\nexport class ObservabilityStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OBSERVABILITY',\n    });\n  }\n\n  /**\n   * Provides hints for AI tracing strategy selection by the DefaultExporter.\n   * Storage adapters can override this to specify their preferred and supported strategies.\n   */\n  public get aiTracingStrategy(): {\n    preferred: TracingStrategy;\n    supported: TracingStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates', // Default for most SQL stores\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  /**\n   * Creates a single AI span record in the storage provider.\n   */\n  createAISpan(_span: CreateAISpanRecord): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_CREATE_AI_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support creating AI spans',\n    });\n  }\n\n  /**\n   * Updates a single AI span with partial data. Primarily used for realtime trace creation.\n   */\n  updateAISpan(_params: { spanId: string; traceId: string; updates: Partial<UpdateAISpanRecord> }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_UPDATE_AI_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support updating AI spans',\n    });\n  }\n\n  /**\n   * Retrieves a single AI trace with all its associated spans.\n   */\n  getAITrace(_traceId: string): Promise<AITraceRecord | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_AI_TRACE_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting AI traces',\n    });\n  }\n\n  /**\n   * Retrieves a paginated list of AI traces with optional filtering.\n   */\n  getAITracesPaginated(_args: AITracesPaginatedArg): Promise<{ pagination: PaginationInfo; spans: AISpanRecord[] }> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_AI_TRACES_PAGINATED_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting AI traces paginated',\n    });\n  }\n\n  /**\n   * Creates multiple AI spans in a single batch.\n   */\n  batchCreateAISpans(_args: { records: CreateAISpanRecord[] }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_CREATE_AI_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch creating AI spans',\n    });\n  }\n\n  /**\n   * Updates multiple AI spans in a single batch.\n   */\n  batchUpdateAISpans(_args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateAISpanRecord>;\n    }[];\n  }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_UPDATE_AI_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch updating AI spans',\n    });\n  }\n\n  /**\n   * Deletes multiple AI traces and all their associated spans in a single batch operation.\n   */\n  batchDeleteAITraces(_args: { traceIds: string[] }): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_DELETE_AI_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch deleting AI traces',\n    });\n  }\n}\n","import type { TracingStrategy } from '../../../ai-tracing';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type {\n  AISpanRecord,\n  AITraceRecord,\n  AITracesPaginatedArg,\n  CreateAISpanRecord,\n  PaginationInfo,\n  UpdateAISpanRecord,\n} from '../../types';\nimport type { StoreOperations } from '../operations';\nimport { ObservabilityStorage } from './base';\n\nexport type InMemoryObservability = Map<string, AISpanRecord>;\nexport class ObservabilityInMemory extends ObservabilityStorage {\n  operations: StoreOperations;\n  collection: InMemoryObservability;\n\n  constructor({ collection, operations }: { collection: InMemoryObservability; operations: StoreOperations }) {\n    super();\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  public get aiTracingStrategy(): {\n    preferred: TracingStrategy;\n    supported: TracingStrategy[];\n  } {\n    return {\n      preferred: 'realtime',\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createAISpan(span: CreateAISpanRecord): Promise<void> {\n    this.validateCreateAISpan(span);\n    const id = this.generateId(span);\n    const record = span as AISpanRecord;\n    record.createdAt = new Date();\n    record.updatedAt = record.createdAt;\n    this.collection.set(id, record);\n  }\n\n  async batchCreateAISpans(args: { records: CreateAISpanRecord[] }): Promise<void> {\n    for (const record of args.records) {\n      await this.createAISpan(record);\n    }\n  }\n\n  private validateCreateAISpan(record: CreateAISpanRecord): void {\n    if (!record.spanId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_SPAN_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span ID is required for creating a span',\n      });\n    }\n\n    if (!record.traceId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_TRACE_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Trace ID is required for creating a span',\n      });\n    }\n  }\n\n  private generateId({ traceId, spanId }: { traceId: string; spanId: string }): string {\n    return `${traceId}-${spanId}`;\n  }\n\n  async getAITrace(traceId: string): Promise<AITraceRecord | null> {\n    const spans = Array.from(this.collection.values()).filter(span => span.traceId === traceId);\n    if (spans.length === 0) {\n      return null;\n    }\n    spans.sort((a, b) => a.startedAt.getTime() - b.startedAt.getTime());\n\n    return {\n      traceId,\n      spans,\n    };\n  }\n\n  async getAITracesPaginated({\n    filters,\n    pagination,\n  }: AITracesPaginatedArg): Promise<{ pagination: PaginationInfo; spans: AISpanRecord[] }> {\n    const allRootSpans = this.filterForRootSpans(Array.from(this.collection.values()));\n    const filteredRootSpans = this.filterSpansByFilter(allRootSpans, filters);\n\n    const startDate = pagination?.dateRange?.start;\n    const endDate = pagination?.dateRange?.end;\n    const filteredRootSpansByDate = this.filterSpansByDate(filteredRootSpans, startDate, endDate);\n\n    const total = filteredRootSpansByDate.length;\n    const page = pagination?.page ?? 0;\n    const perPage = pagination?.perPage ?? 10;\n\n    const start = page * perPage;\n    const end = start + perPage;\n    const paged = this.filterSpansByPagination(filteredRootSpansByDate, pagination);\n\n    return {\n      spans: paged,\n      pagination: { total, page, perPage, hasMore: end < total },\n    };\n  }\n\n  private filterForRootSpans(spans: AISpanRecord[]): AISpanRecord[] {\n    return spans.filter(span => span.parentSpanId === null);\n  }\n\n  private filterSpansByDate(\n    spans: AISpanRecord[],\n    startDate: Date | undefined,\n    endDate: Date | undefined,\n  ): AISpanRecord[] {\n    return spans.filter(span => {\n      if (startDate && span.startedAt < startDate) return false;\n      if (endDate && span.startedAt > endDate) return false;\n      return true;\n    });\n  }\n\n  private filterSpansByFilter(spans: AISpanRecord[], filter: AITracesPaginatedArg['filters']): AISpanRecord[] {\n    return spans.filter(span => {\n      if (filter?.name && span.name !== filter.name) return false;\n      if (filter?.spanType && span.spanType !== filter.spanType) return false;\n\n      if (filter?.entityType === 'agent' && filter.entityId !== span.attributes?.agentId) return false;\n\n      if (filter?.entityType === 'workflow' && filter.entityId !== span.attributes?.workflowId) return false;\n\n      return true;\n    });\n  }\n\n  private filterSpansByPagination(\n    spans: AISpanRecord[],\n    pagination: AITracesPaginatedArg['pagination'],\n  ): AISpanRecord[] {\n    const page = pagination?.page ?? 0;\n    const perPage = pagination?.perPage ?? 10;\n    const start = page * perPage;\n    const end = start + perPage;\n    return spans.slice(start, end);\n  }\n\n  async updateAISpan(params: { spanId: string; traceId: string; updates: Partial<UpdateAISpanRecord> }): Promise<void> {\n    const id = this.generateId(params);\n    const span = this.collection.get(id);\n\n    if (!span) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_UPDATE_AI_SPAN_NOT_FOUND',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span not found for update',\n      });\n    }\n\n    this.collection.set(id, { ...span, ...params.updates, updatedAt: new Date() });\n  }\n\n  async batchUpdateAISpans(args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateAISpanRecord>;\n    }[];\n  }): Promise<void> {\n    for (const record of args.records) {\n      await this.updateAISpan(record);\n    }\n  }\n\n  async batchDeleteAITraces(args: { traceIds: string[] }): Promise<void> {\n    for (const traceId of args.traceIds) {\n      const spans = Array.from(this.collection.values()).filter(span => span.traceId === traceId);\n      for (const span of spans) {\n        this.collection.delete(this.generateId(span));\n      }\n    }\n  }\n}\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn, CreateIndexOptions, IndexInfo, StorageIndexStats } from '../../types';\n\nexport abstract class StoreOperations extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OPERATIONS',\n    });\n  }\n\n  abstract hasColumn(table: string, column: string): Promise<boolean>;\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n        return 'TEXT';\n      case 'timestamp':\n        return 'TIMESTAMP';\n      case 'float':\n        return 'FLOAT';\n      case 'integer':\n        return 'INTEGER';\n      case 'bigint':\n        return 'BIGINT';\n      case 'jsonb':\n        return 'JSONB';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'timestamp':\n        return \"DEFAULT '1970-01-01 00:00:00'\";\n      case 'integer':\n      case 'bigint':\n      case 'float':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  abstract createTable({ tableName }: { tableName: TABLE_NAMES; schema: Record<string, StorageColumn> }): Promise<void>;\n\n  abstract clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract alterTable(args: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void>;\n\n  abstract insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void>;\n\n  abstract batchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void>;\n\n  abstract load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<R | null>;\n\n  /**\n   * DATABASE INDEX MANAGEMENT\n   * Optional methods for database index management.\n   * Storage adapters can override these to provide index management capabilities.\n   */\n\n  /**\n   * Creates a database index on specified columns\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async createIndex(_options: CreateIndexOptions): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Drops a database index by name\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async dropIndex(_indexName: string): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Lists database indexes for a table or all tables\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async listIndexes(_tableName?: string): Promise<IndexInfo[]> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Gets detailed statistics for a specific index\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async describeIndex(_indexName: string): Promise<StorageIndexStats> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Returns definitions for automatic performance indexes\n   * Storage adapters can override this to define indexes that should be created during initialization\n   * @returns Array of index definitions to create automatically\n   */\n  protected getAutomaticIndexDefinitions(): CreateIndexOptions[] {\n    return [];\n  }\n}\n","import { TABLE_EVALS, TABLE_WORKFLOW_SNAPSHOT } from '../../constants';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn } from '../../types';\nimport { StoreOperations } from './base';\n\nexport class StoreOperationsInMemory extends StoreOperations {\n  data: Record<TABLE_NAMES, Map<string, Record<string, any>>>;\n\n  constructor() {\n    super();\n    this.data = {\n      mastra_workflow_snapshot: new Map(),\n      mastra_evals: new Map(),\n      mastra_messages: new Map(),\n      mastra_threads: new Map(),\n      mastra_traces: new Map(),\n      mastra_resources: new Map(),\n      mastra_scorers: new Map(),\n      mastra_ai_spans: new Map(),\n    };\n  }\n\n  getDatabase() {\n    return this.data;\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    const table = this.data[tableName];\n    let key = record.id;\n    if ([TABLE_WORKFLOW_SNAPSHOT, TABLE_EVALS].includes(tableName) && !record.id && record.run_id) {\n      key = record.workflow_name ? `${record.workflow_name}-${record.run_id}` : record.run_id;\n      record.id = key;\n    } else if (!record.id) {\n      key = `auto-${Date.now()}-${Math.random()}`;\n      record.id = key;\n    }\n    table.set(key, record);\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    const table = this.data[tableName];\n    for (const record of records) {\n      let key = record.id;\n      if ([TABLE_WORKFLOW_SNAPSHOT, TABLE_EVALS].includes(tableName) && !record.id && record.run_id) {\n        key = record.run_id;\n        record.id = key;\n      } else if (!record.id) {\n        key = `auto-${Date.now()}-${Math.random()}`;\n        record.id = key;\n      }\n      table.set(key, record);\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    this.logger.debug(`MockStore: load called for ${tableName} with keys`, keys);\n\n    const table = this.data[tableName];\n\n    const records = Array.from(table.values());\n\n    return records.filter(record => Object.keys(keys).every(key => record[key] === keys[key]))?.[0] as R | null;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    this.logger.debug(`MockStore: createTable called for ${tableName} with schema`, schema);\n\n    this.data[tableName] = new Map();\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: clearTable called for ${tableName}`);\n\n    this.data[tableName].clear();\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: dropTable called for ${tableName}`);\n    this.data[tableName].clear();\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    this.logger.debug(`MockStore: alterTable called for ${tableName} with schema`, schema);\n  }\n\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    this.logger.debug(`MockStore: hasColumn called for ${table} with column ${column}`);\n    return true;\n  }\n}\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { ScoreRowData, ScoringSource } from '../../../scores/types';\nimport type { PaginationInfo, StoragePagination } from '../../types';\n\nexport abstract class ScoresStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'SCORES',\n    });\n  }\n\n  abstract getScoreById({ id }: { id: string }): Promise<ScoreRowData | null>;\n\n  abstract saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }>;\n\n  abstract getScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  abstract getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }>;\n\n  async getScoresBySpan({\n    traceId,\n    spanId,\n    pagination: _pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    throw new MastraError({\n      id: 'SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      details: { traceId, spanId },\n    });\n  }\n}\n","import type { ScoreRowData, ScoringSource } from '../../../scores/types';\nimport type { PaginationInfo, StoragePagination } from '../../types';\nimport { ScoresStorage } from './base';\n\nexport type InMemoryScores = Map<string, ScoreRowData>;\n\nexport class ScoresInMemory extends ScoresStorage {\n  scores: InMemoryScores;\n\n  constructor({ collection }: { collection: InMemoryScores }) {\n    super();\n    this.scores = collection;\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.scores.get(id) ?? null;\n  }\n\n  async saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }> {\n    const newScore = { id: crypto.randomUUID(), createdAt: new Date(), updatedAt: new Date(), ...score };\n    this.scores.set(newScore.id, newScore);\n    return { score: newScore };\n  }\n\n  async getScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(score => {\n      let baseFilter = score.scorerId === scorerId;\n\n      if (entityId) {\n        baseFilter = baseFilter && score.entityId === entityId;\n      }\n\n      if (entityType) {\n        baseFilter = baseFilter && score.entityType === entityType;\n      }\n\n      if (source) {\n        baseFilter = baseFilter && score.source === source;\n      }\n\n      return baseFilter;\n    });\n\n    return {\n      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),\n      pagination: {\n        total: scores.length,\n        page: pagination.page,\n        perPage: pagination.perPage,\n        hasMore: scores.length > (pagination.page + 1) * pagination.perPage,\n      },\n    };\n  }\n\n  async getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(score => score.runId === runId);\n    return {\n      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),\n      pagination: {\n        total: scores.length,\n        page: pagination.page,\n        perPage: pagination.perPage,\n        hasMore: scores.length > (pagination.page + 1) * pagination.perPage,\n      },\n    };\n  }\n\n  async getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    entityId: string;\n    entityType: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(score => {\n      const baseFilter = score.entityId === entityId && score.entityType === entityType;\n\n      return baseFilter;\n    });\n\n    return {\n      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),\n      pagination: {\n        total: scores.length,\n        page: pagination.page,\n        perPage: pagination.perPage,\n        hasMore: scores.length > (pagination.page + 1) * pagination.perPage,\n      },\n    };\n  }\n\n  async getScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    const scores = Array.from(this.scores.values()).filter(\n      score => score.traceId === traceId && score.spanId === spanId,\n    );\n    scores.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    return {\n      scores: scores.slice(pagination.page * pagination.perPage, (pagination.page + 1) * pagination.perPage),\n      pagination: {\n        total: scores.length,\n        page: pagination.page,\n        perPage: pagination.perPage,\n        hasMore: scores.length > (pagination.page + 1) * pagination.perPage,\n      },\n    };\n  }\n}\n","import { MastraBase } from '../../../base';\nimport type { Trace } from '../../../telemetry';\nimport type { StorageGetTracesArg, PaginationInfo, StorageGetTracesPaginatedArg } from '../../types';\n\nexport abstract class TracesStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'TRACES',\n    });\n  }\n\n  abstract getTraces(args: StorageGetTracesArg): Promise<Trace[]>;\n\n  abstract getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }>;\n\n  abstract batchTraceInsert(args: { records: Record<string, any>[] }): Promise<void>;\n}\n","import type { Trace } from '../../../telemetry';\nimport { TABLE_TRACES } from '../../constants';\nimport type { StorageGetTracesArg, PaginationInfo, StorageGetTracesPaginatedArg } from '../../types';\nimport type { StoreOperations } from '../operations';\nimport { TracesStorage } from './base';\n\nexport type InMemoryTraces = Map<string, Trace>;\n\nexport class TracesInMemory extends TracesStorage {\n  traces: InMemoryTraces;\n  operations: StoreOperations;\n  collection: InMemoryTraces;\n\n  constructor({ collection, operations }: { collection: InMemoryTraces; operations: StoreOperations }) {\n    super();\n    this.collection = collection;\n    this.traces = collection;\n    this.operations = operations;\n  }\n\n  async getTraces({\n    name,\n    scope,\n    page,\n    perPage,\n    attributes,\n    filters,\n    fromDate,\n    toDate,\n  }: StorageGetTracesArg): Promise<Trace[]> {\n    this.logger.debug(`MockStore: getTraces called`);\n    // Mock implementation - basic filtering\n    let traces = Array.from(this.collection.values());\n\n    if (name) traces = traces.filter((t: any) => t.name?.startsWith(name));\n    if (scope) traces = traces.filter((t: any) => t.scope === scope);\n    if (attributes) {\n      traces = traces.filter((t: any) =>\n        Object.entries(attributes).every(([key, value]) => t.attributes?.[key] === value),\n      );\n    }\n    if (filters) {\n      traces = traces.filter((t: any) => Object.entries(filters).every(([key, value]) => t[key] === value));\n    }\n    if (fromDate) traces = traces.filter((t: any) => new Date(t.createdAt) >= fromDate);\n    if (toDate) traces = traces.filter((t: any) => new Date(t.createdAt) <= toDate);\n\n    // Apply pagination and sort\n    traces.sort((a: any, b: any) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());\n    const start = page * perPage;\n    const end = start + perPage;\n    return traces.slice(start, end);\n  }\n\n  async getTracesPaginated({\n    name,\n    scope,\n    attributes,\n    page = 0,\n    perPage = 10,\n    dateRange,\n  }: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }> {\n    this.logger.debug(`MockStore: getTracesPaginated called`);\n    // Mock implementation - basic filtering\n    let traces = Array.from(this.collection.values());\n\n    if (name) traces = traces.filter((t: any) => t.name?.startsWith(name));\n    if (scope) traces = traces.filter((t: any) => t.scope === scope);\n    if (attributes) {\n      traces = traces.filter((t: any) =>\n        Object.entries(attributes).every(([key, value]) => t.attributes?.[key] === value),\n      );\n    }\n    if (dateRange?.start) traces = traces.filter((t: any) => new Date(t.createdAt) >= dateRange.start!);\n    if (dateRange?.end) traces = traces.filter((t: any) => new Date(t.createdAt) <= dateRange.end!);\n\n    // Apply pagination and sort\n    traces.sort((a: any, b: any) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());\n    const start = page * perPage;\n    const end = start + perPage;\n    return {\n      traces: traces.slice(start, end),\n      total: traces.length,\n      page,\n      perPage,\n      hasMore: traces.length > end,\n    };\n  }\n\n  async batchTraceInsert({ records }: { records: Record<string, any>[] }): Promise<void> {\n    this.logger.debug('Batch inserting traces', { count: records.length });\n    await this.operations.batchInsert({\n      tableName: TABLE_TRACES,\n      records,\n    });\n  }\n}\n","import { MastraBase } from '../../../base';\nimport type { StepResult, WorkflowRunState } from '../../../workflows';\nimport type { WorkflowRun, WorkflowRuns } from '../../types';\n\nexport abstract class WorkflowsStorage extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'WORKFLOWS',\n    });\n  }\n\n  abstract updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    runtimeContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    runtimeContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>>;\n\n  abstract updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined>;\n\n  abstract persistWorkflowSnapshot(_: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void>;\n\n  abstract loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null>;\n\n  abstract getWorkflowRuns(args?: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  }): Promise<WorkflowRuns>;\n\n  abstract getWorkflowRunById(args: { runId: string; workflowName?: string }): Promise<WorkflowRun | null>;\n}\n","import type { StepResult, WorkflowRunState } from '../../../workflows';\nimport { TABLE_WORKFLOW_SNAPSHOT } from '../../constants';\nimport type { StorageWorkflowRun, WorkflowRun, WorkflowRuns } from '../../types';\nimport type { StoreOperations } from '../operations';\nimport { WorkflowsStorage } from './base';\n\nexport type InMemoryWorkflows = Map<string, StorageWorkflowRun>;\n\nexport class WorkflowsInMemory extends WorkflowsStorage {\n  operations: StoreOperations;\n  collection: InMemoryWorkflows;\n\n  constructor({ collection, operations }: { collection: InMemoryWorkflows; operations: StoreOperations }) {\n    super();\n    this.collection = collection;\n    this.operations = operations;\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    runtimeContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    runtimeContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    this.logger.debug(`MockStore: updateWorkflowResults called for ${workflowName} ${runId} ${stepId}`, result);\n    const run = this.collection.get(`${workflowName}-${runId}`);\n\n    if (!run) {\n      return {};\n    }\n\n    let snapshot;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.collection.set(`${workflowName}-${runId}`, {\n        ...run,\n        snapshot,\n      });\n    }\n\n    snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot.context[stepId] = result;\n    snapshot.runtimeContext = { ...snapshot.runtimeContext, ...runtimeContext };\n\n    this.collection.set(`${workflowName}-${runId}`, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return JSON.parse(JSON.stringify(snapshot.context));\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined> {\n    const run = this.collection.get(`${workflowName}-${runId}`);\n\n    if (!run) {\n      return;\n    }\n\n    let snapshot;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.collection.set(`${workflowName}-${runId}`, {\n        ...run,\n        snapshot,\n      });\n    } else {\n      snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    }\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot = { ...snapshot, ...opts };\n    this.collection.set(`${workflowName}-${runId}`, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return snapshot;\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }) {\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    await this.operations.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.operations.load<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    // Return a deep copy to prevent mutation\n    return d ? JSON.parse(JSON.stringify(d.snapshot)) : null;\n  }\n\n  async getWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    limit,\n    offset,\n    resourceId,\n  }: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  } = {}): Promise<WorkflowRuns> {\n    let runs = Array.from(this.collection.values());\n\n    if (workflowName) runs = runs.filter((run: any) => run.workflow_name === workflowName);\n    if (fromDate && toDate) {\n      runs = runs.filter(\n        (run: any) =>\n          new Date(run.createdAt).getTime() >= fromDate.getTime() &&\n          new Date(run.createdAt).getTime() <= toDate.getTime(),\n      );\n    } else if (fromDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() >= fromDate.getTime());\n    } else if (toDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() <= toDate.getTime());\n    }\n    if (resourceId) runs = runs.filter((run: any) => run.resourceId === resourceId);\n\n    const total = runs.length;\n\n    // Sort by createdAt\n    runs.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Apply pagination\n    if (limit !== undefined && offset !== undefined) {\n      const start = offset;\n      const end = start + limit;\n      runs = runs.slice(start, end);\n    }\n\n    // Deserialize snapshot if it's a string\n    const parsedRuns = runs.map((run: any) => ({\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    }));\n\n    return { runs: parsedRuns as WorkflowRun[], total };\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const runs = Array.from(this.collection.values()).filter((r: any) => r.run_id === runId);\n    let run = runs.find((r: any) => r.workflow_name === workflowName);\n\n    if (!run) return null;\n\n    // Return a deep copy to prevent mutation\n    const parsedRun = {\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    };\n\n    return parsedRun as WorkflowRun;\n  }\n}\n","import type { MastraMessageV2 } from '../agent';\nimport type { MastraMessageV1, StorageThreadType } from '../memory/types';\nimport type { ScoreRowData, ScoringSource } from '../scores/types';\nimport type { Trace } from '../telemetry';\nimport type { StepResult, WorkflowRunState } from '../workflows/types';\nimport { MastraStorage } from './base';\nimport type { StorageDomains } from './base';\nimport type { TABLE_NAMES } from './constants';\nimport { InMemoryLegacyEvals } from './domains/legacy-evals/inmemory';\nimport type { InMemoryEvals } from './domains/legacy-evals/inmemory';\nimport { InMemoryMemory } from './domains/memory/inmemory';\nimport type { InMemoryThreads, InMemoryResources, InMemoryMessages } from './domains/memory/inmemory';\nimport { ObservabilityInMemory } from './domains/observability/inmemory';\nimport type { InMemoryObservability } from './domains/observability/inmemory';\nimport { StoreOperationsInMemory } from './domains/operations/inmemory';\nimport { ScoresInMemory } from './domains/scores/inmemory';\nimport type { InMemoryScores } from './domains/scores/inmemory';\nimport { TracesInMemory } from './domains/traces/inmemory';\nimport type { InMemoryTraces } from './domains/traces/inmemory';\nimport { WorkflowsInMemory } from './domains/workflows';\nimport type { InMemoryWorkflows } from './domains/workflows/inmemory';\n\nimport type {\n  AISpanRecord,\n  AITraceRecord,\n  EvalRow,\n  PaginationArgs,\n  PaginationInfo,\n  StorageColumn,\n  StorageGetMessagesArg,\n  StorageGetTracesPaginatedArg,\n  StoragePagination,\n  StorageResourceType,\n  ThreadSortOptions,\n  WorkflowRun,\n  WorkflowRuns,\n} from './types';\n\nexport class InMemoryStore extends MastraStorage {\n  stores: StorageDomains;\n\n  constructor() {\n    super({ name: 'InMemoryStorage' });\n    // MockStore doesn't need async initialization\n    this.hasInitialized = Promise.resolve(true);\n\n    const operationsStorage = new StoreOperationsInMemory();\n\n    const database = operationsStorage.getDatabase();\n\n    const scoresStorage = new ScoresInMemory({\n      collection: database.mastra_scorers as InMemoryScores,\n    });\n\n    const workflowsStorage = new WorkflowsInMemory({\n      collection: database.mastra_workflow_snapshot as InMemoryWorkflows,\n      operations: operationsStorage,\n    });\n\n    const tracesStorage = new TracesInMemory({\n      collection: database.mastra_traces as InMemoryTraces,\n      operations: operationsStorage,\n    });\n\n    const memoryStorage = new InMemoryMemory({\n      collection: {\n        threads: database.mastra_threads as InMemoryThreads,\n        resources: database.mastra_resources as InMemoryResources,\n        messages: database.mastra_messages as InMemoryMessages,\n      },\n      operations: operationsStorage,\n    });\n\n    const legacyEvalsStorage = new InMemoryLegacyEvals({\n      collection: database.mastra_evals as InMemoryEvals,\n    });\n\n    const observabilityStorage = new ObservabilityInMemory({\n      collection: database.mastra_ai_spans as InMemoryObservability,\n      operations: operationsStorage,\n    });\n\n    this.stores = {\n      legacyEvals: legacyEvalsStorage,\n      operations: operationsStorage,\n      workflows: workflowsStorage,\n      traces: tracesStorage,\n      scores: scoresStorage,\n      memory: memoryStorage,\n      observability: observabilityStorage,\n    };\n  }\n\n  public get supports() {\n    return {\n      selectByIncludeResourceScope: false,\n      resourceWorkingMemory: false,\n      hasColumn: false,\n      createTable: false,\n      deleteMessages: true,\n      aiTracing: true,\n      indexManagement: false,\n      getScoresBySpan: true,\n    };\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    await this.stores.workflows.persistWorkflowSnapshot({ workflowName, runId, resourceId, snapshot });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    return this.stores.workflows.loadWorkflowSnapshot({ workflowName, runId });\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    await this.stores.operations.createTable({ tableName, schema });\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    await this.stores.operations.alterTable({ tableName, schema, ifNotExists });\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    await this.stores.operations.clearTable({ tableName });\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    await this.stores.operations.dropTable({ tableName });\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    await this.stores.operations.insert({ tableName, record });\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    runtimeContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    runtimeContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    return this.stores.workflows.updateWorkflowResults({ workflowName, runId, stepId, result, runtimeContext });\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined> {\n    return this.stores.workflows.updateWorkflowState({ workflowName, runId, opts });\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    await this.stores.operations.batchInsert({ tableName, records });\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    return this.stores.operations.load({ tableName, keys });\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    return this.stores.memory.getThreadById({ threadId });\n  }\n\n  async getThreadsByResourceId({\n    resourceId,\n    orderBy,\n    sortDirection,\n  }: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    return this.stores.memory.getThreadsByResourceId({ resourceId, orderBy, sortDirection });\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    return this.stores.memory.saveThread({ thread });\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    return this.stores.memory.updateThread({ id, title, metadata });\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    return this.stores.memory.deleteThread({ threadId });\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    return this.stores.memory.getResourceById({ resourceId });\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    return this.stores.memory.saveResource({ resource });\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    return this.stores.memory.updateResource({ resourceId, workingMemory, metadata });\n  }\n\n  async getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  async getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  async getMessages({\n    threadId,\n    resourceId,\n    selectBy,\n    format,\n  }: StorageGetMessagesArg & { format?: 'v1' | 'v2' }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    return this.stores.memory.getMessages({ threadId, resourceId, selectBy, format }) as unknown as Promise<\n      MastraMessageV1[] | MastraMessageV2[]\n    >;\n  }\n\n  async getMessagesById({ messageIds, format }: { messageIds: string[]; format: 'v1' }): Promise<MastraMessageV1[]>;\n  async getMessagesById({ messageIds, format }: { messageIds: string[]; format?: 'v2' }): Promise<MastraMessageV2[]>;\n  async getMessagesById({\n    messageIds,\n    format,\n  }: {\n    messageIds: string[];\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    return this.stores.memory.getMessagesById({ messageIds, format });\n  }\n\n  async saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  async saveMessages(\n    args: { messages: MastraMessageV1[]; format?: undefined | 'v1' } | { messages: MastraMessageV2[]; format: 'v2' },\n  ): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    return this.stores.memory.saveMessages(args);\n  }\n\n  async updateMessages(args: { messages: Partial<MastraMessageV2> & { id: string }[] }): Promise<MastraMessageV2[]> {\n    return this.stores.memory.updateMessages(args);\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    return this.stores.memory.deleteMessages(messageIds);\n  }\n\n  async getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }> {\n    return this.stores.memory.getThreadsByResourceIdPaginated(args);\n  }\n\n  async getMessagesPaginated({\n    threadId,\n    selectBy,\n  }: StorageGetMessagesArg & { format?: 'v1' | 'v2' }): Promise<\n    PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }\n  > {\n    return this.stores.memory.getMessagesPaginated({ threadId, selectBy });\n  }\n\n  async getTraces({\n    name,\n    scope,\n    page,\n    perPage,\n    attributes,\n    filters,\n    fromDate,\n    toDate,\n  }: {\n    name?: string;\n    scope?: string;\n    page: number;\n    perPage: number;\n    attributes?: Record<string, string>;\n    filters?: Record<string, any>;\n    fromDate?: Date;\n    toDate?: Date;\n  }): Promise<any[]> {\n    return this.stores.traces.getTraces({ name, scope, page, perPage, attributes, filters, fromDate, toDate });\n  }\n\n  async getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }> {\n    return this.stores.traces.getTracesPaginated(args);\n  }\n\n  async batchTraceInsert(args: { records: Record<string, any>[] }): Promise<void> {\n    return this.stores.traces.batchTraceInsert(args);\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.stores.scores.getScoreById({ id });\n  }\n\n  async saveScore(score: ScoreRowData): Promise<{ score: ScoreRowData }> {\n    return this.stores.scores.saveScore(score);\n  }\n\n  async getScoresByScorerId({\n    scorerId,\n    entityId,\n    entityType,\n    source,\n    pagination,\n  }: {\n    scorerId: string;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByScorerId({ scorerId, entityId, entityType, source, pagination });\n  }\n\n  async getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByRunId({ runId, pagination });\n  }\n\n  async getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    entityId: string;\n    entityType: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByEntityId({ entityId, entityType, pagination });\n  }\n\n  async getScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresBySpan({ traceId, spanId, pagination });\n  }\n\n  async getEvals(\n    options: { agentName?: string; type?: 'test' | 'live' } & PaginationArgs,\n  ): Promise<PaginationInfo & { evals: EvalRow[] }> {\n    return this.stores.legacyEvals.getEvals(options);\n  }\n\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    return this.stores.legacyEvals.getEvalsByAgentName(agentName, type);\n  }\n\n  async getWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    limit,\n    offset,\n    resourceId,\n  }: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  } = {}): Promise<WorkflowRuns> {\n    return this.stores.workflows.getWorkflowRuns({ workflowName, fromDate, toDate, limit, offset, resourceId });\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    return this.stores.workflows.getWorkflowRunById({ runId, workflowName });\n  }\n\n  async createAISpan(span: AISpanRecord): Promise<void> {\n    return this.stores.observability!.createAISpan(span);\n  }\n\n  async updateAISpan(params: {\n    spanId: string;\n    traceId: string;\n    updates: Partial<Omit<AISpanRecord, 'spanId' | 'traceId'>>;\n  }): Promise<void> {\n    return this.stores.observability!.updateAISpan(params);\n  }\n\n  async getAITrace(traceId: string): Promise<AITraceRecord | null> {\n    return this.stores.observability!.getAITrace(traceId);\n  }\n\n  async batchCreateAISpans(args: { records: AISpanRecord[] }): Promise<void> {\n    return this.stores.observability!.batchCreateAISpans(args);\n  }\n\n  async batchUpdateAISpans(args: {\n    records: { traceId: string; spanId: string; updates: Partial<Omit<AISpanRecord, 'spanId' | 'traceId'>> }[];\n  }): Promise<void> {\n    return this.stores.observability!.batchUpdateAISpans(args);\n  }\n\n  async batchDeleteAITraces(args: { traceIds: string[] }): Promise<void> {\n    return this.stores.observability!.batchDeleteAITraces(args);\n  }\n}\n\nexport const MockStore = InMemoryStore;\n","export function safelyParseJSON(input: any): any {\n  // If already an object (and not null), return as-is\n  if (input && typeof input === 'object') return input;\n  if (input == null) return {};\n  // If it's a string, try to parse\n  if (typeof input === 'string') {\n    try {\n      return JSON.parse(input);\n    } catch {\n      return input;\n    }\n  }\n  // For anything else (number, boolean, etc.), return empty object\n  return {};\n}\n"]}