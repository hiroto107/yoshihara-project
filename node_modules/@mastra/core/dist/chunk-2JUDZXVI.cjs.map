{"version":3,"sources":["../src/telemetry/utility.ts","../src/telemetry/telemetry.decorators.ts","../src/telemetry/storage-exporter.ts","../src/telemetry/telemetry.ts"],"names":["trace","propagation","SpanStatusCode","context","SpanKind","JsonTraceSerializer","acc","TABLE_TRACES","ExportResultCode","MastraError","otlpContext","recordResult","wrappedFn"],"mappings":"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","file":"chunk-2JUDZXVI.cjs","sourcesContent":["import { propagation, trace } from '@opentelemetry/api';\nimport type { Context } from '@opentelemetry/api';\n\n// Helper function to check if telemetry is active\nexport function hasActiveTelemetry(tracerName: string = 'default-tracer'): boolean {\n  try {\n    return !!trace.getTracer(tracerName);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get baggage values from context\n * @param ctx The context to get baggage values from\n * @returns\n */\nexport function getBaggageValues(ctx: Context) {\n  const currentBaggage = propagation.getBaggage(ctx);\n  const requestId = currentBaggage?.getEntry('http.request_id')?.value;\n  const componentName = currentBaggage?.getEntry('componentName')?.value;\n  const runId = currentBaggage?.getEntry('runId')?.value;\n  const threadId = currentBaggage?.getEntry('threadId')?.value;\n  const resourceId = currentBaggage?.getEntry('resourceId')?.value;\n  return {\n    requestId,\n    componentName,\n    runId,\n    threadId,\n    resourceId,\n  };\n}\n","import { trace, context, SpanStatusCode, SpanKind, propagation } from '@opentelemetry/api';\nimport type { Span } from '@opentelemetry/api';\n\nimport { hasActiveTelemetry, getBaggageValues } from './utility';\n\n// Type interfaces for better type safety\ninterface StreamFinishData {\n  text?: string;\n  usage?: {\n    // AI SDK v5 format (VNext paths)\n    inputTokens?: number;\n    outputTokens?: number;\n    reasoningTokens?: number;\n    cachedInputTokens?: number;\n    // Legacy format (backward compatibility)\n    promptTokens?: number;\n    completionTokens?: number;\n    // Common fields\n    totalTokens?: number;\n  };\n  finishReason?: string;\n  toolCalls?: unknown[];\n  toolResults?: unknown[];\n  warnings?: unknown;\n  object?: unknown; // For structured output\n}\n\ninterface StreamOptions {\n  onFinish?: (data: StreamFinishData) => Promise<void> | void;\n  [key: string]: unknown;\n}\n\ninterface EnhancedSpan extends Span {\n  __mastraStreamingSpan?: boolean;\n}\n\nfunction isStreamingResult(result: unknown, methodName: string): boolean {\n  if (methodName === 'stream' || methodName === 'streamLegacy') {\n    return true;\n  }\n\n  if (result && typeof result === 'object' && result !== null) {\n    const obj = result as Record<string, unknown>;\n    return 'textStream' in obj || 'objectStream' in obj || 'usagePromise' in obj || 'finishReasonPromise' in obj;\n  }\n\n  return false;\n}\n\nfunction enhanceStreamingArgumentsWithTelemetry(\n  args: unknown[],\n  span: EnhancedSpan,\n  spanName: string,\n  methodName: string,\n): unknown[] {\n  if (methodName === 'stream' || methodName === 'streamLegacy') {\n    const enhancedArgs = [...args];\n    const streamOptions = (enhancedArgs.length > 1 && (enhancedArgs[1] as StreamOptions)) || ({} as StreamOptions);\n    const enhancedStreamOptions: StreamOptions = { ...streamOptions };\n    const originalOnFinish = enhancedStreamOptions.onFinish;\n\n    enhancedStreamOptions.onFinish = async (finishData: StreamFinishData) => {\n      try {\n        const telemetryData = {\n          text: finishData.text,\n          usage: finishData.usage,\n          finishReason: finishData.finishReason,\n          toolCalls: finishData.toolCalls,\n          toolResults: finishData.toolResults,\n          warnings: finishData.warnings,\n          ...(finishData.object !== undefined && { object: finishData.object }),\n        };\n\n        span.setAttribute(`${spanName}.result`, JSON.stringify(telemetryData));\n        span.setStatus({ code: SpanStatusCode.OK });\n        span.end();\n      } catch (error) {\n        console.warn('Telemetry capture failed:', error);\n        span.setAttribute(`${spanName}.result`, '[Telemetry Capture Error]');\n        span.setStatus({ code: SpanStatusCode.ERROR });\n        span.end();\n      }\n\n      if (originalOnFinish) {\n        return await originalOnFinish(finishData);\n      }\n    };\n\n    // Check if an original onFinish was passed\n    (enhancedStreamOptions.onFinish as any).__hasOriginalOnFinish = !!originalOnFinish;\n\n    enhancedArgs[1] = enhancedStreamOptions;\n    span.__mastraStreamingSpan = true;\n\n    return enhancedArgs;\n  }\n\n  return args;\n}\n\n// Decorator factory that takes optional spanName\nexport function withSpan(options: {\n  spanName?: string;\n  skipIfNoTelemetry?: boolean;\n  spanKind?: SpanKind;\n  tracerName?: string;\n}): any {\n  return function (_target: any, propertyKey: string | symbol, descriptor?: PropertyDescriptor | number) {\n    if (!descriptor || typeof descriptor === 'number') return;\n\n    const originalMethod = descriptor.value as Function;\n    const methodName = String(propertyKey);\n\n    descriptor.value = function (this: unknown, ...args: unknown[]) {\n      // Skip if no telemetry is available and skipIfNoTelemetry is true\n      if (options?.skipIfNoTelemetry && !hasActiveTelemetry(options?.tracerName)) {\n        return originalMethod.apply(this, args);\n      }\n\n      const tracer = trace.getTracer(options?.tracerName ?? 'default-tracer');\n\n      // Determine span name and kind\n      let spanName: string;\n      let spanKind: SpanKind | undefined;\n\n      if (typeof options === 'string') {\n        spanName = options;\n      } else if (options) {\n        spanName = options.spanName || methodName;\n        spanKind = options.spanKind;\n      } else {\n        spanName = methodName;\n      }\n\n      // Start the span with optional kind\n      const span = tracer.startSpan(spanName, { kind: spanKind }) as EnhancedSpan;\n      let ctx = trace.setSpan(context.active(), span);\n\n      // Record input arguments as span attributes\n      args.forEach((arg, index) => {\n        try {\n          span.setAttribute(`${spanName}.argument.${index}`, JSON.stringify(arg));\n        } catch {\n          span.setAttribute(`${spanName}.argument.${index}`, '[Not Serializable]');\n        }\n      });\n\n      const { requestId, componentName, runId, threadId, resourceId } = getBaggageValues(ctx);\n      if (requestId) {\n        span.setAttribute('http.request_id', requestId);\n      }\n\n      if (threadId) {\n        span.setAttribute('threadId', threadId);\n      }\n\n      if (resourceId) {\n        span.setAttribute('resourceId', resourceId);\n      }\n\n      if (componentName) {\n        span.setAttribute('componentName', componentName);\n        // @ts-ignore - These properties may exist on the context\n        span.setAttribute('runId', runId);\n      } else if (this && typeof this === 'object' && 'name' in this) {\n        const contextObj = this as { name: string; runId?: string };\n        span.setAttribute('componentName', contextObj.name);\n        if (contextObj.runId) {\n          span.setAttribute('runId', contextObj.runId);\n        }\n        ctx = propagation.setBaggage(\n          ctx,\n          propagation.createBaggage({\n            // @ts-ignore\n            componentName: { value: this.name },\n            // @ts-ignore\n            runId: { value: this.runId },\n            // @ts-ignore\n            'http.request_id': { value: requestId },\n            // @ts-ignore\n            threadId: { value: threadId },\n            // @ts-ignore\n            resourceId: { value: resourceId },\n          }),\n        );\n      }\n\n      let result: unknown;\n      try {\n        // For streaming methods, enhance arguments with telemetry capture before calling\n        const enhancedArgs = isStreamingResult(result, methodName)\n          ? enhanceStreamingArgumentsWithTelemetry(args, span, spanName, methodName)\n          : args;\n\n        // Call the original method within the context\n        result = context.with(ctx, () => originalMethod.apply(this, enhancedArgs));\n\n        // Handle promises\n        if (result instanceof Promise) {\n          return result\n            .then(resolvedValue => {\n              if (isStreamingResult(resolvedValue, methodName)) {\n                return resolvedValue;\n              } else {\n                try {\n                  span.setAttribute(`${spanName}.result`, JSON.stringify(resolvedValue));\n                } catch {\n                  span.setAttribute(`${spanName}.result`, '[Not Serializable]');\n                }\n                return resolvedValue;\n              }\n            })\n            .finally(() => {\n              if (!span.__mastraStreamingSpan) {\n                span.end();\n              }\n            });\n        }\n\n        // Record result for non-promise returns\n        if (!isStreamingResult(result, methodName)) {\n          try {\n            span.setAttribute(`${spanName}.result`, JSON.stringify(result));\n          } catch {\n            span.setAttribute(`${spanName}.result`, '[Not Serializable]');\n          }\n        }\n\n        // Return regular results\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error instanceof Error ? error.message : 'Unknown error',\n        });\n        if (error instanceof Error) {\n          span.recordException(error);\n        }\n        throw error;\n      } finally {\n        // End span for non-promise returns\n        if (!(result instanceof Promise) && !isStreamingResult(result, methodName)) {\n          span.end();\n        }\n      }\n    };\n\n    return descriptor;\n  };\n}\n\n// class-telemetry.decorator.ts\nexport function InstrumentClass(options?: {\n  prefix?: string;\n  spanKind?: SpanKind;\n  excludeMethods?: string[];\n  methodFilter?: (methodName: string) => boolean;\n  tracerName?: string;\n}) {\n  return function (target: any) {\n    const methods = Object.getOwnPropertyNames(target.prototype);\n\n    methods.forEach(method => {\n      // Skip excluded methods\n      if (options?.excludeMethods?.includes(method) || method === 'constructor') return;\n      // Apply method filter if provided\n      if (options?.methodFilter && !options.methodFilter(method)) return;\n\n      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, method);\n      if (descriptor && typeof descriptor.value === 'function') {\n        Object.defineProperty(\n          target.prototype,\n          method,\n          withSpan({\n            spanName: options?.prefix ? `${options.prefix}.${method}` : method,\n            skipIfNoTelemetry: true,\n            spanKind: options?.spanKind || SpanKind.INTERNAL,\n            tracerName: options?.tracerName,\n          })(target, method, descriptor),\n        );\n      }\n    });\n\n    return target;\n  };\n}\n","import { ExportResultCode } from '@opentelemetry/core';\nimport type { ExportResult } from '@opentelemetry/core';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\nimport type { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\n\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { IMastraLogger } from '../logger';\nimport type { MastraStorage } from '../storage/base';\nimport { TABLE_TRACES } from '../storage/constants';\n\nexport class OTLPTraceExporter implements SpanExporter {\n  private storage: MastraStorage;\n  private queue: { data: any[]; resultCallback: (result: ExportResult) => void }[] = [];\n  private serializer: typeof JsonTraceSerializer;\n  private logger: IMastraLogger;\n  private activeFlush: Promise<void> | undefined = undefined;\n\n  constructor({ logger, storage }: { logger: IMastraLogger; storage: MastraStorage }) {\n    this.storage = storage;\n    this.serializer = JsonTraceSerializer;\n    this.logger = logger;\n  }\n\n  export(internalRepresentation: ReadableSpan[], resultCallback: (result: ExportResult) => void): void {\n    const serializedRequest = this.serializer.serializeRequest(internalRepresentation);\n    // @ts-ignore\n    const payload = JSON.parse(Buffer.from(serializedRequest.buffer, 'utf8'));\n    const items = payload?.resourceSpans?.[0]?.scopeSpans;\n    this.logger.debug(`Exporting telemetry: ${items.length} scope spans to be processed [trace batch]`);\n\n    this.queue.push({ data: items, resultCallback });\n\n    if (!this.activeFlush) {\n      this.activeFlush = this.flush();\n    }\n  }\n  shutdown(): Promise<void> {\n    return this.forceFlush();\n  }\n\n  flush(): Promise<void> {\n    const now = new Date();\n    const items = this.queue.shift();\n    if (!items) return Promise.resolve();\n\n    const allSpans: any[] = items.data.reduce((acc, scopedSpans) => {\n      const { scope, spans } = scopedSpans;\n      for (const span of spans) {\n        const {\n          spanId,\n          parentSpanId,\n          traceId,\n          name,\n          kind,\n          attributes,\n          status,\n          events,\n          links,\n          startTimeUnixNano,\n          endTimeUnixNano,\n          ...rest\n        } = span;\n\n        const startTime = Number(BigInt(startTimeUnixNano) / 1000n);\n        const endTime = Number(BigInt(endTimeUnixNano) / 1000n);\n\n        acc.push({\n          id: spanId,\n          parentSpanId,\n          traceId,\n          name,\n          scope: scope.name,\n          kind,\n          status: JSON.stringify(status),\n          events: JSON.stringify(events),\n          links: JSON.stringify(links),\n          attributes: JSON.stringify(\n            attributes.reduce((acc: Record<string, any>, attr: any) => {\n              const valueKey = Object.keys(attr.value)[0];\n              if (valueKey) {\n                acc[attr.key] = attr.value[valueKey];\n              }\n              return acc;\n            }, {}),\n          ),\n          startTime,\n          endTime,\n          other: JSON.stringify(rest),\n          createdAt: now,\n        });\n      }\n      return acc;\n    }, []);\n\n    return this.storage\n      .batchInsert({\n        tableName: TABLE_TRACES,\n        records: allSpans,\n      })\n      .then(() => {\n        items.resultCallback({\n          code: ExportResultCode.SUCCESS,\n        });\n      })\n      .catch(e => {\n        const mastraError = new MastraError(\n          {\n            id: 'OTLP_TRACE_EXPORT_FAILURE',\n            text: 'Failed to export telemetry spans',\n            domain: ErrorDomain.MASTRA_TELEMETRY,\n            category: ErrorCategory.SYSTEM,\n            details: {\n              attemptedSpanCount: allSpans.length,\n              targetTable: TABLE_TRACES,\n              firstSpanName: allSpans.length > 0 ? allSpans[0].name : '',\n              firstSpanKind: allSpans.length > 0 ? allSpans[0].kind : '',\n              firstSpanScope: allSpans.length > 0 ? allSpans[0].scope : '',\n            },\n          },\n          e,\n        );\n        this.logger.trackException(mastraError);\n        this.logger.error('span err:' + mastraError.toString());\n        items.resultCallback({\n          code: ExportResultCode.FAILED,\n          error: e,\n        });\n      })\n      .finally(() => {\n        this.activeFlush = undefined;\n      });\n  }\n  async forceFlush(): Promise<void> {\n    if (!this.queue.length) {\n      return;\n    }\n\n    await this.activeFlush;\n    while (this.queue.length) {\n      await this.flush();\n    }\n  }\n\n  __setLogger(logger: IMastraLogger) {\n    this.logger = logger;\n  }\n}\n","import { context as otlpContext, SpanStatusCode, trace, propagation, context } from '@opentelemetry/api';\nimport type { Tracer, SpanOptions, Context, Span, BaggageEntry } from '@opentelemetry/api';\n\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { OtelConfig } from './types';\nimport { getBaggageValues, hasActiveTelemetry } from './utility';\n\n// Add type declaration for global namespace\ndeclare global {\n  var __TELEMETRY__: Telemetry | undefined;\n}\n\nexport class Telemetry {\n  public tracer: Tracer = trace.getTracer('default');\n  name: string = 'default-service';\n\n  private constructor(config: OtelConfig) {\n    this.name = config.serviceName ?? 'default-service';\n\n    this.tracer = trace.getTracer(this.name);\n  }\n\n  /**\n   * @deprecated This method does not do anything\n   */\n  public async shutdown() {}\n\n  /**\n   * Initialize telemetry with the given configuration\n   * @param config - Optional telemetry configuration object\n   * @returns Telemetry instance that can be used for tracing\n   */\n  static init(config: OtelConfig = {}): Telemetry {\n    try {\n      if (!globalThis.__TELEMETRY__) {\n        globalThis.__TELEMETRY__ = new Telemetry(config);\n      }\n\n      return globalThis.__TELEMETRY__;\n    } catch (error) {\n      const wrappedError = new MastraError(\n        {\n          id: 'TELEMETRY_INIT_FAILED',\n          text: 'Failed to initialize telemetry',\n          domain: ErrorDomain.MASTRA_TELEMETRY,\n          category: ErrorCategory.SYSTEM,\n        },\n        error,\n      );\n      throw wrappedError;\n    }\n  }\n\n  static getActiveSpan() {\n    const span = trace.getActiveSpan();\n    return span;\n  }\n\n  /**\n   * Get the global telemetry instance\n   * @throws {Error} If telemetry has not been initialized\n   * @returns {Telemetry} The global telemetry instance\n   */\n  static get(): Telemetry {\n    if (!globalThis.__TELEMETRY__) {\n      throw new MastraError({\n        id: 'TELEMETRY_GETTER_FAILED_GLOBAL_TELEMETRY_NOT_INITIALIZED',\n        text: 'Telemetry not initialized',\n        domain: ErrorDomain.MASTRA_TELEMETRY,\n        category: ErrorCategory.USER,\n      });\n    }\n    return globalThis.__TELEMETRY__;\n  }\n\n  /**\n   * Wraps a class instance with telemetry tracing\n   * @param instance The class instance to wrap\n   * @param options Optional configuration for tracing\n   * @returns Wrapped instance with all methods traced\n   */\n  traceClass<T extends object>(\n    instance: T,\n    options: {\n      /** Base name for spans (e.g. 'integration', 'agent') */\n      spanNamePrefix?: string;\n      /** Additional attributes to add to all spans */\n      attributes?: Record<string, string>;\n      /** Methods to exclude from tracing */\n      excludeMethods?: string[];\n      /** Skip tracing if telemetry is not active */\n      skipIfNoTelemetry?: boolean;\n    } = {},\n  ): T {\n    const { skipIfNoTelemetry = true } = options;\n\n    // Skip if no telemetry is active and skipIfNoTelemetry is true\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return instance;\n    }\n\n    const { spanNamePrefix = instance.constructor.name.toLowerCase(), attributes = {}, excludeMethods = [] } = options;\n\n    return new Proxy(instance, {\n      get: (target, prop: string | symbol) => {\n        const value = target[prop as keyof T];\n\n        // Skip tracing for excluded methods, constructors, private methods\n        if (\n          typeof value === 'function' &&\n          prop !== 'constructor' &&\n          !prop.toString().startsWith('_') &&\n          !excludeMethods.includes(prop.toString())\n        ) {\n          return this.traceMethod(value.bind(target), {\n            spanName: `${spanNamePrefix}.${prop.toString()}`,\n            attributes: {\n              ...attributes,\n              [`${spanNamePrefix}.name`]: target.constructor.name,\n              [`${spanNamePrefix}.method.name`]: prop.toString(),\n            },\n          });\n        }\n\n        return value;\n      },\n    });\n  }\n\n  static setBaggage(baggage: Record<string, BaggageEntry>, ctx: Context = otlpContext.active()) {\n    const currentBaggage = Object.fromEntries(propagation.getBaggage(ctx)?.getAllEntries() ?? []);\n    const newCtx = propagation.setBaggage(\n      ctx,\n      propagation.createBaggage({\n        ...currentBaggage,\n        ...baggage,\n      }),\n    );\n    return newCtx;\n  }\n\n  static withContext(ctx: Context, fn: () => void) {\n    return otlpContext.with(ctx, fn);\n  }\n\n  /**\n   * method to trace individual methods with proper context\n   * @param method The method to trace\n   * @param context Additional context for the trace\n   * @returns Wrapped method with tracing\n   */\n  traceMethod<TMethod extends Function>(\n    method: TMethod,\n    context: {\n      spanName: string;\n      attributes?: Record<string, string>;\n      skipIfNoTelemetry?: boolean;\n      parentSpan?: Span;\n    },\n  ): TMethod {\n    let ctx = otlpContext.active();\n    const { skipIfNoTelemetry = true } = context;\n\n    // Skip if no telemetry is active and skipIfNoTelemetry is true\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return method;\n    }\n\n    return ((...args: unknown[]) => {\n      const span = this.tracer.startSpan(context.spanName);\n\n      function handleError(error: unknown) {\n        span.recordException(error as Error);\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: (error as Error).message,\n        });\n        span.end();\n        throw error;\n      }\n      try {\n        const { requestId, componentName, runId, threadId, resourceId } = getBaggageValues(ctx);\n\n        // Add all context attributes to span\n        if (context.attributes) {\n          span.setAttributes(context.attributes);\n        }\n\n        if (requestId) {\n          span.setAttribute('http.request_id', requestId);\n        }\n\n        if (threadId) {\n          span.setAttribute('threadId', threadId);\n        }\n\n        if (resourceId) {\n          span.setAttribute('resourceId', resourceId);\n        }\n\n        if (context.attributes?.componentName) {\n          ctx = propagation.setBaggage(\n            ctx,\n            propagation.createBaggage({\n              componentName: { value: context.attributes.componentName },\n              // @ts-ignore\n              runId: { value: context.attributes.runId },\n              // @ts-ignore\n              'http.request_id': { value: requestId },\n            }),\n          );\n        } else {\n          if (componentName) {\n            span.setAttribute('componentName', componentName);\n            // @ts-ignore\n            span.setAttribute('runId', runId);\n          } else if (this && this.name) {\n            span.setAttribute('componentName', this.name);\n            // @ts-ignore\n            span.setAttribute('runId', this.runId);\n            ctx = propagation.setBaggage(\n              ctx,\n              propagation.createBaggage({\n                componentName: { value: this.name },\n                // @ts-ignore\n                runId: { value: this.runId },\n                // @ts-ignore\n                'http.request_id': { value: requestId },\n                // @ts-ignore\n                threadId: { value: threadId },\n                // @ts-ignore\n                resourceId: { value: resourceId },\n              }),\n            );\n          }\n        }\n\n        // Record input arguments as span attributes\n        args.forEach((arg, index) => {\n          try {\n            span.setAttribute(`${context.spanName}.argument.${index}`, JSON.stringify(arg));\n          } catch {\n            span.setAttribute(`${context.spanName}.argument.${index}`, '[Not Serializable]');\n          }\n        });\n\n        let result: any;\n        otlpContext.with(trace.setSpan(ctx, span), () => {\n          result = method(...args);\n        });\n\n        function recordResult(res: any) {\n          try {\n            span.setAttribute(`${context.spanName}.result`, JSON.stringify(res));\n          } catch {\n            span.setAttribute(`${context.spanName}.result`, '[Not Serializable]');\n          }\n\n          span.end();\n\n          return res;\n        }\n\n        if (result instanceof Promise) {\n          return result.then(recordResult).catch(handleError);\n        } else {\n          return recordResult(result);\n        }\n      } catch (error) {\n        handleError(error);\n      }\n    }) as unknown as TMethod;\n  }\n\n  getBaggageTracer(): Tracer {\n    return new BaggageTracer(this.tracer);\n  }\n}\n\nclass BaggageTracer implements Tracer {\n  private _tracer: Tracer;\n\n  constructor(tracer: Tracer) {\n    this._tracer = tracer;\n  }\n\n  startSpan(name: string, options: SpanOptions = {}, ctx: Context) {\n    ctx = ctx ?? otlpContext.active();\n    const span = this._tracer.startSpan(name, options, ctx);\n    const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(ctx);\n    // @ts-ignore\n    span.setAttribute('componentName', componentName);\n    // @ts-ignore\n    span.setAttribute('runId', runId);\n    // @ts-ignore\n    span.setAttribute('http.request_id', requestId);\n    // @ts-ignore\n    span.setAttribute('threadId', threadId);\n    // @ts-ignore\n    span.setAttribute('resourceId', resourceId);\n\n    return span;\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(name: string, fn: F): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(name: string, options: SpanOptions, fn: F): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: string,\n    options: SpanOptions,\n    ctx: Context,\n    fn: F,\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: string,\n    optionsOrFn: SpanOptions | F,\n    ctxOrFn?: Context | F,\n    fn?: F,\n  ): ReturnType<F> {\n    if (typeof optionsOrFn === 'function') {\n      const wrappedFn = (span: Span) => {\n        const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(otlpContext.active());\n        // @ts-ignore\n        span.setAttribute('componentName', componentName);\n        // @ts-ignore\n        span.setAttribute('runId', runId);\n        // @ts-ignore\n        span.setAttribute('http.request_id', requestId);\n        // @ts-ignore\n        span.setAttribute('threadId', threadId);\n        // @ts-ignore\n        span.setAttribute('resourceId', resourceId);\n\n        return optionsOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, {}, context.active(), wrappedFn as F);\n    }\n    if (typeof ctxOrFn === 'function') {\n      const wrappedFn = (span: Span) => {\n        const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(otlpContext.active());\n        // @ts-ignore\n        span.setAttribute('componentName', componentName);\n        // @ts-ignore\n        span.setAttribute('runId', runId);\n        // @ts-ignore\n        span.setAttribute('http.request_id', requestId);\n        // @ts-ignore\n        span.setAttribute('threadId', threadId);\n        // @ts-ignore\n        span.setAttribute('resourceId', resourceId);\n\n        return ctxOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, optionsOrFn, context.active(), wrappedFn as F);\n    }\n    const wrappedFn = (span: Span) => {\n      const { componentName, runId, requestId, threadId, resourceId } = getBaggageValues(\n        ctxOrFn ?? otlpContext.active(),\n      );\n      // @ts-ignore\n      span.setAttribute('componentName', componentName);\n      // @ts-ignore\n      span.setAttribute('runId', runId);\n      // @ts-ignore\n      span.setAttribute('http.request_id', requestId);\n      // @ts-ignore\n      span.setAttribute('threadId', threadId);\n      // @ts-ignore\n      span.setAttribute('resourceId', resourceId);\n\n      return fn!(span);\n    };\n    return this._tracer.startActiveSpan(name, optionsOrFn, ctxOrFn!, wrappedFn as F);\n  }\n}\n"]}