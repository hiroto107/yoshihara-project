{"version":3,"sources":["../src/logger/multi-logger.ts","../src/logger/noop-logger.ts","../src/logger/transport.ts"],"names":["Transform"],"mappings":"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","file":"chunk-6TEQIYXV.cjs","sourcesContent":["import type { MastraError } from '../error';\nimport type { LogLevel } from './constants';\nimport type { IMastraLogger } from './logger';\nimport type { LoggerTransport } from './transport';\n\nexport class MultiLogger implements IMastraLogger {\n  private loggers: IMastraLogger[];\n\n  constructor(loggers: IMastraLogger[]) {\n    this.loggers = loggers;\n  }\n\n  debug(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.debug(message, ...args));\n  }\n\n  info(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.info(message, ...args));\n  }\n\n  warn(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.warn(message, ...args));\n  }\n\n  error(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.error(message, ...args));\n  }\n\n  trackException(error: MastraError): void {\n    this.loggers.forEach(logger => logger.trackException(error));\n  }\n\n  getTransports(): Map<string, LoggerTransport> {\n    const transports: [string, LoggerTransport][] = [];\n    this.loggers.forEach(logger => transports.push(...logger.getTransports().entries()));\n    return new Map(transports);\n  }\n\n  async getLogs(\n    transportId: string,\n    params?: {\n      fromDate?: Date;\n      toDate?: Date;\n      logLevel?: LogLevel;\n      filters?: Record<string, any>;\n      returnPaginationResults?: boolean;\n      page?: number;\n      perPage?: number;\n    },\n  ) {\n    for (const logger of this.loggers) {\n      const logs = await logger.getLogs(transportId, params);\n      if (logs.total > 0) {\n        return logs;\n      }\n    }\n\n    return { logs: [], total: 0, page: params?.page ?? 1, perPage: params?.perPage ?? 100, hasMore: false };\n  }\n\n  async getLogsByRunId(args: {\n    transportId: string;\n    runId: string;\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    page?: number;\n    perPage?: number;\n  }) {\n    for (const logger of this.loggers) {\n      const logs = await logger.getLogsByRunId(args);\n      if (logs.total > 0) {\n        return logs;\n      }\n    }\n\n    return { logs: [], total: 0, page: args.page ?? 1, perPage: args.perPage ?? 100, hasMore: false };\n  }\n}\n","import type { IMastraLogger } from './logger';\n\nexport const noopLogger = {\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n  cleanup: async () => {},\n  getTransports: () => new Map(),\n  trackException: () => {},\n  getLogs: async () => ({ logs: [], total: 0, page: 1, perPage: 100, hasMore: false }),\n  getLogsByRunId: async () => ({ logs: [], total: 0, page: 1, perPage: 100, hasMore: false }),\n} as IMastraLogger;\n","import { Transform } from 'stream';\nimport type { LogLevel } from './constants';\n\nexport interface BaseLogMessage {\n  runId?: string;\n  msg: string;\n  level: LogLevel;\n  time: Date;\n  pid: number;\n  hostname: string;\n  name: string;\n}\n\nexport abstract class LoggerTransport extends Transform {\n  constructor(opts: any = {}) {\n    super({ ...opts, objectMode: true });\n  }\n\n  async getLogsByRunId(_args: {\n    runId: string;\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    page?: number;\n    perPage?: number;\n  }): Promise<{\n    logs: BaseLogMessage[];\n    total: number;\n    page: number;\n    perPage: number;\n    hasMore: boolean;\n  }> {\n    return { logs: [], total: 0, page: _args?.page ?? 1, perPage: _args?.perPage ?? 100, hasMore: false };\n  }\n  async getLogs(_args?: {\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    returnPaginationResults?: boolean;\n    page?: number;\n    perPage?: number;\n  }): Promise<{\n    logs: BaseLogMessage[];\n    total: number;\n    page: number;\n    perPage: number;\n    hasMore: boolean;\n  }> {\n    return { logs: [], total: 0, page: _args?.page ?? 1, perPage: _args?.perPage ?? 100, hasMore: false };\n  }\n}\n\nexport const createCustomTransport = (\n  stream: Transform,\n  getLogs?: LoggerTransport['getLogs'],\n  getLogsByRunId?: LoggerTransport['getLogsByRunId'],\n) => {\n  let transport = stream as LoggerTransport;\n  if (getLogs) {\n    transport.getLogs = getLogs;\n  }\n  if (getLogsByRunId) {\n    transport.getLogsByRunId = getLogsByRunId;\n  }\n  return transport as LoggerTransport;\n};\n"]}