{"version":3,"sources":["../src/runtime-context/index.ts"],"names":[],"mappings":";;;AAIO,IAAM,iBAAN,MAA6E;AAAA,EAC1E,QAAA,uBAAe,GAAA,EAAqB;AAAA,EAE5C,YACE,QAAA,EAGA;AACA,IAAA,IAAA,CAAK,QAAA,GAAW,IAAI,GAAA,CAAI,QAAQ,CAAA;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKO,GAAA,CACL,KACA,KAAA,EACM;AAEN,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,GAAA,EAAe,KAAK,CAAA;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,IAGL,GAAA,EAAW;AACX,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,GAAa,CAAA;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKO,IAA0E,GAAA,EAAiB;AAChG,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,GAAG,CAAA;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKO,OAA6E,GAAA,EAAiB;AACnG,IAAA,OAAO,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,GAAG,CAAA;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKO,KAAA,GAAc;AACnB,IAAA,IAAA,CAAK,SAAS,KAAA,EAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKO,IAAA,GAA4F;AACjG,IAAA,OAAO,IAAA,CAAK,SAAS,IAAA,EAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,MAAA,GAAuG;AAC5G,IAAA,OAAO,IAAA,CAAK,SAAS,MAAA,EAAO;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKO,OAAA,GAEL;AACA,IAAA,OAAO,IAAA,CAAK,SAAS,OAAA,EAAQ;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKO,IAAA,GAAe;AACpB,IAAA,OAAO,KAAK,QAAA,CAAS,IAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKO,QAAiB,UAAA,EAA0E;AAChG,IAAA,IAAA,CAAK,QAAA,CAAS,QAAQ,UAAiB,CAAA;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,MAAA,GAA8B;AACnC,IAAA,OAAO,MAAA,CAAO,WAAA,CAAY,IAAA,CAAK,QAAQ,CAAA;AAAA,EACzC;AACF","file":"chunk-GPWMM745.cjs","sourcesContent":["type RecordToTuple<T> = {\n  [K in keyof T]: [K, T[K]];\n}[keyof T][];\n\nexport class RuntimeContext<Values extends Record<string, any> | unknown = unknown> {\n  private registry = new Map<string, unknown>();\n\n  constructor(\n    iterable?: Values extends Record<string, any>\n      ? RecordToTuple<Partial<Values>>\n      : Iterable<readonly [string, unknown]>,\n  ) {\n    this.registry = new Map(iterable);\n  }\n\n  /**\n   * set a value with strict typing if `Values` is a Record and the key exists in it.\n   */\n  public set<K extends Values extends Record<string, any> ? keyof Values : string>(\n    key: K,\n    value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown,\n  ): void {\n    // The type assertion `key as string` is safe because K always extends string ultimately.\n    this.registry.set(key as string, value);\n  }\n\n  /**\n   * Get a value with its type\n   */\n  public get<\n    K extends Values extends Record<string, any> ? keyof Values : string,\n    R = Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown,\n  >(key: K): R {\n    return this.registry.get(key as string) as R;\n  }\n\n  /**\n   * Check if a key exists in the container\n   */\n  public has<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean {\n    return this.registry.has(key);\n  }\n\n  /**\n   * Delete a value by key\n   */\n  public delete<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean {\n    return this.registry.delete(key);\n  }\n\n  /**\n   * Clear all values from the container\n   */\n  public clear(): void {\n    this.registry.clear();\n  }\n\n  /**\n   * Get all keys in the container\n   */\n  public keys<R = Values extends Record<string, any> ? keyof Values : string>(): IterableIterator<R> {\n    return this.registry.keys() as IterableIterator<R>;\n  }\n\n  /**\n   * Get all values in the container\n   */\n  public values<R = Values extends Record<string, any> ? Values[keyof Values] : unknown>(): IterableIterator<R> {\n    return this.registry.values() as IterableIterator<R>;\n  }\n\n  /**\n   * Get all entries in the container\n   */\n  public entries<R = Values extends Record<string, any> ? Values[keyof Values] : unknown>(): IterableIterator<\n    [string, R]\n  > {\n    return this.registry.entries() as IterableIterator<[string, R]>;\n  }\n\n  /**\n   * Get the size of the container\n   */\n  public size(): number {\n    return this.registry.size;\n  }\n\n  /**\n   * Execute a function for each entry in the container\n   */\n  public forEach<T = any>(callbackfn: (value: T, key: string, map: Map<string, any>) => void): void {\n    this.registry.forEach(callbackfn as any);\n  }\n\n  /**\n   * Custom JSON serialization method\n   * Converts the internal Map to a plain object for proper JSON serialization\n   */\n  public toJSON(): Record<string, any> {\n    return Object.fromEntries(this.registry);\n  }\n}\n"]}