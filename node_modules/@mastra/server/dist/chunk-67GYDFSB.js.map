{"version":3,"sources":["../src/server/handlers/telemetry.ts"],"names":["error","acc"],"mappings":"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","file":"chunk-67GYDFSB.js","sourcesContent":["import { HTTPException } from '../http-exception';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\n\ninterface TelemetryContext extends Context {\n  body?: {\n    name?: string;\n    scope?: string;\n    page?: number;\n    perPage?: number;\n    attribute?: string | string[];\n    fromDate?: Date;\n    toDate?: Date;\n  };\n}\n\nexport async function getTelemetryHandler({ mastra, body }: TelemetryContext) {\n  try {\n    const telemetry = mastra.getTelemetry();\n    const storage = mastra.getStorage();\n\n    if (!telemetry) {\n      throw new HTTPException(400, { message: 'Telemetry is not initialized' });\n    }\n\n    if (!storage) {\n      return [];\n    }\n\n    if (!body) {\n      throw new HTTPException(400, { message: 'Body is required' });\n    }\n\n    const { name, scope, page, perPage, attribute, fromDate, toDate } = body;\n\n    // Parse attribute query parameter if present\n    const attributes = attribute\n      ? Object.fromEntries(\n          (Array.isArray(attribute) ? attribute : [attribute]).map(attr => {\n            const [key, value] = attr.split(':');\n            return [key, value];\n          }),\n        )\n      : undefined;\n\n    const traces = await storage.getTraces({\n      name,\n      scope,\n      page: Number(page ?? 0),\n      perPage: Number(perPage ?? 100),\n      attributes,\n      fromDate: fromDate ? new Date(fromDate) : undefined,\n      toDate: toDate ? new Date(toDate) : undefined,\n    });\n\n    return traces;\n  } catch (error) {\n    return handleError(error, 'Error getting telemetry');\n  }\n}\n\nexport async function storeTelemetryHandler({ mastra, body }: Context & { body: { resourceSpans: any[] } }) {\n  try {\n    const storage = mastra.getStorage();\n    const logger = mastra.getLogger();\n\n    if (!storage) {\n      return {\n        status: 'error',\n        message: 'Storage is not initialized',\n      };\n    }\n\n    const now = new Date();\n\n    const items = body?.resourceSpans?.[0]?.scopeSpans;\n    logger.debug('[Telemetry Handler] Received spans:', {\n      totalSpans: items?.reduce((acc: number, scope: { spans: any[] }) => acc + scope.spans.length, 0) || 0,\n      timestamp: now.toISOString(),\n    });\n    if (!items?.length) {\n      return {\n        status: 'success',\n        message: 'No spans to process',\n        traceCount: 0,\n      };\n    }\n\n    const parentSpanIds = collectParentSpanIds(items);\n    const allSpans: any[] = items.reduce((acc: any, scopedSpans: any) => {\n      const { scope, spans } = scopedSpans;\n\n      // HTTP instrumentation spans are root spans but are not useful.\n      // Remove them entirely and promote their direct children to root spans.\n      if (scope.name === '@opentelemetry/instrumentation-http') {\n        return acc;\n      }\n\n      for (const span of spans) {\n        const {\n          spanId,\n          parentSpanId,\n          traceId,\n          name,\n          kind,\n          attributes,\n          status,\n          events,\n          links,\n          startTimeUnixNano,\n          endTimeUnixNano,\n          ...rest\n        } = span;\n\n        const startTime = Number(BigInt(startTimeUnixNano) / 1000n);\n        const endTime = Number(BigInt(endTimeUnixNano) / 1000n);\n\n        acc.push({\n          id: spanId,\n          parentSpanId: parentSpanIds.has(parentSpanId) ? null : parentSpanId,\n          traceId,\n          name,\n          scope: scope.name,\n          kind,\n          status: JSON.stringify(status),\n          events: JSON.stringify(events),\n          links: JSON.stringify(links),\n          attributes: JSON.stringify(\n            attributes.reduce((acc: Record<string, any>, attr: any) => {\n              const valueKey = Object.keys(attr.value)[0];\n              if (valueKey) {\n                acc[attr.key] = attr.value[valueKey];\n              }\n              return acc;\n            }, {}),\n          ),\n          startTime,\n          endTime,\n          other: JSON.stringify(rest),\n          createdAt: now,\n        });\n      }\n      return acc;\n    }, []);\n\n    return storage\n      .batchTraceInsert({\n        records: allSpans,\n      })\n      .then(() => {\n        return {\n          status: 'success',\n          message: 'Traces received and processed successfully',\n          traceCount: body.resourceSpans?.length || 0,\n        };\n      })\n      .catch(() => {\n        return {\n          status: 'error',\n          message: 'Failed to process traces',\n          // @ts-ignore\n          error: error.message,\n        };\n      });\n\n    // Return a simple response\n  } catch (error) {\n    console.error('Error processing traces:', error);\n    return {\n      status: 'error',\n      message: 'Failed to process traces',\n      // @ts-ignore\n      error: error.message,\n    };\n  }\n}\n\nexport const collectParentSpanIds = (items: any[]) => {\n  const result = new Set<string>();\n  for (const { scope, spans } of items) {\n    if (scope.name !== '@opentelemetry/instrumentation-http') {\n      continue;\n    }\n\n    for (const span of spans) {\n      result.add(span.spanId);\n    }\n  }\n\n  return result;\n};\n"]}