import { stringify } from './chunk-LF2ZLOFP.js';
import { zodToJsonSchema } from '@mastra/core/utils/zod-to-json';

function getSteps(steps, path) {
  return Object.entries(steps).reduce((acc, [key, step]) => {
    const fullKey = path ? `${path}.${key}` : key;
    acc[fullKey] = {
      id: step.id,
      description: step.description,
      inputSchema: step.inputSchema ? stringify(zodToJsonSchema(step.inputSchema)) : void 0,
      outputSchema: step.outputSchema ? stringify(zodToJsonSchema(step.outputSchema)) : void 0,
      resumeSchema: step.resumeSchema ? stringify(zodToJsonSchema(step.resumeSchema)) : void 0,
      suspendSchema: step.suspendSchema ? stringify(zodToJsonSchema(step.suspendSchema)) : void 0,
      isWorkflow: step.component === "WORKFLOW",
      component: step.component
    };
    if (step.component === "WORKFLOW" && step.steps) {
      const nestedSteps = getSteps(step.steps, fullKey) || {};
      acc = { ...acc, ...nestedSteps };
    }
    return acc;
  }, {});
}
function getWorkflowInfo(workflow) {
  return {
    name: workflow.name,
    description: workflow.description,
    steps: Object.entries(workflow.steps).reduce((acc, [key, step]) => {
      acc[key] = {
        id: step.id,
        description: step.description,
        inputSchema: step.inputSchema ? stringify(zodToJsonSchema(step.inputSchema)) : void 0,
        outputSchema: step.outputSchema ? stringify(zodToJsonSchema(step.outputSchema)) : void 0,
        resumeSchema: step.resumeSchema ? stringify(zodToJsonSchema(step.resumeSchema)) : void 0,
        suspendSchema: step.suspendSchema ? stringify(zodToJsonSchema(step.suspendSchema)) : void 0,
        component: step.component
      };
      return acc;
    }, {}),
    allSteps: getSteps(workflow.steps) || {},
    stepGraph: workflow.serializedStepGraph,
    inputSchema: workflow.inputSchema ? stringify(zodToJsonSchema(workflow.inputSchema)) : void 0,
    outputSchema: workflow.outputSchema ? stringify(zodToJsonSchema(workflow.outputSchema)) : void 0
  };
}
var WorkflowRegistry = class {
  static additionalWorkflows = {};
  /**
   * Register a workflow temporarily
   */
  static registerTemporaryWorkflow(id, workflow) {
    this.additionalWorkflows[id] = workflow;
  }
  /**
   * Register all workflows from map
   */
  static registerTemporaryWorkflows(workflows, mastra) {
    for (const [id, workflow] of Object.entries(workflows)) {
      if (mastra) {
        workflow.__registerMastra(mastra);
        workflow.__registerPrimitives({
          logger: mastra.getLogger(),
          telemetry: mastra.getTelemetry(),
          storage: mastra.getStorage(),
          memory: mastra.getMemory(),
          agents: mastra.getAgents(),
          tts: mastra.getTTS(),
          vectors: mastra.getVectors()
        });
      }
      this.additionalWorkflows[id] = workflow;
    }
  }
  /**
   * Get a workflow by ID from the registry (returns undefined if not found)
   */
  static getWorkflow(workflowId) {
    return this.additionalWorkflows[workflowId];
  }
  /**
   * Get all workflows from the registry
   */
  static getAllWorkflows() {
    return { ...this.additionalWorkflows };
  }
  /**
   * Clean up a temporary workflow
   */
  static cleanupTemporaryWorkflow(workflowId) {
    delete this.additionalWorkflows[workflowId];
  }
  /**
   * Clean up all registered workflows
   */
  static cleanup() {
    this.additionalWorkflows = {};
  }
  /**
   * Check if a workflow ID is a valid agent-builder workflow
   */
  static isAgentBuilderWorkflow(workflowId) {
    return workflowId in this.additionalWorkflows;
  }
  /**
   * Get all registered temporary workflow IDs (for debugging)
   */
  static getRegisteredWorkflowIds() {
    return Object.keys(this.additionalWorkflows);
  }
};
function convertInstructionsToString(message) {
  if (!message) {
    return "";
  }
  if (typeof message === "string") {
    return message;
  }
  if (Array.isArray(message)) {
    return message.map((m) => {
      if (typeof m === "string") {
        return m;
      }
      return typeof m.content === "string" ? m.content : "";
    }).filter((content) => content).join("\n");
  }
  return typeof message.content === "string" ? message.content : "";
}

export { WorkflowRegistry, convertInstructionsToString, getWorkflowInfo };
//# sourceMappingURL=chunk-YWOK4F5A.js.map
//# sourceMappingURL=chunk-YWOK4F5A.js.map