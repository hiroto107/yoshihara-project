'use strict';

var chunkG4PUALCE_cjs = require('./chunk-G4PUALCE.cjs');
var chunkRE4RPXT2_cjs = require('./chunk-RE4RPXT2.cjs');
var chunk7NADHFD2_cjs = require('./chunk-7NADHFD2.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var stream = require('stream');
var error = require('@mastra/core/error');

// src/server/handlers/voice.ts
var voice_exports = {};
chunkO7I5CWRX_cjs.__export(voice_exports, {
  generateSpeechHandler: () => generateSpeechHandler,
  getListenerHandler: () => getListenerHandler,
  getSpeakersHandler: () => getSpeakersHandler,
  transcribeSpeechHandler: () => transcribeSpeechHandler
});
async function getSpeakersHandler({ mastra, agentId, runtimeContext }) {
  try {
    if (!agentId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent ID is required" });
    }
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const speakers = await voice.getSpeakers();
    return speakers;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting speakers");
  }
}
async function generateSpeechHandler({
  mastra,
  agentId,
  body,
  runtimeContext
}) {
  try {
    if (!agentId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent ID is required" });
    }
    chunkG4PUALCE_cjs.validateBody({
      text: body?.text
    });
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const audioStream = await Promise.resolve().then(() => voice.speak(body.text, { speaker: body.speakerId })).catch((err) => {
      if (err instanceof error.MastraError) {
        throw new chunk7NADHFD2_cjs.HTTPException(400, { message: err.message });
      }
      throw err;
    });
    if (!audioStream) {
      throw new chunk7NADHFD2_cjs.HTTPException(500, { message: "Failed to generate speech" });
    }
    return audioStream;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error generating speech");
  }
}
async function transcribeSpeechHandler({
  mastra,
  agentId,
  body,
  runtimeContext
}) {
  try {
    if (!agentId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent ID is required" });
    }
    if (!body?.audioData) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Audio data is required" });
    }
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const audioStream = new stream.Readable();
    audioStream.push(body.audioData);
    audioStream.push(null);
    const text = await voice.listen(audioStream, body.options);
    return { text };
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error transcribing speech");
  }
}
async function getListenerHandler({ mastra, agentId, runtimeContext }) {
  try {
    if (!agentId) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent ID is required" });
    }
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const listeners = await voice.getListener();
    return listeners;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting listeners");
  }
}

exports.generateSpeechHandler = generateSpeechHandler;
exports.getListenerHandler = getListenerHandler;
exports.getSpeakersHandler = getSpeakersHandler;
exports.transcribeSpeechHandler = transcribeSpeechHandler;
exports.voice_exports = voice_exports;
//# sourceMappingURL=chunk-3SNGNFUJ.cjs.map
//# sourceMappingURL=chunk-3SNGNFUJ.cjs.map