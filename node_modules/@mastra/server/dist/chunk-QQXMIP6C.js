import { validateBody } from './chunk-4QCXUEAT.js';
import { handleError } from './chunk-CY4TP3FK.js';
import { HTTPException } from './chunk-MMROOK5J.js';
import { __export } from './chunk-PR4QN5HX.js';
import { Readable } from 'stream';
import { MastraError } from '@mastra/core/error';

// src/server/handlers/voice.ts
var voice_exports = {};
__export(voice_exports, {
  generateSpeechHandler: () => generateSpeechHandler,
  getListenerHandler: () => getListenerHandler,
  getSpeakersHandler: () => getSpeakersHandler,
  transcribeSpeechHandler: () => transcribeSpeechHandler
});
async function getSpeakersHandler({ mastra, agentId, runtimeContext }) {
  try {
    if (!agentId) {
      throw new HTTPException(400, { message: "Agent ID is required" });
    }
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const speakers = await voice.getSpeakers();
    return speakers;
  } catch (error) {
    return handleError(error, "Error getting speakers");
  }
}
async function generateSpeechHandler({
  mastra,
  agentId,
  body,
  runtimeContext
}) {
  try {
    if (!agentId) {
      throw new HTTPException(400, { message: "Agent ID is required" });
    }
    validateBody({
      text: body?.text
    });
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const audioStream = await Promise.resolve().then(() => voice.speak(body.text, { speaker: body.speakerId })).catch((err) => {
      if (err instanceof MastraError) {
        throw new HTTPException(400, { message: err.message });
      }
      throw err;
    });
    if (!audioStream) {
      throw new HTTPException(500, { message: "Failed to generate speech" });
    }
    return audioStream;
  } catch (error) {
    return handleError(error, "Error generating speech");
  }
}
async function transcribeSpeechHandler({
  mastra,
  agentId,
  body,
  runtimeContext
}) {
  try {
    if (!agentId) {
      throw new HTTPException(400, { message: "Agent ID is required" });
    }
    if (!body?.audioData) {
      throw new HTTPException(400, { message: "Audio data is required" });
    }
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const audioStream = new Readable();
    audioStream.push(body.audioData);
    audioStream.push(null);
    const text = await voice.listen(audioStream, body.options);
    return { text };
  } catch (error) {
    return handleError(error, "Error transcribing speech");
  }
}
async function getListenerHandler({ mastra, agentId, runtimeContext }) {
  try {
    if (!agentId) {
      throw new HTTPException(400, { message: "Agent ID is required" });
    }
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const voice = await agent.getVoice({ runtimeContext });
    if (!voice) {
      throw new HTTPException(400, { message: "Agent does not have voice capabilities" });
    }
    const listeners = await voice.getListener();
    return listeners;
  } catch (error) {
    return handleError(error, "Error getting listeners");
  }
}

export { generateSpeechHandler, getListenerHandler, getSpeakersHandler, transcribeSpeechHandler, voice_exports };
//# sourceMappingURL=chunk-QQXMIP6C.js.map
//# sourceMappingURL=chunk-QQXMIP6C.js.map