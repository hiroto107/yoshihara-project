{"version":3,"sources":["../src/server/handlers/logs.ts"],"names":["__export","validateBody","handleError"],"mappings":"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","file":"chunk-XN74I6VW.cjs","sourcesContent":["import type { BaseLogMessage, LogLevel } from '@mastra/core/logger';\nimport type { Mastra } from '@mastra/core/mastra';\nimport { handleError } from './error';\nimport { validateBody } from './utils';\n\ntype LogsContext = {\n  mastra: Mastra;\n  transportId?: string;\n  runId?: string;\n  params?: {\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: string | string[];\n    page?: number;\n    perPage?: number;\n  };\n};\n\nexport async function getLogsHandler({\n  mastra,\n  transportId,\n  params,\n}: Pick<LogsContext, 'mastra' | 'transportId' | 'params'>): Promise<{\n  logs: BaseLogMessage[];\n  total: number;\n  page: number;\n  perPage: number;\n  hasMore: boolean;\n}> {\n  try {\n    validateBody({ transportId });\n\n    const { fromDate, toDate, logLevel, filters: _filters, page, perPage } = params || {};\n\n    // Parse filter query parameter if present\n    const filters = _filters\n      ? Object.fromEntries(\n          (Array.isArray(_filters) ? _filters : [_filters]).map(attr => {\n            const [key, value] = attr.split(':');\n            return [key, value];\n          }),\n        )\n      : undefined;\n\n    const logs = await mastra.getLogs(transportId!, {\n      fromDate,\n      toDate,\n      logLevel,\n      filters,\n      page: page ? Number(page) : undefined,\n      perPage: perPage ? Number(perPage) : undefined,\n    });\n    return logs;\n  } catch (error) {\n    return handleError(error, 'Error getting logs');\n  }\n}\n\nexport async function getLogsByRunIdHandler({\n  mastra,\n  runId,\n  transportId,\n  params,\n}: Pick<LogsContext, 'mastra' | 'runId' | 'transportId' | 'params'>) {\n  try {\n    validateBody({ runId, transportId });\n\n    const { fromDate, toDate, logLevel, filters: _filters, page, perPage } = params || {};\n\n    // Parse filter query parameter if present\n    const filters = _filters\n      ? Object.fromEntries(\n          (Array.isArray(_filters) ? _filters : [_filters]).map(attr => {\n            const [key, value] = attr.split(':');\n            return [key, value];\n          }),\n        )\n      : undefined;\n\n    const logs = await mastra.getLogsByRunId({\n      runId: runId!,\n      transportId: transportId!,\n      fromDate,\n      toDate,\n      logLevel,\n      filters,\n      page: page ? Number(page) : undefined,\n      perPage: perPage ? Number(perPage) : undefined,\n    });\n    return logs;\n  } catch (error) {\n    return handleError(error, 'Error getting logs by run ID');\n  }\n}\n\nexport async function getLogTransports({ mastra }: Pick<LogsContext, 'mastra'>) {\n  try {\n    const logger = mastra.getLogger();\n    const transports = logger.getTransports();\n\n    return {\n      transports: transports ? [...transports.keys()] : [],\n    };\n  } catch (error) {\n    return handleError(error, 'Error getting log Transports');\n  }\n}\n"]}