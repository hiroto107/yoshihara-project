{"version":3,"sources":["../../../node_modules/.pnpm/secure-json-parse@2.7.0/node_modules/secure-json-parse/index.js","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider@1.1.3/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../../../node_modules/.pnpm/nanoid@3.3.11/node_modules/nanoid/non-secure/index.js","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/delay.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validator.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../../../node_modules/.pnpm/@ai-sdk+provider-utils@2.2.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts"],"names":["__commonJS","_AISDKError","name","marker","symbol","_a","_TypeValidationError","__toESM","resolve","getErrorMessage","validator","SecureJSON","TypeValidationError","InvalidArgumentError","getOriginalFetch","APICallError"],"mappings":"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","file":"chunk-LPM6BBAX.cjs","sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n"]}