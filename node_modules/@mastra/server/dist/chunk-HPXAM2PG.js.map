{"version":3,"sources":["../src/server/handlers/a2a.ts","../src/server/a2a/protocol.ts","../src/server/a2a/tasks.ts"],"names":["MastraA2AError","result"],"mappings":"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","file":"chunk-HPXAM2PG.js","sourcesContent":["import { MastraA2AError } from '@mastra/core/a2a';\nimport type {\n  MessageSendParams,\n  TaskQueryParams,\n  TaskIdParams,\n  AgentCard,\n  TaskStatus,\n  TaskState,\n} from '@mastra/core/a2a';\nimport type { Agent } from '@mastra/core/agent';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { RuntimeContext } from '@mastra/core/runtime-context';\nimport { z } from 'zod';\nimport { convertToCoreMessage, normalizeError, createSuccessResponse, createErrorResponse } from '../a2a/protocol';\nimport type { InMemoryTaskStore } from '../a2a/store';\nimport { applyUpdateToTask, createTaskContext, loadOrCreateTask } from '../a2a/tasks';\nimport type { Context } from '../types';\nimport { convertInstructionsToString } from '../utils';\n\nconst messageSendParamsSchema = z.object({\n  message: z.object({\n    role: z.enum(['user', 'agent']),\n    parts: z.array(\n      z.object({\n        kind: z.enum(['text']),\n        text: z.string(),\n      }),\n    ),\n    kind: z.literal('message'),\n    messageId: z.string(),\n    contextId: z.string().optional(),\n    taskId: z.string().optional(),\n    referenceTaskIds: z.array(z.string()).optional(),\n    extensions: z.array(z.string()).optional(),\n    metadata: z.record(z.any()).optional(),\n  }),\n});\n\nexport async function getAgentCardByIdHandler({\n  mastra,\n  agentId,\n  executionUrl = `/a2a/${agentId}`,\n  provider = {\n    organization: 'Mastra',\n    url: 'https://mastra.ai',\n  },\n  version = '1.0',\n  runtimeContext,\n}: Context & {\n  runtimeContext: RuntimeContext;\n  agentId: keyof ReturnType<typeof mastra.getAgents>;\n  executionUrl?: string;\n  version?: string;\n  provider?: {\n    organization: string;\n    url: string;\n  };\n}): Promise<AgentCard> {\n  const agent = mastra.getAgent(agentId);\n\n  if (!agent) {\n    throw new Error(`Agent with ID ${agentId} not found`);\n  }\n\n  const [instructions, tools] = await Promise.all([\n    agent.getInstructions({ runtimeContext }),\n    agent.getTools({ runtimeContext }),\n  ]);\n\n  // Extract agent information to create the AgentCard\n  const agentCard: AgentCard = {\n    name: agent.id || agentId,\n    description: convertInstructionsToString(instructions),\n    url: executionUrl,\n    provider,\n    version,\n    capabilities: {\n      streaming: true, // All agents support streaming\n      pushNotifications: false,\n      stateTransitionHistory: false,\n    },\n    defaultInputModes: ['text'],\n    defaultOutputModes: ['text'],\n    // Convert agent tools to skills format for A2A protocol\n    skills: Object.entries(tools).map(([toolId, tool]) => ({\n      id: toolId,\n      name: toolId,\n      description: tool.description || `Tool: ${toolId}`,\n      // Optional fields\n      tags: ['tool'],\n    })),\n  };\n\n  return agentCard;\n}\n\nfunction validateMessageSendParams(params: MessageSendParams) {\n  try {\n    messageSendParamsSchema.parse(params);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw MastraA2AError.invalidParams((error as z.ZodError).errors[0]!.message);\n    }\n\n    throw error;\n  }\n}\n\nexport async function handleMessageSend({\n  requestId,\n  params,\n  taskStore,\n  agent,\n  agentId,\n  logger,\n  runtimeContext,\n}: {\n  requestId: string;\n  params: MessageSendParams;\n  taskStore: InMemoryTaskStore;\n  agent: Agent;\n  agentId: string;\n  logger?: IMastraLogger;\n  runtimeContext: RuntimeContext;\n}) {\n  validateMessageSendParams(params);\n\n  const { message, metadata } = params;\n  const { contextId } = message;\n  const taskId = message.taskId || crypto.randomUUID();\n\n  // Load or create task\n  let currentData = await loadOrCreateTask({\n    taskId,\n    taskStore,\n    agentId,\n    message,\n    contextId,\n    metadata,\n  });\n\n  // Use the new TaskContext definition, passing history\n  const context = createTaskContext({\n    task: currentData,\n    userMessage: message,\n    history: currentData.history || [],\n    activeCancellations: taskStore.activeCancellations,\n  });\n\n  try {\n    const { text } = await agent.generate([convertToCoreMessage(message)], {\n      runId: taskId,\n      runtimeContext,\n    });\n\n    currentData = applyUpdateToTask(currentData, {\n      state: 'completed',\n      message: {\n        messageId: crypto.randomUUID(),\n        role: 'agent',\n        parts: [\n          {\n            kind: 'text',\n            text: text,\n          },\n        ],\n        kind: 'message',\n      },\n    });\n\n    await taskStore.save({ agentId, data: currentData });\n    context.task = currentData;\n  } catch (handlerError) {\n    // If handler throws, apply 'failed' status, save, and rethrow\n    const failureStatusUpdate: Omit<TaskStatus, 'timestamp'> = {\n      state: 'failed',\n      message: {\n        messageId: crypto.randomUUID(),\n        role: 'agent',\n        parts: [\n          {\n            kind: 'text',\n            text: `Handler failed: ${handlerError instanceof Error ? handlerError.message : String(handlerError)}`,\n          },\n        ],\n        kind: 'message',\n      },\n    };\n    currentData = applyUpdateToTask(currentData, failureStatusUpdate);\n\n    try {\n      await taskStore.save({ agentId, data: currentData });\n    } catch (saveError) {\n      // @ts-expect-error saveError is an unknown error\n      logger?.error(`Failed to save task ${currentData.id} after handler error:`, saveError?.message);\n    }\n\n    return normalizeError(handlerError, requestId, currentData.id, logger); // Rethrow original error\n  }\n\n  // The loop finished, send the final task state\n  return createSuccessResponse(requestId, currentData);\n}\n\nexport async function handleTaskGet({\n  requestId,\n  taskStore,\n  agentId,\n  taskId,\n}: {\n  requestId: string;\n  taskStore: InMemoryTaskStore;\n  agentId: string;\n  taskId: string;\n}) {\n  const task = await taskStore.load({ agentId, taskId });\n\n  if (!task) {\n    throw MastraA2AError.taskNotFound(taskId);\n  }\n\n  return createSuccessResponse(requestId, task);\n}\n\nexport async function* handleMessageStream({\n  requestId,\n  params,\n  taskStore,\n  agent,\n  agentId,\n  logger,\n  runtimeContext,\n}: {\n  requestId: string;\n  params: MessageSendParams;\n  taskStore: InMemoryTaskStore;\n  agent: Agent;\n  agentId: string;\n  logger?: IMastraLogger;\n  runtimeContext: RuntimeContext;\n}) {\n  yield createSuccessResponse(requestId, {\n    state: 'working',\n    message: {\n      messageId: crypto.randomUUID(),\n      kind: 'message',\n      role: 'agent',\n      parts: [{ kind: 'text', text: 'Generating response...' }],\n    },\n  });\n\n  let result;\n  try {\n    result = await handleMessageSend({\n      requestId,\n      params,\n      taskStore,\n      agent,\n      agentId,\n      runtimeContext,\n      logger,\n    });\n  } catch (err) {\n    if (!(err instanceof MastraA2AError)) {\n      throw err;\n    }\n\n    result = createErrorResponse(requestId, err.toJSONRPCError());\n  }\n\n  yield result;\n}\n\nexport async function handleTaskCancel({\n  requestId,\n  taskStore,\n  agentId,\n  taskId,\n  logger,\n}: {\n  requestId: string;\n  taskStore: InMemoryTaskStore;\n  agentId: string;\n  taskId: string;\n  logger?: IMastraLogger;\n}) {\n  // Load task and history\n  let data = await taskStore.load({\n    agentId,\n    taskId,\n  });\n\n  if (!data) {\n    throw MastraA2AError.taskNotFound(taskId);\n  }\n\n  // Check if cancelable (not already in a final state)\n  const finalStates: TaskState[] = ['completed', 'failed', 'canceled'];\n\n  if (finalStates.includes(data.status.state)) {\n    logger?.info(`Task ${taskId} already in final state ${data.status.state}, cannot cancel.`);\n    return createSuccessResponse(requestId, data);\n  }\n\n  // Signal cancellation\n  taskStore.activeCancellations.add(taskId);\n\n  // Apply 'canceled' state update\n  const cancelUpdate: Omit<TaskStatus, 'timestamp'> = {\n    state: 'canceled',\n    message: {\n      role: 'agent',\n      parts: [{ kind: 'text', text: 'Task cancelled by request.' }],\n      kind: 'message',\n      messageId: crypto.randomUUID(),\n    },\n  };\n\n  data = applyUpdateToTask(data, cancelUpdate);\n\n  // Save the updated state\n  await taskStore.save({ agentId, data });\n\n  // Remove from active cancellations *after* saving\n  taskStore.activeCancellations.delete(taskId);\n\n  // Return the updated task object\n  return createSuccessResponse(requestId, data);\n}\n\nexport async function getAgentExecutionHandler({\n  requestId,\n  mastra,\n  agentId,\n  runtimeContext,\n  method,\n  params,\n  taskStore,\n  logger,\n}: Context & {\n  requestId: string;\n  runtimeContext: RuntimeContext;\n  agentId: string;\n  method: 'message/send' | 'message/stream' | 'tasks/get' | 'tasks/cancel';\n  params: MessageSendParams | TaskQueryParams | TaskIdParams;\n  taskStore: InMemoryTaskStore;\n  logger?: IMastraLogger;\n}): Promise<any> {\n  const agent = mastra.getAgent(agentId);\n\n  let taskId: string | undefined; // For error context\n\n  try {\n    // Attempt to get task ID early for error context. Cast params to any to access id.\n    // Proper validation happens within specific handlers.\n    taskId = 'id' in params ? params.id : params.message?.taskId || 'No task ID provided';\n\n    // 2. Route based on method\n    switch (method) {\n      case 'message/send': {\n        const result = await handleMessageSend({\n          requestId,\n          params: params as MessageSendParams,\n          taskStore,\n          agent,\n          agentId,\n          runtimeContext,\n        });\n        return result;\n      }\n      case 'message/stream':\n        const result = await handleMessageStream({\n          requestId,\n          taskStore,\n          params: params as MessageSendParams,\n          agent,\n          agentId,\n          runtimeContext,\n        });\n        return result;\n\n      case 'tasks/get': {\n        const result = await handleTaskGet({\n          requestId,\n          taskStore,\n          agentId,\n          taskId,\n        });\n\n        return result;\n      }\n      case 'tasks/cancel': {\n        const result = await handleTaskCancel({\n          requestId,\n          taskStore,\n          agentId,\n          taskId,\n        });\n\n        return result;\n      }\n      default:\n        throw MastraA2AError.methodNotFound(method);\n    }\n  } catch (error) {\n    if (error instanceof MastraA2AError && taskId && !error.taskId) {\n      error.taskId = taskId; // Add task ID context if missing\n    }\n\n    return normalizeError(error, requestId, taskId, logger);\n  }\n}\n","import { MastraA2AError } from '@mastra/core/a2a';\n\nimport type { JSONRPCError, JSONRPCResponse, Message, Part } from '@mastra/core/a2a';\nimport type { CoreMessage } from '@mastra/core/llm';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function normalizeError(\n  error: any,\n  reqId: number | string | null,\n  taskId?: string,\n  logger?: IMastraLogger,\n): JSONRPCResponse<null, unknown> {\n  let a2aError: MastraA2AError;\n  if (error instanceof MastraA2AError) {\n    a2aError = error;\n  } else if (error instanceof Error) {\n    // Generic JS error\n    a2aError = MastraA2AError.internalError(error.message, { stack: error.stack });\n  } else {\n    // Unknown error type\n    a2aError = MastraA2AError.internalError('An unknown error occurred.', error);\n  }\n\n  // Ensure Task ID context is present if possible\n  if (taskId && !a2aError.taskId) {\n    a2aError.taskId = taskId;\n  }\n\n  logger?.error(`Error processing request (Task: ${a2aError.taskId ?? 'N/A'}, ReqID: ${reqId ?? 'N/A'}):`, a2aError);\n\n  return createErrorResponse(reqId, a2aError.toJSONRPCError());\n}\n\nexport function createErrorResponse(\n  id: number | string | null,\n  error: JSONRPCError<unknown>,\n): JSONRPCResponse<null, unknown> {\n  // For errors, ID should be the same as request ID, or null if that couldn't be determined\n  return {\n    jsonrpc: '2.0',\n    id: id, // Can be null if request ID was invalid/missing\n    error: error,\n  };\n}\n\nexport function createSuccessResponse<T>(id: number | string | null, result: T): JSONRPCResponse<T> {\n  if (!id) {\n    // This shouldn't happen for methods that expect a response, but safeguard\n    throw MastraA2AError.internalError('Cannot create success response for null ID.');\n  }\n\n  return {\n    jsonrpc: '2.0',\n    id: id,\n    result: result,\n  };\n}\n\nexport function convertToCoreMessage(message: Message): CoreMessage {\n  return {\n    role: message.role === 'user' ? 'user' : 'assistant',\n    content: message.parts.map(msg => convertToCoreMessagePart(msg)),\n  };\n}\n\nfunction convertToCoreMessagePart(part: Part) {\n  switch (part.kind) {\n    case 'text':\n      return {\n        type: 'text',\n        text: part.text,\n      } as const;\n    case 'file':\n      return {\n        type: 'file',\n        data: 'uri' in part.file ? new URL(part.file.uri) : part.file.bytes,\n        mimeType: part.file.mimeType!,\n      } as const;\n    case 'data':\n      throw new Error('Data parts are not supported in core messages');\n  }\n}\n","import type {\n  Message,\n  Task,\n  TaskState,\n  TaskStatus,\n  TaskContext,\n  TaskArtifactUpdateEvent,\n  Artifact,\n} from '@mastra/core/a2a';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { InMemoryTaskStore } from './store';\n\nfunction isTaskStatusUpdate(update: TaskStatus | TaskArtifactUpdateEvent): update is Omit<TaskStatus, 'timestamp'> {\n  return 'state' in update && !('parts' in update);\n}\n\nfunction isArtifactUpdate(update: TaskStatus | TaskArtifactUpdateEvent): update is TaskArtifactUpdateEvent {\n  return 'kind' in update && update.kind === 'artifact-update';\n}\n\nexport function applyUpdateToTask(\n  current: Task,\n  update: Omit<TaskStatus, 'timestamp'> | TaskArtifactUpdateEvent,\n): Task {\n  let newTask = structuredClone(current);\n\n  if (isTaskStatusUpdate(update)) {\n    // Merge status update\n    newTask.status = {\n      ...newTask.status, // Keep existing properties if not overwritten\n      ...update, // Apply updates\n      timestamp: new Date().toISOString(),\n    };\n  } else if (isArtifactUpdate(update)) {\n    // Handle artifact update\n    if (!newTask.artifacts) {\n      newTask.artifacts = [];\n    } else {\n      // Ensure we're working with a copy of the artifacts array\n      newTask.artifacts = [...newTask.artifacts];\n    }\n\n    const artifact = update.artifact;\n    const existingIndex = newTask.artifacts.findIndex(a => a.name === artifact.name);\n    const existingArtifact = newTask.artifacts[existingIndex];\n\n    if (existingArtifact) {\n      if (update.append) {\n        // Create a deep copy for modification to avoid mutating original\n        const appendedArtifact = JSON.parse(JSON.stringify(existingArtifact)) as Artifact;\n        appendedArtifact.parts.push(...artifact.parts);\n        if (artifact.metadata) {\n          appendedArtifact.metadata = {\n            ...(appendedArtifact.metadata || {}),\n            ...artifact.metadata,\n          };\n        }\n        if (artifact.description) appendedArtifact.description = artifact.description;\n        newTask.artifacts[existingIndex] = appendedArtifact; // Replace with appended version\n      } else {\n        // Overwrite artifact at index (with a copy of the update)\n        newTask.artifacts[existingIndex] = { ...artifact };\n      }\n    } else {\n      newTask.artifacts.push({ ...artifact });\n    }\n  }\n\n  return newTask;\n}\n\nexport async function loadOrCreateTask({\n  agentId,\n  taskId,\n  taskStore,\n  message,\n  contextId,\n  metadata,\n  logger,\n}: {\n  agentId: string;\n  taskId: string;\n  taskStore: InMemoryTaskStore;\n  message: Message;\n  contextId?: string;\n  metadata?: Record<string, unknown>;\n  logger?: IMastraLogger;\n}): Promise<Task> {\n  const data = await taskStore.load({ agentId, taskId });\n\n  // Create new task if none exists\n  if (!data) {\n    const initialTask: Task = {\n      id: taskId,\n      contextId: contextId || crypto.randomUUID(),\n      status: {\n        state: 'submitted',\n        timestamp: new Date().toISOString(),\n        message: undefined,\n      },\n      artifacts: [],\n      history: [message],\n      metadata: metadata,\n      kind: 'task',\n    };\n\n    logger?.info(`[Task ${taskId}] Created new task.`);\n    await taskStore.save({ agentId, data: initialTask });\n\n    return initialTask;\n  }\n\n  // Handle existing task\n  logger?.info(`[Task ${taskId}] Loaded existing task.`);\n\n  // Add message to history and prepare updated data\n  let updatedData = data;\n  updatedData.history = [...(data.history || []), message];\n\n  // Handle state transitions\n  const { status } = data;\n  const finalStates: TaskState[] = ['completed', 'failed', 'canceled'];\n\n  if (finalStates.includes(status.state)) {\n    logger?.warn(`[Task ${taskId}] Received message for task in final state ${status.state}. Restarting.`);\n    updatedData = applyUpdateToTask(updatedData, {\n      state: 'submitted',\n      message: undefined,\n    });\n  } else if (status.state === 'input-required') {\n    logger?.info(`[Task ${taskId}] Changing state from 'input-required' to 'working'.`);\n    updatedData = applyUpdateToTask(updatedData, { state: 'working' });\n  } else if (status.state === 'working') {\n    logger?.warn(`[Task ${taskId}] Received message while already 'working'. Proceeding.`);\n  }\n\n  await taskStore.save({ agentId, data: updatedData });\n\n  return updatedData;\n}\n\nexport function createTaskContext({\n  task,\n  userMessage,\n  history,\n  activeCancellations,\n}: {\n  task: Task;\n  userMessage: Message;\n  history: Message[];\n  activeCancellations: Set<string>;\n}): TaskContext {\n  return {\n    task: structuredClone(task),\n    userMessage,\n    history: structuredClone(history),\n    isCancelled: () => activeCancellations.has(task.id),\n  };\n}\n"]}