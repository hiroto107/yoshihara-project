{"version":3,"sources":["../src/server/handlers/vector.ts"],"names":["__export","HTTPException","handleError"],"mappings":"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","file":"chunk-EP3JQDPD.cjs","sourcesContent":["import type { MastraVector, QueryResult, IndexStats } from '@mastra/core/vector';\nimport { HTTPException } from '../http-exception';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\n\ninterface VectorContext extends Context {\n  vectorName?: string;\n}\n\ninterface UpsertRequest {\n  indexName: string;\n  vectors: number[][];\n  metadata?: Record<string, any>[];\n  ids?: string[];\n}\n\ninterface CreateIndexRequest {\n  indexName: string;\n  dimension: number;\n  metric?: 'cosine' | 'euclidean' | 'dotproduct';\n}\n\ninterface QueryRequest {\n  indexName: string;\n  queryVector: number[];\n  topK?: number;\n  filter?: Record<string, any>;\n  includeVector?: boolean;\n}\n\nfunction getVector(mastra: Context['mastra'], vectorName?: string): MastraVector {\n  if (!vectorName) {\n    throw new HTTPException(400, { message: 'Vector name is required' });\n  }\n\n  const vector = mastra.getVector(vectorName);\n  if (!vector) {\n    throw new HTTPException(404, { message: `Vector store ${vectorName} not found` });\n  }\n\n  return vector;\n}\n\n// Upsert vectors\nexport async function upsertVectors({ mastra, vectorName, index }: VectorContext & { index: UpsertRequest }) {\n  try {\n    if (!index?.indexName || !index?.vectors || !Array.isArray(index.vectors)) {\n      throw new HTTPException(400, { message: 'Invalid request index. indexName and vectors array are required.' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    const result = await vector.upsert(index);\n    return { ids: result };\n  } catch (error) {\n    return handleError(error, 'Error upserting vectors');\n  }\n}\n\n// Create index\nexport async function createIndex({\n  mastra,\n  vectorName,\n  index,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & { index: CreateIndexRequest }) {\n  try {\n    const { indexName, dimension, metric } = index;\n\n    if (!indexName || typeof dimension !== 'number' || dimension <= 0) {\n      throw new HTTPException(400, {\n        message: 'Invalid request index, indexName and positive dimension number are required.',\n      });\n    }\n\n    if (metric && !['cosine', 'euclidean', 'dotproduct'].includes(metric)) {\n      throw new HTTPException(400, { message: 'Invalid metric. Must be one of: cosine, euclidean, dotproduct' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    await vector.createIndex({ indexName, dimension, metric });\n    return { success: true };\n  } catch (error) {\n    return handleError(error, 'Error creating index');\n  }\n}\n\n// Query vectors\nexport async function queryVectors({\n  mastra,\n  vectorName,\n  query,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & { query: QueryRequest }) {\n  try {\n    if (!query?.indexName || !query?.queryVector || !Array.isArray(query.queryVector)) {\n      throw new HTTPException(400, { message: 'Invalid request query. indexName and queryVector array are required.' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    const results: QueryResult[] = await vector.query(query);\n    return results;\n  } catch (error) {\n    return handleError(error, 'Error querying vectors');\n  }\n}\n\n// List indexes\nexport async function listIndexes({ mastra, vectorName }: Pick<VectorContext, 'mastra' | 'vectorName'>) {\n  try {\n    const vector = getVector(mastra, vectorName);\n\n    const indexes = await vector.listIndexes();\n    return indexes.filter(Boolean);\n  } catch (error) {\n    return handleError(error, 'Error listing indexes');\n  }\n}\n\n// Describe index\nexport async function describeIndex({\n  mastra,\n  vectorName,\n  indexName,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & { indexName?: string }) {\n  try {\n    if (!indexName) {\n      throw new HTTPException(400, { message: 'Index name is required' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    const stats: IndexStats = await vector.describeIndex({ indexName });\n\n    return {\n      dimension: stats.dimension,\n      count: stats.count,\n      metric: stats.metric?.toLowerCase(),\n    };\n  } catch (error) {\n    return handleError(error, 'Error describing index');\n  }\n}\n\n// Delete index\nexport async function deleteIndex({\n  mastra,\n  vectorName,\n  indexName,\n}: Pick<VectorContext, 'mastra' | 'vectorName'> & { indexName?: string }) {\n  try {\n    if (!indexName) {\n      throw new HTTPException(400, { message: 'Index name is required' });\n    }\n\n    const vector = getVector(mastra, vectorName);\n    await vector.deleteIndex({ indexName });\n    return { success: true };\n  } catch (error) {\n    return handleError(error, 'Error deleting index');\n  }\n}\n"]}