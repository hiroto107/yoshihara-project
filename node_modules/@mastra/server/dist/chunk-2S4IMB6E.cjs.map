{"version":3,"sources":["../src/server/handlers/observability.ts"],"names":["__export","HTTPException","handleError","scoreTraces"],"mappings":"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","file":"chunk-2S4IMB6E.cjs","sourcesContent":["import type { AITracesPaginatedArg, StoragePagination } from '@mastra/core';\nimport { scoreTraces } from '@mastra/core/scores/scoreTraces';\nimport { HTTPException } from '../http-exception';\nimport type { Context } from '../types';\nimport { handleError } from './error';\n\ninterface ObservabilityContext extends Context {\n  traceId?: string;\n  body?: AITracesPaginatedArg;\n}\n\ninterface ScoreTracesContext extends Context {\n  body?: {\n    scorerName: string;\n    targets: Array<{\n      traceId: string;\n      spanId?: string;\n    }>;\n  };\n}\n\n/**\n * Get a complete AI trace by trace ID\n * Returns all spans in the trace with their parent-child relationships\n */\nexport async function getAITraceHandler({ mastra, traceId }: ObservabilityContext & { traceId: string }) {\n  try {\n    if (!traceId) {\n      throw new HTTPException(400, { message: 'Trace ID is required' });\n    }\n\n    const storage = mastra.getStorage();\n    if (!storage) {\n      throw new HTTPException(500, { message: 'Storage is not available' });\n    }\n\n    const trace = await storage.getAITrace(traceId);\n\n    if (!trace) {\n      throw new HTTPException(404, { message: `Trace with ID '${traceId}' not found` });\n    }\n\n    return trace;\n  } catch (error) {\n    handleError(error, 'Error getting AI trace');\n  }\n}\n\n/**\n * Get paginated AI traces with filtering and pagination\n * Returns only root spans (parent spans) for pagination, not child spans\n */\nexport async function getAITracesPaginatedHandler({ mastra, body }: ObservabilityContext) {\n  try {\n    const storage = mastra.getStorage();\n    if (!storage) {\n      throw new HTTPException(500, { message: 'Storage is not available' });\n    }\n\n    if (!body) {\n      throw new HTTPException(400, { message: 'Request body is required' });\n    }\n\n    const { filters, pagination } = body;\n\n    if (pagination?.page && pagination.page < 0) {\n      throw new HTTPException(400, { message: 'Page must be a non-negative integer' });\n    }\n\n    if (pagination?.perPage && pagination.perPage < 0) {\n      throw new HTTPException(400, { message: 'Per page must be a non-negative integer' });\n    }\n\n    if (pagination?.dateRange) {\n      const { start, end } = pagination.dateRange;\n\n      if (start && !(start instanceof Date)) {\n        throw new HTTPException(400, { message: 'Invalid date format in date range' });\n      }\n\n      if (end && !(end instanceof Date)) {\n        throw new HTTPException(400, { message: 'Invalid date format in date range' });\n      }\n    }\n\n    return storage.getAITracesPaginated({\n      pagination,\n      filters,\n    });\n  } catch (error) {\n    handleError(error, 'Error getting AI traces paginated');\n  }\n}\n\n/**\n * Score traces using a specified scorer\n * Fire-and-forget approach - returns immediately while scoring runs in background\n */\nexport async function scoreTracesHandler({ mastra, body }: ScoreTracesContext) {\n  try {\n    if (!body) {\n      throw new HTTPException(400, { message: 'Request body is required' });\n    }\n\n    const { scorerName, targets } = body;\n\n    if (!scorerName) {\n      throw new HTTPException(400, { message: 'Scorer Name is required' });\n    }\n\n    if (!targets || targets.length === 0) {\n      throw new HTTPException(400, { message: 'At least one target is required' });\n    }\n\n    const storage = mastra.getStorage();\n    if (!storage) {\n      throw new HTTPException(500, { message: 'Storage is not available' });\n    }\n\n    const scorer = mastra.getScorerByName(scorerName);\n    if (!scorer) {\n      throw new HTTPException(404, { message: `Scorer '${scorerName}' not found` });\n    }\n\n    const logger = mastra.getLogger();\n    scoreTraces({\n      scorerName,\n      targets,\n      mastra,\n    }).catch(error => {\n      logger?.error(`Background trace scoring failed: ${error.message}`, error);\n    });\n\n    // Return immediate response\n    return {\n      status: 'success',\n      message: `Scoring started for ${targets.length} ${targets.length === 1 ? 'trace' : 'traces'}`,\n      traceCount: targets.length,\n    };\n  } catch (error) {\n    handleError(error, 'Error processing trace scoring');\n  }\n}\n\nexport async function getScoresBySpan({\n  mastra,\n  traceId,\n  spanId,\n  pagination,\n}: Context & { traceId: string; spanId: string; pagination: StoragePagination }) {\n  try {\n    const storage = mastra.getStorage();\n    if (!storage) {\n      throw new HTTPException(500, { message: 'Storage is not available' });\n    }\n\n    if (!traceId || !spanId) {\n      throw new HTTPException(400, { message: 'Trace ID and span ID are required' });\n    }\n\n    return await storage.getScoresBySpan({ traceId, spanId, pagination });\n  } catch (error) {\n    return handleError(error, 'Error getting scores by span');\n  }\n}\n"]}