'use strict';

var chunkG4PUALCE_cjs = require('./chunk-G4PUALCE.cjs');
var chunkGU4EWMZB_cjs = require('./chunk-GU4EWMZB.cjs');
var chunkRE4RPXT2_cjs = require('./chunk-RE4RPXT2.cjs');
var chunk7NADHFD2_cjs = require('./chunk-7NADHFD2.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var tools = require('@mastra/core/tools');
var zodToJson = require('@mastra/core/utils/zod-to-json');

// src/server/handlers/tools.ts
var tools_exports = {};
chunkO7I5CWRX_cjs.__export(tools_exports, {
  executeAgentToolHandler: () => executeAgentToolHandler,
  executeToolHandler: () => executeToolHandler,
  getAgentToolHandler: () => getAgentToolHandler,
  getToolByIdHandler: () => getToolByIdHandler,
  getToolsHandler: () => getToolsHandler
});
async function getToolsHandler({ tools }) {
  try {
    if (!tools) {
      return {};
    }
    const serializedTools = Object.entries(tools).reduce(
      (acc, [id, _tool]) => {
        const tool = _tool;
        acc[id] = {
          ...tool,
          inputSchema: tool.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
          outputSchema: tool.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0
        };
        return acc;
      },
      {}
    );
    return serializedTools;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting tools");
  }
}
async function getToolByIdHandler({ tools, toolId }) {
  try {
    const tool = Object.values(tools || {}).find((tool2) => tool2.id === toolId);
    if (!tool) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Tool not found" });
    }
    const serializedTool = {
      ...tool,
      inputSchema: tool.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
      outputSchema: tool.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0
    };
    return serializedTool;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting tool");
  }
}
function executeToolHandler(tools$1) {
  return async ({
    mastra,
    runId,
    toolId,
    data,
    runtimeContext
  }) => {
    try {
      if (!toolId) {
        throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Tool ID is required" });
      }
      const tool = Object.values(tools$1 || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Tool is not executable" });
      }
      chunkG4PUALCE_cjs.validateBody({ data });
      if (tools.isVercelTool(tool)) {
        const result2 = await tool.execute(data);
        return result2;
      }
      const result = await tool.execute({
        context: data,
        mastra,
        runId,
        runtimeContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 },
        suspend: async () => {
        }
      });
      return result;
    } catch (error) {
      return chunkRE4RPXT2_cjs.handleError(error, "Error executing tool");
    }
  };
}
async function getAgentToolHandler({
  mastra,
  agentId,
  toolId,
  runtimeContext
}) {
  try {
    const agent = agentId ? mastra.getAgent(agentId) : null;
    if (!agent) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Agent not found" });
    }
    const agentTools = await agent.getTools({ runtimeContext });
    const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
    if (!tool) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Tool not found" });
    }
    const serializedTool = {
      ...tool,
      inputSchema: tool.inputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
      outputSchema: tool.outputSchema ? chunkGU4EWMZB_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0
    };
    return serializedTool;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error getting agent tool");
  }
}
async function executeAgentToolHandler({
  mastra,
  agentId,
  toolId,
  data,
  runtimeContext
}) {
  try {
    const agent = agentId ? mastra.getAgent(agentId) : null;
    if (!agent) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Tool not found" });
    }
    const agentTools = await agent.getTools({ runtimeContext });
    const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
    if (!tool) {
      throw new chunk7NADHFD2_cjs.HTTPException(404, { message: "Tool not found" });
    }
    if (!tool?.execute) {
      throw new chunk7NADHFD2_cjs.HTTPException(400, { message: "Tool is not executable" });
    }
    const result = await tool.execute({
      context: data,
      runtimeContext,
      mastra,
      runId: agentId,
      // TODO: Pass proper tracing context when server API supports tracing
      tracingContext: { currentSpan: void 0 },
      suspend: async () => {
      }
    });
    return result;
  } catch (error) {
    return chunkRE4RPXT2_cjs.handleError(error, "Error executing tool");
  }
}

exports.executeAgentToolHandler = executeAgentToolHandler;
exports.executeToolHandler = executeToolHandler;
exports.getAgentToolHandler = getAgentToolHandler;
exports.getToolByIdHandler = getToolByIdHandler;
exports.getToolsHandler = getToolsHandler;
exports.tools_exports = tools_exports;
//# sourceMappingURL=chunk-TRGAMKHX.cjs.map
//# sourceMappingURL=chunk-TRGAMKHX.cjs.map