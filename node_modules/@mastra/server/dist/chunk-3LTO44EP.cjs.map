{"version":3,"sources":["../src/server/handlers/memory.ts"],"names":["__export","HTTPException","handleError","validateBody","convertMessages","generateEmptyFromSchema"],"mappings":";;;;;;;;;;AAAA,IAAA,cAAA,GAAA;AAAAA,0BAAA,CAAA,cAAA,EAAA;AAAA,EAAA,mBAAA,EAAA,MAAA,mBAAA;AAAA,EAAA,qBAAA,EAAA,MAAA,qBAAA;AAAA,EAAA,mBAAA,EAAA,MAAA,mBAAA;AAAA,EAAA,sBAAA,EAAA,MAAA,sBAAA;AAAA,EAAA,sBAAA,EAAA,MAAA,sBAAA;AAAA,EAAA,kBAAA,EAAA,MAAA,kBAAA;AAAA,EAAA,2BAAA,EAAA,MAAA,2BAAA;AAAA,EAAA,oBAAA,EAAA,MAAA,oBAAA;AAAA,EAAA,iBAAA,EAAA,MAAA,iBAAA;AAAA,EAAA,0BAAA,EAAA,MAAA,0BAAA;AAAA,EAAA,uBAAA,EAAA,MAAA,uBAAA;AAAA,EAAA,mBAAA,EAAA,MAAA,mBAAA;AAAA,EAAA,mBAAA,EAAA,MAAA,mBAAA;AAAA,EAAA,mBAAA,EAAA,MAAA,mBAAA;AAAA,EAAA,0BAAA,EAAA,MAAA;AAAA,CAAA,CAAA;AAkBA,eAAe,oBAAA,CAAqB;AAAA,EAClC,MAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA,EAA2G;AACzG,EAAA,MAAM,KAAA,GAAQ,OAAA,GAAU,MAAA,CAAO,QAAA,CAAS,OAAO,CAAA,GAAI,IAAA;AACnD,EAAA,IAAI,OAAA,IAAW,CAAC,KAAA,EAAO;AACrB,IAAA,MAAM,IAAIC,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,mBAAmB,CAAA;AAAA,EAC7D;AAEA,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,OACG,MAAM,OAAO,SAAA,CAAU;AAAA,MACtB;AAAA,KACD,CAAA,IAAM,MAAA,CAAO,SAAA,EAAU;AAAA,EAE5B;AAEA,EAAA,OAAO,OAAO,SAAA,EAAU;AAC1B;AAGA,eAAsB,sBAAA,CAAuB;AAAA,EAC3C,MAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA,EAAiE;AAC/D,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,OAAO,EAAE,QAAQ,KAAA,EAAM;AAAA,IACzB;AAEA,IAAA,OAAO,EAAE,QAAQ,IAAA,EAAK;AAAA,EACxB,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,6BAA6B,CAAA;AAAA,EACzD;AACF;AAEA,eAAsB,sBAAA,CAAuB;AAAA,EAC3C,MAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA,EAAiE;AAC/D,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAGA,IAAA,MAAM,MAAA,GAAS,MAAA,CAAO,qBAAA,CAAsB,EAAE,CAAA;AAE9C,IAAA,OAAO,EAAE,MAAA,EAAO;AAAA,EAClB,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,oCAAoC,CAAA;AAAA,EAChE;AACF;AAEA,eAAsB,iBAAA,CAAkB;AAAA,EACtC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,UAAA;AAAA,EACA,cAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA,EAAoG;AAClG,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAAE,8BAAA,CAAa,EAAE,YAAY,CAAA;AAE3B,IAAA,MAAM,OAAA,GAAU,MAAM,MAAA,CAAO,sBAAA,CAAuB;AAAA,MAClD,UAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACD,CAAA;AACD,IAAA,OAAO,OAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOD,6BAAA,CAAY,OAAO,uBAAuB,CAAA;AAAA,EACnD;AACF;AAEA,eAAsB,0BAAA,CAA2B;AAAA,EAC/C,MAAA;AAAA,EACA,OAAA;AAAA,EACA,UAAA;AAAA,EACA,cAAA;AAAA,EACA,IAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA,EAGuB;AACrB,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAAE,8BAAA,CAAa,EAAE,YAAY,CAAA;AAE3B,IAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,+BAAA,CAAgC;AAAA,MAC1D,UAAA;AAAA,MACA,IAAA;AAAA,MACA,OAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACD,CAAA;AACD,IAAA,OAAO,MAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOD,6BAAA,CAAY,OAAO,iCAAiC,CAAA;AAAA,EAC7D;AACF;AAEA,eAAsB,oBAAA,CAAqB;AAAA,EACzC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA;AACF,CAAA,EAA8E;AAC5E,EAAA,IAAI;AACF,IAAAC,8BAAA,CAAa,EAAE,UAAU,CAAA;AAEzB,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAC7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAqB,CAAA;AACjE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,OAAO,MAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,sBAAsB,CAAA;AAAA,EAClD;AACF;AAEA,eAAsB,mBAAA,CAAoB;AAAA,EACxC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,IAAA;AAAA,EACA;AACF,CAAA,EAIG;AACD,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAA,IAAI,CAAC,MAAM,QAAA,EAAU;AACnB,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,yBAAyB,CAAA;AAAA,IACnE;AAEA,IAAA,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,IAAA,CAAK,QAAQ,CAAA,EAAG;AACjC,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,+BAA+B,CAAA;AAAA,IACzE;AAGA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,CAAA,OAAA,KAAW,CAAC,OAAA,CAAQ,QAAA,IAAY,CAAC,OAAA,CAAQ,UAAU,CAAA;AAChG,IAAA,IAAI,eAAA,CAAgB,SAAS,CAAA,EAAG;AAC9B,MAAA,MAAM,IAAIA,gCAAc,GAAA,EAAK;AAAA,QAC3B,OAAA,EAAS,CAAA,6DAAA,EAAgE,eAAA,CAAgB,MAAM,CAAA,oBAAA;AAAA,OAChG,CAAA;AAAA,IACH;AAEA,IAAA,MAAM,iBAAA,GAAoB,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,CAAA,OAAA,MAAY;AAAA,MACtD,GAAG,OAAA;AAAA,MACH,EAAA,EAAI,OAAA,CAAQ,EAAA,IAAM,MAAA,CAAO,UAAA,EAAW;AAAA,MACpC,SAAA,EAAW,QAAQ,SAAA,GAAY,IAAI,KAAK,OAAA,CAAQ,SAAS,CAAA,mBAAI,IAAI,IAAA;AAAK,KACxE,CAAE,CAAA;AAEF,IAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,YAAA,CAAa,EAAE,UAAU,iBAAA,EAAmB,YAAA,EAAc,EAAC,EAAG,CAAA;AAC1F,IAAA,OAAO,MAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,uBAAuB,CAAA;AAAA,EACnD;AACF;AAEA,eAAsB,mBAAA,CAAoB;AAAA,EACxC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,IAAA;AAAA,EACA;AACF,CAAA,EAEG;AACD,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAAE,8BAAA,CAAa,EAAE,UAAA,EAAY,IAAA,EAAM,UAAA,EAAY,CAAA;AAE7C,IAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,YAAA,CAAa;AAAA,MACvC,YAAY,IAAA,EAAM,UAAA;AAAA,MAClB,OAAO,IAAA,EAAM,KAAA;AAAA,MACb,UAAU,IAAA,EAAM,QAAA;AAAA,MAChB,UAAU,IAAA,EAAM;AAAA,KACjB,CAAA;AACD,IAAA,OAAO,MAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOD,6BAAA,CAAY,OAAO,+BAA+B,CAAA;AAAA,EAC3D;AACF;AAEA,eAAsB,mBAAA,CAAoB;AAAA,EACxC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,IAAA;AAAA,EACA;AACF,CAAA,EAEG;AACD,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,MAAM,EAAE,KAAA,EAAO,QAAA,EAAU,UAAA,EAAW,GAAI,IAAA;AACxC,IAAA,MAAM,SAAA,uBAAgB,IAAA,EAAK;AAE3B,IAAAE,8BAAA,CAAa,EAAE,UAAU,CAAA;AAEzB,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAqB,CAAA;AACjE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,MAAM,aAAA,GAAgB;AAAA,MACpB,GAAG,MAAA;AAAA,MACH,KAAA,EAAO,SAAS,MAAA,CAAO,KAAA;AAAA,MACvB,QAAA,EAAU,YAAY,MAAA,CAAO,QAAA;AAAA,MAC7B,UAAA,EAAY,cAAc,MAAA,CAAO,UAAA;AAAA,MACjC,WAAW,MAAA,CAAO,SAAA;AAAA,MAClB;AAAA,KACF;AAEA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,WAAW,EAAE,MAAA,EAAQ,eAAe,CAAA;AAChE,IAAA,OAAO,MAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,uBAAuB,CAAA;AAAA,EACnD;AACF;AAEA,eAAsB,mBAAA,CAAoB;AAAA,EACxC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA;AACF,CAAA,EAA8E;AAC5E,EAAA,IAAI;AACF,IAAAC,8BAAA,CAAa,EAAE,UAAU,CAAA;AAEzB,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAC7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAqB,CAAA;AACjE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,MAAM,MAAA,CAAO,aAAa,QAAS,CAAA;AACnC,IAAA,OAAO,EAAE,QAAQ,gBAAA,EAAiB;AAAA,EACpC,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,uBAAuB,CAAA;AAAA,EACnD;AACF;AAEA,eAAsB,2BAAA,CAA4B;AAAA,EAChD,MAAA;AAAA,EACA,QAAA;AAAA,EACA,UAAA;AAAA,EACA,QAAA;AAAA,EACA;AACF,CAAA,EAA0D;AACxD,EAAA,IAAI;AACF,IAAAC,8BAAA,CAAa,EAAE,UAAU,CAAA;AAEzB,IAAA,MAAM,OAAA,GAAU,OAAO,UAAA,EAAW;AAElC,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,8BAA8B,CAAA;AAAA,IACxE;AAEA,IAAA,MAAM,SAAS,MAAM,OAAA,CAAQ,aAAA,CAAc,EAAE,UAAqB,CAAA;AAElE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,MAAM,MAAA,GAAS,MAAM,OAAA,CAAQ,oBAAA,CAAqB,EAAE,QAAA,EAAqB,UAAA,EAAY,QAAA,EAAU,MAAA,EAAQ,CAAA;AACvG,IAAA,OAAO,MAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,wBAAwB,CAAA;AAAA,EACpD;AACF;AAEA,eAAsB,kBAAA,CAAmB;AAAA,EACvC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,KAAA;AAAA,EACA;AACF,CAAA,EAEG;AACD,EAAA,IAAI,KAAA,KAAU,WAAc,CAAC,MAAA,CAAO,UAAU,KAAK,CAAA,IAAK,SAAS,CAAA,CAAA,EAAI;AACnE,IAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6CAA6C,CAAA;AAAA,EACvF;AACA,EAAA,IAAI;AACF,IAAAE,8BAAA,CAAa,EAAE,UAAU,CAAA;AAEzB,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAE7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAEA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAqB,CAAA;AACjE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,KAAA,CAAM;AAAA,MAChC,QAAA;AAAA,MACA,GAAI,KAAA,IAAS,EAAE,UAAU,EAAE,IAAA,EAAM,OAAM;AAAE,KAC1C,CAAA;AACD,IAAA,MAAM,aAAaG,qBAAA,CAAgB,MAAA,CAAO,QAAQ,CAAA,CAAE,GAAG,SAAS,CAAA;AAChE,IAAA,OAAO,EAAE,QAAA,EAAU,MAAA,CAAO,UAAU,UAAA,EAAY,cAAA,EAAgB,OAAO,UAAA,EAAW;AAAA,EACpF,SAAS,KAAA,EAAO;AACd,IAAA,OAAOF,6BAAA,CAAY,OAAO,wBAAwB,CAAA;AAAA,EACpD;AACF;AAOA,eAAsB,uBAAA,CAAwB;AAAA,EAC5C,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,UAAA;AAAA,EACA,cAAA;AAAA,EACA;AACF,CAAA,EAGG;AACD,EAAA,IAAI;AACF,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAC7E,IAAAC,8BAAA,CAAa,EAAE,UAAU,CAAA;AACzB,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AACA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAqB,CAAA;AACjE,IAAA,MAAM,YAAA,GAAe,CAAC,CAAC,MAAA;AACvB,IAAA,MAAM,WAAW,MAAM,MAAA,CAAO,wBAAA,CAAyB,EAAE,cAAc,CAAA;AACvE,IAAA,MAAM,qBAAA,GACJ,QAAA,EAAU,MAAA,KAAW,MAAA,GACjB,EAAE,GAAG,QAAA,EAAU,OAAA,EAAS,IAAA,CAAK,UAAUI,6BAAA,CAAwB,QAAA,CAAS,OAAO,CAAC,GAAE,GAClF,QAAA;AACN,IAAA,MAAM,aAAA,GAAgB,MAAM,MAAA,CAAO,gBAAA,CAAiB,EAAE,QAAA,EAAqB,UAAA,EAAY,cAAc,CAAA;AACrG,IAAA,MAAM,MAAA,GAAS,MAAA,CAAO,qBAAA,CAAsB,YAAA,IAAgB,EAAE,CAAA;AAC9D,IAAA,MAAM,SAAS,MAAA,CAAO,aAAA,EAAe,KAAA,KAAU,UAAA,IAAc,aAAa,UAAA,GAAa,QAAA;AACvF,IAAA,OAAO,EAAE,aAAA,EAAe,MAAA,EAAQ,qBAAA,EAAuB,YAAA,EAAa;AAAA,EACtE,SAAS,KAAA,EAAO;AACd,IAAA,OAAOH,6BAAA,CAAY,OAAO,8BAA8B,CAAA;AAAA,EAC1D;AACF;AAOA,eAAsB,0BAAA,CAA2B;AAAA,EAC/C,MAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,IAAA;AAAA,EACA;AACF,CAAA,EAEG;AACD,EAAA,IAAI;AACF,IAAAC,8BAAA,CAAa,EAAE,UAAU,CAAA;AACzB,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAC7E,IAAA,MAAM,EAAE,UAAA,EAAY,YAAA,EAAc,aAAA,EAAc,GAAI,IAAA;AACpD,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AACA,IAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAqB,CAAA;AACjE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,IAC9D;AAEA,IAAA,MAAM,OAAO,mBAAA,CAAoB,EAAE,UAAqB,UAAA,EAAY,aAAA,EAAe,cAAc,CAAA;AACjG,IAAA,OAAO,EAAE,SAAS,IAAA,EAAK;AAAA,EACzB,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,+BAA+B,CAAA;AAAA,EAC3D;AACF;AA4BA,eAAsB,qBAAA,CAAsB;AAAA,EAC1C,MAAA;AAAA,EACA,OAAA;AAAA,EACA,UAAA;AAAA,EACA;AACF,CAAA,EAEG;AACD,EAAA,IAAI;AACF,IAAA,IAAI,UAAA,KAAe,MAAA,IAAa,UAAA,KAAe,IAAA,EAAM;AACnD,MAAA,MAAM,IAAID,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,0BAA0B,CAAA;AAAA,IACpE;AAEA,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAC7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAGA,IAAA,MAAM,MAAA,CAAO,eAAe,UAAiB,CAAA;AAG7C,IAAA,IAAI,KAAA,GAAQ,CAAA;AACZ,IAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,UAAU,CAAA,EAAG;AAC7B,MAAA,KAAA,GAAQ,UAAA,CAAW,MAAA;AAAA,IACrB;AAEA,IAAA,OAAO,EAAE,OAAA,EAAS,IAAA,EAAM,OAAA,EAAS,CAAA,EAAG,KAAK,CAAA,QAAA,EAAW,KAAA,KAAU,CAAA,GAAI,EAAA,GAAK,GAAG,CAAA,qBAAA,CAAA,EAAwB;AAAA,EACpG,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,yBAAyB,CAAA;AAAA,EACrD;AACF;AAEA,eAAsB,mBAAA,CAAoB;AAAA,EACxC,MAAA;AAAA,EACA,OAAA;AAAA,EACA,WAAA;AAAA,EACA,UAAA;AAAA,EACA,QAAA;AAAA,EACA,KAAA,GAAQ,EAAA;AAAA,EACR,cAAA;AAAA,EACA;AACF,CAAA,EAM6D;AAC3D,EAAA,IAAI;AACF,IAAAC,8BAAA,CAAa,EAAE,WAAA,EAAa,UAAA,EAAY,CAAA;AAExC,IAAA,MAAM,SAAS,MAAM,oBAAA,CAAqB,EAAE,MAAA,EAAQ,OAAA,EAAS,gBAAgB,CAAA;AAC7E,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAIF,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,6BAA6B,CAAA;AAAA,IACvE;AAGA,IAAA,MAAM,MAAA,GAAS,MAAA,CAAO,qBAAA,CAAsB,YAAA,IAAgB,EAAE,CAAA;AAC9D,IAAA,MAAM,iBAAA,GAAoB,CAAC,CAAC,MAAA,EAAQ,cAAA;AACpC,IAAA,MAAM,gBAAgB,OAAO,MAAA,EAAQ,mBAAmB,QAAA,IAAY,MAAA,EAAQ,gBAAgB,KAAA,KAAU,UAAA;AAGtG,IAAA,IAAI,QAAA,IAAY,CAAC,aAAA,EAAe;AAC9B,MAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAU,CAAA;AACtD,MAAA,IAAI,CAAC,MAAA,EAAQ;AACX,QAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oBAAoB,CAAA;AAAA,MAC9D;AACA,MAAA,IAAI,MAAA,CAAO,eAAe,UAAA,EAAY;AACpC,QAAA,MAAM,IAAIA,+BAAA,CAAc,GAAA,EAAK,EAAE,OAAA,EAAS,oDAAoD,CAAA;AAAA,MAC9F;AAAA,IACF;AAEA,IAAA,MAAM,gBAAgC,EAAC;AACvC,IAAA,MAAM,UAAA,uBAAiB,GAAA,EAAqB;AAG5C,IAAA,IAAI,QAAA,IAAY,CAAC,aAAA,EAAe;AAC9B,MAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAU,CAAA;AACtD,MAAA,IAAI,CAAC,MAAA,EAAQ;AAEX,QAAA,OAAO;AAAA,UACL,SAAS,EAAC;AAAA,UACV,KAAA,EAAO,CAAA;AAAA,UACP,KAAA,EAAO,WAAA;AAAA,UACP,WAAA,EAAa,QAAA;AAAA,UACb,UAAA,EAAY,oBAAoB,UAAA,GAAa;AAAA,SAC/C;AAAA,MACF;AAAA,IACF;AAGA,IAAA,IAAI,CAAC,YAAY,aAAA,EAAe;AAE9B,MAAA,MAAM,UAAU,MAAM,MAAA,CAAO,sBAAA,CAAuB,EAAE,YAAY,CAAA;AAGlE,MAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACxB,QAAA,OAAO;AAAA,UACL,SAAS,EAAC;AAAA,UACV,KAAA,EAAO,CAAA;AAAA,UACP,KAAA,EAAO,WAAA;AAAA,UACP,WAAA,EAAa,UAAA;AAAA,UACb,UAAA,EAAY,oBAAoB,UAAA,GAAa;AAAA,SAC/C;AAAA,MACF;AAEA,MAAA,KAAA,MAAW,UAAU,OAAA,EAAS;AAE5B,QAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,gBAAA,CAAiB;AAAA,UAC3C,UAAU,MAAA,CAAO,EAAA;AAAA,UACjB,UAAA;AAAA,UACA,mBAAA,EAAqB,WAAA;AAAA,UACrB;AAAA,SACD,CAAA;AAGD,QAAA,MAAM,cAAA,GAAA,CAAkB,MAAM,MAAA,CAAO,KAAA,CAAM,EAAE,QAAA,EAAU,MAAA,CAAO,EAAA,EAAI,CAAA,EAAG,UAAA;AAGrE,QAAA,MAAA,CAAO,UAAA,CAAW,QAAQ,CAAA,GAAA,KAAO;AAC/B,UAAA,IAAI,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA,EAAG;AAC5B,UAAA,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,IAAI,CAAA;AAE3B,UAAA,MAAM,UACJ,GAAA,CAAI,OAAA,CAAQ,WAAW,GAAA,CAAI,OAAA,CAAQ,OAAO,GAAA,CAAI,CAAA,CAAA,KAAM,CAAA,CAAE,IAAA,KAAS,SAAS,CAAA,CAAE,IAAA,GAAO,EAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA,IAAK,EAAA;AAErG,UAAA,IAAI,CAAC,iBAAA,IAAqB,CAAC,OAAA,CAAQ,WAAA,GAAc,QAAA,CAAS,WAAA,CAAY,WAAA,EAAa,CAAA,EAAG;AACpF,YAAA;AAAA,UACF;AAEA,UAAA,MAAM,eAAe,cAAA,CAAe,SAAA,CAAU,OAAK,CAAA,CAAE,EAAA,KAAO,IAAI,EAAE,CAAA;AAElE,UAAA,MAAM,YAAA,GAA6B;AAAA,YACjC,IAAI,GAAA,CAAI,EAAA;AAAA,YACR,MAAM,GAAA,CAAI,IAAA;AAAA,YACV,OAAA;AAAA,YACA,WAAW,GAAA,CAAI,SAAA;AAAA,YACf,QAAA,EAAU,GAAA,CAAI,QAAA,IAAY,MAAA,CAAO,EAAA;AAAA,YACjC,WAAA,EAAa,MAAA,CAAO,KAAA,IAAS,GAAA,CAAI,YAAY,MAAA,CAAO;AAAA,WACtD;AAEA,UAAA,IAAI,iBAAiB,EAAA,EAAI;AACvB,YAAA,YAAA,CAAa,OAAA,GAAU;AAAA,cACrB,MAAA,EAAQ,cAAA,CAAe,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,YAAA,GAAe,CAAC,CAAA,EAAG,YAAY,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,gBAClF,IAAI,CAAA,CAAE,EAAA;AAAA,gBACN,MAAM,CAAA,CAAE,IAAA;AAAA,gBACR,SAAS,CAAA,CAAE,OAAA;AAAA,gBACX,SAAA,EAAW,CAAA,CAAE,SAAA,oBAAa,IAAI,IAAA;AAAK,eACrC,CAAE,CAAA;AAAA,cACF,KAAA,EAAO,eAAe,KAAA,CAAM,YAAA,GAAe,GAAG,YAAA,GAAe,CAAC,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,gBACxE,IAAI,CAAA,CAAE,EAAA;AAAA,gBACN,MAAM,CAAA,CAAE,IAAA;AAAA,gBACR,SAAS,CAAA,CAAE,OAAA;AAAA,gBACX,SAAA,EAAW,CAAA,CAAE,SAAA,oBAAa,IAAI,IAAA;AAAK,eACrC,CAAE;AAAA,aACJ;AAAA,UACF;AAEA,UAAA,aAAA,CAAc,KAAK,YAAY,CAAA;AAAA,QACjC,CAAC,CAAA;AAAA,MACH;AAAA,IACF,WAAW,QAAA,EAAU;AAEnB,MAAA,MAAM,SAAS,MAAM,MAAA,CAAO,aAAA,CAAc,EAAE,UAAU,CAAA;AACtD,MAAA,IAAI,CAAC,MAAA,EAAQ;AAEX,QAAA,OAAO;AAAA,UACL,SAAS,EAAC;AAAA,UACV,KAAA,EAAO,CAAA;AAAA,UACP,KAAA,EAAO,WAAA;AAAA,UACP,WAAA,EAAa,QAAA;AAAA,UACb,UAAA,EAAY,oBAAoB,UAAA,GAAa;AAAA,SAC/C;AAAA,MACF;AAEA,MAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,gBAAA,CAAiB;AAAA,QAC3C,QAAA;AAAA,QACA,UAAA;AAAA,QACA,mBAAA,EAAqB,WAAA;AAAA,QACrB;AAAA,OACD,CAAA;AAED,MAAA,MAAM,kBAAkB,MAAM,MAAA,CAAO,MAAM,EAAE,QAAA,EAAU,CAAA,EAAG,UAAA;AAE1D,MAAA,MAAA,CAAO,UAAA,CAAW,QAAQ,CAAA,GAAA,KAAO;AAE/B,QAAA,IAAI,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAE,CAAA,EAAG;AAC5B,QAAA,UAAA,CAAW,GAAA,CAAI,GAAA,CAAI,EAAA,EAAI,IAAI,CAAA;AAG3B,QAAA,MAAM,UACJ,GAAA,CAAI,OAAA,CAAQ,WAAW,GAAA,CAAI,OAAA,CAAQ,OAAO,GAAA,CAAI,CAAA,CAAA,KAAM,CAAA,CAAE,IAAA,KAAS,SAAS,CAAA,CAAE,IAAA,GAAO,EAAG,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA,IAAK,EAAA;AAGrG,QAAA,IAAI,CAAC,iBAAA,IAAqB,CAAC,OAAA,CAAQ,WAAA,GAAc,QAAA,CAAS,WAAA,CAAY,WAAA,EAAa,CAAA,EAAG;AACpF,UAAA;AAAA,QACF;AAGA,QAAA,MAAM,eAAe,cAAA,CAAe,SAAA,CAAU,OAAK,CAAA,CAAE,EAAA,KAAO,IAAI,EAAE,CAAA;AAElE,QAAA,MAAM,YAAA,GAA6B;AAAA,UACjC,IAAI,GAAA,CAAI,EAAA;AAAA,UACR,MAAM,GAAA,CAAI,IAAA;AAAA,UACV,OAAA;AAAA,UACA,WAAW,GAAA,CAAI,SAAA;AAAA,UACf,QAAA;AAAA,UACA,WAAA,EAAa,QAAQ,KAAA,IAAS;AAAA,SAChC;AAGA,QAAA,IAAI,iBAAiB,EAAA,EAAI;AACvB,UAAA,YAAA,CAAa,OAAA,GAAU;AAAA,YACrB,MAAA,EAAQ,cAAA,CAAe,KAAA,CAAM,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,YAAA,GAAe,CAAC,CAAA,EAAG,YAAY,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,cAClF,IAAI,CAAA,CAAE,EAAA;AAAA,cACN,MAAM,CAAA,CAAE,IAAA;AAAA,cACR,SAAS,CAAA,CAAE,OAAA;AAAA,cACX,SAAA,EAAW,CAAA,CAAE,SAAA,oBAAa,IAAI,IAAA;AAAK,aACrC,CAAE,CAAA;AAAA,YACF,KAAA,EAAO,eAAe,KAAA,CAAM,YAAA,GAAe,GAAG,YAAA,GAAe,CAAC,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,cACxE,IAAI,CAAA,CAAE,EAAA;AAAA,cACN,MAAM,CAAA,CAAE,IAAA;AAAA,cACR,SAAS,CAAA,CAAE,OAAA;AAAA,cACX,SAAA,EAAW,CAAA,CAAE,SAAA,oBAAa,IAAI,IAAA;AAAK,aACrC,CAAE;AAAA,WACJ;AAAA,QACF;AAEA,QAAA,aAAA,CAAc,KAAK,YAAY,CAAA;AAAA,MACjC,CAAC,CAAA;AAAA,IACH;AAGA,IAAA,MAAM,aAAA,GAAgB,cACnB,IAAA,CAAK,CAAC,GAAG,CAAA,KAAM,IAAI,IAAA,CAAK,CAAA,CAAE,SAAS,CAAA,CAAE,SAAQ,GAAI,IAAI,IAAA,CAAK,CAAA,CAAE,SAAS,CAAA,CAAE,SAAS,CAAA,CAChF,KAAA,CAAM,CAAA,EAAG,KAAK,CAAA;AAEjB,IAAA,OAAO;AAAA,MACL,OAAA,EAAS,aAAA;AAAA,MACT,OAAO,aAAA,CAAc,MAAA;AAAA,MACrB,KAAA,EAAO,WAAA;AAAA,MACP,WAAA,EAAa,gBAAgB,UAAA,GAAa,QAAA;AAAA,MAC1C,UAAA,EAAY,oBAAoB,UAAA,GAAa;AAAA,KAC/C;AAAA,EACF,SAAS,KAAA,EAAO;AACd,IAAA,OAAOC,6BAAA,CAAY,OAAO,wBAAwB,CAAA;AAAA,EACpD;AACF","file":"chunk-3LTO44EP.cjs","sourcesContent":["import { convertMessages } from '@mastra/core/agent';\nimport type { RuntimeContext } from '@mastra/core/di';\nimport type { MastraMemory } from '@mastra/core/memory';\nimport type { StorageGetMessagesArg, ThreadSortOptions } from '@mastra/core/storage';\nimport { generateEmptyFromSchema } from '@mastra/core/utils';\nimport { HTTPException } from '../http-exception';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\nimport { validateBody } from './utils';\n\ninterface MemoryContext extends Context {\n  agentId?: string;\n  resourceId?: string;\n  threadId?: string;\n  runtimeContext?: RuntimeContext;\n}\n\nasync function getMemoryFromContext({\n  mastra,\n  agentId,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'>): Promise<MastraMemory | null | undefined> {\n  const agent = agentId ? mastra.getAgent(agentId) : null;\n  if (agentId && !agent) {\n    throw new HTTPException(404, { message: 'Agent not found' });\n  }\n\n  if (agent) {\n    return (\n      (await agent?.getMemory({\n        runtimeContext,\n      })) || mastra.getMemory()\n    );\n  }\n\n  return mastra.getMemory();\n}\n\n// Memory handlers\nexport async function getMemoryStatusHandler({\n  mastra,\n  agentId,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'>) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      return { result: false };\n    }\n\n    return { result: true };\n  } catch (error) {\n    return handleError(error, 'Error getting memory status');\n  }\n}\n\nexport async function getMemoryConfigHandler({\n  mastra,\n  agentId,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'>) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    // Get the merged configuration (defaults + custom)\n    const config = memory.getMergedThreadConfig({});\n\n    return { config };\n  } catch (error) {\n    return handleError(error, 'Error getting memory configuration');\n  }\n}\n\nexport async function getThreadsHandler({\n  mastra,\n  agentId,\n  resourceId,\n  runtimeContext,\n  orderBy,\n  sortDirection,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'resourceId' | 'runtimeContext'> & ThreadSortOptions) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    validateBody({ resourceId });\n\n    const threads = await memory.getThreadsByResourceId({\n      resourceId: resourceId!,\n      orderBy,\n      sortDirection,\n    });\n    return threads;\n  } catch (error) {\n    return handleError(error, 'Error getting threads');\n  }\n}\n\nexport async function getThreadsPaginatedHandler({\n  mastra,\n  agentId,\n  resourceId,\n  runtimeContext,\n  page,\n  perPage,\n  orderBy,\n  sortDirection,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'resourceId' | 'runtimeContext'> & {\n  page: number;\n  perPage: number;\n} & ThreadSortOptions) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    validateBody({ resourceId });\n\n    const result = await memory.getThreadsByResourceIdPaginated({\n      resourceId: resourceId!,\n      page,\n      perPage,\n      orderBy,\n      sortDirection,\n    });\n    return result;\n  } catch (error) {\n    return handleError(error, 'Error getting paginated threads');\n  }\n}\n\nexport async function getThreadByIdHandler({\n  mastra,\n  agentId,\n  threadId,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'runtimeContext'>) {\n  try {\n    validateBody({ threadId });\n\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    const thread = await memory.getThreadById({ threadId: threadId! });\n    if (!thread) {\n      throw new HTTPException(404, { message: 'Thread not found' });\n    }\n\n    return thread;\n  } catch (error) {\n    return handleError(error, 'Error getting thread');\n  }\n}\n\nexport async function saveMessagesHandler({\n  mastra,\n  agentId,\n  body,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'> & {\n  body: {\n    messages: Parameters<MastraMemory['saveMessages']>[0]['messages'];\n  };\n}) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    if (!body?.messages) {\n      throw new HTTPException(400, { message: 'Messages are required' });\n    }\n\n    if (!Array.isArray(body.messages)) {\n      throw new HTTPException(400, { message: 'Messages should be an array' });\n    }\n\n    // Validate that all messages have threadId and resourceId\n    const invalidMessages = body.messages.filter(message => !message.threadId || !message.resourceId);\n    if (invalidMessages.length > 0) {\n      throw new HTTPException(400, {\n        message: `All messages must have threadId and resourceId fields. Found ${invalidMessages.length} invalid message(s).`,\n      });\n    }\n\n    const processedMessages = body.messages.map(message => ({\n      ...message,\n      id: message.id || memory.generateId(),\n      createdAt: message.createdAt ? new Date(message.createdAt) : new Date(),\n    }));\n\n    const result = await memory.saveMessages({ messages: processedMessages, memoryConfig: {} });\n    return result;\n  } catch (error) {\n    return handleError(error, 'Error saving messages');\n  }\n}\n\nexport async function createThreadHandler({\n  mastra,\n  agentId,\n  body,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'> & {\n  body?: Omit<Parameters<MastraMemory['createThread']>[0], 'resourceId'> & { resourceId?: string };\n}) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    validateBody({ resourceId: body?.resourceId });\n\n    const result = await memory.createThread({\n      resourceId: body?.resourceId!,\n      title: body?.title,\n      metadata: body?.metadata,\n      threadId: body?.threadId,\n    });\n    return result;\n  } catch (error) {\n    return handleError(error, 'Error saving thread to memory');\n  }\n}\n\nexport async function updateThreadHandler({\n  mastra,\n  agentId,\n  threadId,\n  body,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'runtimeContext'> & {\n  body?: Parameters<MastraMemory['saveThread']>[0]['thread'];\n}) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!body) {\n      throw new HTTPException(400, { message: 'Body is required' });\n    }\n\n    const { title, metadata, resourceId } = body;\n    const updatedAt = new Date();\n\n    validateBody({ threadId });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    const thread = await memory.getThreadById({ threadId: threadId! });\n    if (!thread) {\n      throw new HTTPException(404, { message: 'Thread not found' });\n    }\n\n    const updatedThread = {\n      ...thread,\n      title: title || thread.title,\n      metadata: metadata || thread.metadata,\n      resourceId: resourceId || thread.resourceId,\n      createdAt: thread.createdAt,\n      updatedAt,\n    };\n\n    const result = await memory.saveThread({ thread: updatedThread });\n    return result;\n  } catch (error) {\n    return handleError(error, 'Error updating thread');\n  }\n}\n\nexport async function deleteThreadHandler({\n  mastra,\n  agentId,\n  threadId,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'runtimeContext'>) {\n  try {\n    validateBody({ threadId });\n\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    const thread = await memory.getThreadById({ threadId: threadId! });\n    if (!thread) {\n      throw new HTTPException(404, { message: 'Thread not found' });\n    }\n\n    await memory.deleteThread(threadId!);\n    return { result: 'Thread deleted' };\n  } catch (error) {\n    return handleError(error, 'Error deleting thread');\n  }\n}\n\nexport async function getMessagesPaginatedHandler({\n  mastra,\n  threadId,\n  resourceId,\n  selectBy,\n  format,\n}: StorageGetMessagesArg & Pick<MemoryContext, 'mastra'>) {\n  try {\n    validateBody({ threadId });\n\n    const storage = mastra.getStorage();\n\n    if (!storage) {\n      throw new HTTPException(400, { message: 'Storage is not initialized' });\n    }\n\n    const thread = await storage.getThreadById({ threadId: threadId! });\n\n    if (!thread) {\n      throw new HTTPException(404, { message: 'Thread not found' });\n    }\n\n    const result = await storage.getMessagesPaginated({ threadId: threadId!, resourceId, selectBy, format });\n    return result;\n  } catch (error) {\n    return handleError(error, 'Error getting messages');\n  }\n}\n\nexport async function getMessagesHandler({\n  mastra,\n  agentId,\n  threadId,\n  limit,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'runtimeContext'> & {\n  limit?: number;\n}) {\n  if (limit !== undefined && (!Number.isInteger(limit) || limit <= 0)) {\n    throw new HTTPException(400, { message: 'Invalid limit: must be a positive integer' });\n  }\n  try {\n    validateBody({ threadId });\n\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    const thread = await memory.getThreadById({ threadId: threadId! });\n    if (!thread) {\n      throw new HTTPException(404, { message: 'Thread not found' });\n    }\n\n    const result = await memory.query({\n      threadId: threadId!,\n      ...(limit && { selectBy: { last: limit } }),\n    });\n    const uiMessages = convertMessages(result.messages).to('AIV5.UI');\n    return { messages: result.messages, uiMessages, legacyMessages: result.uiMessages };\n  } catch (error) {\n    return handleError(error, 'Error getting messages');\n  }\n}\n\n/**\n * Handler to get the working memory for a thread (optionally resource-scoped).\n * @returns workingMemory - the working memory for the thread\n * @returns source - thread or resource\n */\nexport async function getWorkingMemoryHandler({\n  mastra,\n  agentId,\n  threadId,\n  resourceId,\n  runtimeContext,\n  memoryConfig,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'runtimeContext'> & {\n  resourceId?: Parameters<MastraMemory['getWorkingMemory']>[0]['resourceId'];\n  memoryConfig?: Parameters<MastraMemory['getWorkingMemory']>[0]['memoryConfig'];\n}) {\n  try {\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n    validateBody({ threadId });\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n    const thread = await memory.getThreadById({ threadId: threadId! });\n    const threadExists = !!thread;\n    const template = await memory.getWorkingMemoryTemplate({ memoryConfig });\n    const workingMemoryTemplate =\n      template?.format === 'json'\n        ? { ...template, content: JSON.stringify(generateEmptyFromSchema(template.content)) }\n        : template;\n    const workingMemory = await memory.getWorkingMemory({ threadId: threadId!, resourceId, memoryConfig });\n    const config = memory.getMergedThreadConfig(memoryConfig || {});\n    const source = config.workingMemory?.scope === 'resource' && resourceId ? 'resource' : 'thread';\n    return { workingMemory, source, workingMemoryTemplate, threadExists };\n  } catch (error) {\n    return handleError(error, 'Error getting working memory');\n  }\n}\n\n/**\n * Handler to update the working memory for a thread (optionally resource-scoped).\n * @param threadId - the thread id\n * @param body - the body containing the working memory to update and the resource id (optional)\n */\nexport async function updateWorkingMemoryHandler({\n  mastra,\n  agentId,\n  threadId,\n  body,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'threadId' | 'runtimeContext'> & {\n  body: Omit<Parameters<MastraMemory['updateWorkingMemory']>[0], 'threadId'>;\n}) {\n  try {\n    validateBody({ threadId });\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n    const { resourceId, memoryConfig, workingMemory } = body;\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n    const thread = await memory.getThreadById({ threadId: threadId! });\n    if (!thread) {\n      throw new HTTPException(404, { message: 'Thread not found' });\n    }\n\n    await memory.updateWorkingMemory({ threadId: threadId!, resourceId, workingMemory, memoryConfig });\n    return { success: true };\n  } catch (error) {\n    return handleError(error, 'Error updating working memory');\n  }\n}\n\ninterface SearchResult {\n  id: string;\n  role: string;\n  content: any;\n  createdAt: Date;\n  threadId?: string;\n  threadTitle?: string;\n  score?: number;\n  context?: {\n    before?: SearchResult[];\n    after?: SearchResult[];\n  };\n}\n\ninterface SearchResponse {\n  results: SearchResult[];\n  count: number;\n  query: string;\n  searchScope?: string;\n  searchType?: string;\n}\n\n/**\n * Handler to delete one or more messages.\n * @param messageIds - Can be a single ID, array of IDs, or objects with ID property\n */\nexport async function deleteMessagesHandler({\n  mastra,\n  agentId,\n  messageIds,\n  runtimeContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'> & {\n  messageIds: string | string[] | { id: string } | { id: string }[];\n}) {\n  try {\n    if (messageIds === undefined || messageIds === null) {\n      throw new HTTPException(400, { message: 'messageIds is required' });\n    }\n\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    // Delete the messages - let the memory method handle validation\n    await memory.deleteMessages(messageIds as any);\n\n    // Count messages for response\n    let count = 1;\n    if (Array.isArray(messageIds)) {\n      count = messageIds.length;\n    }\n\n    return { success: true, message: `${count} message${count === 1 ? '' : 's'} deleted successfully` };\n  } catch (error) {\n    return handleError(error, 'Error deleting messages');\n  }\n}\n\nexport async function searchMemoryHandler({\n  mastra,\n  agentId,\n  searchQuery,\n  resourceId,\n  threadId,\n  limit = 20,\n  runtimeContext,\n  memoryConfig,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'runtimeContext'> & {\n  searchQuery: string;\n  resourceId: string;\n  threadId?: string;\n  limit?: number;\n  memoryConfig?: any;\n}): Promise<SearchResponse | ReturnType<typeof handleError>> {\n  try {\n    validateBody({ searchQuery, resourceId });\n\n    const memory = await getMemoryFromContext({ mastra, agentId, runtimeContext });\n    if (!memory) {\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    }\n\n    // Get memory configuration first to check scope\n    const config = memory.getMergedThreadConfig(memoryConfig || {});\n    const hasSemanticRecall = !!config?.semanticRecall;\n    const resourceScope = typeof config?.semanticRecall === 'object' && config?.semanticRecall?.scope === 'resource';\n\n    // Only validate thread ownership if we're in thread scope\n    if (threadId && !resourceScope) {\n      const thread = await memory.getThreadById({ threadId });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n      if (thread.resourceId !== resourceId) {\n        throw new HTTPException(403, { message: 'Thread does not belong to the specified resource' });\n      }\n    }\n\n    const searchResults: SearchResult[] = [];\n    const messageMap = new Map<string, boolean>(); // For deduplication\n\n    // If threadId is provided and scope is thread-based, check if the thread exists\n    if (threadId && !resourceScope) {\n      const thread = await memory.getThreadById({ threadId });\n      if (!thread) {\n        // Thread doesn't exist yet (new unsaved thread) - return empty results\n        return {\n          results: [],\n          count: 0,\n          query: searchQuery,\n          searchScope: 'thread',\n          searchType: hasSemanticRecall ? 'semantic' : 'text',\n        };\n      }\n    }\n\n    // If resource scope is enabled or no threadId provided, search across all threads\n    if (!threadId || resourceScope) {\n      // Search across all threads for this resource\n      const threads = await memory.getThreadsByResourceId({ resourceId });\n\n      // If no threads exist yet, return empty results\n      if (threads.length === 0) {\n        return {\n          results: [],\n          count: 0,\n          query: searchQuery,\n          searchScope: 'resource',\n          searchType: hasSemanticRecall ? 'semantic' : 'text',\n        };\n      }\n\n      for (const thread of threads) {\n        // Use rememberMessages for semantic search\n        const result = await memory.rememberMessages({\n          threadId: thread.id,\n          resourceId,\n          vectorMessageSearch: searchQuery,\n          config,\n        });\n\n        // Get thread messages for context\n        const threadMessages = (await memory.query({ threadId: thread.id })).uiMessages;\n\n        // Process results\n        result.messagesV2.forEach(msg => {\n          if (messageMap.has(msg.id)) return;\n          messageMap.set(msg.id, true);\n\n          const content =\n            msg.content.content || msg.content.parts?.map(p => (p.type === 'text' ? p.text : '')).join(' ') || '';\n\n          if (!hasSemanticRecall && !content.toLowerCase().includes(searchQuery.toLowerCase())) {\n            return;\n          }\n\n          const messageIndex = threadMessages.findIndex(m => m.id === msg.id);\n\n          const searchResult: SearchResult = {\n            id: msg.id,\n            role: msg.role,\n            content,\n            createdAt: msg.createdAt,\n            threadId: msg.threadId || thread.id,\n            threadTitle: thread.title || msg.threadId || thread.id,\n          };\n\n          if (messageIndex !== -1) {\n            searchResult.context = {\n              before: threadMessages.slice(Math.max(0, messageIndex - 2), messageIndex).map(m => ({\n                id: m.id,\n                role: m.role,\n                content: m.content,\n                createdAt: m.createdAt || new Date(),\n              })),\n              after: threadMessages.slice(messageIndex + 1, messageIndex + 3).map(m => ({\n                id: m.id,\n                role: m.role,\n                content: m.content,\n                createdAt: m.createdAt || new Date(),\n              })),\n            };\n          }\n\n          searchResults.push(searchResult);\n        });\n      }\n    } else if (threadId) {\n      // Search in specific thread only\n      const thread = await memory.getThreadById({ threadId });\n      if (!thread) {\n        // Thread doesn't exist yet - return empty results\n        return {\n          results: [],\n          count: 0,\n          query: searchQuery,\n          searchScope: 'thread',\n          searchType: hasSemanticRecall ? 'semantic' : 'text',\n        };\n      }\n\n      const result = await memory.rememberMessages({\n        threadId,\n        resourceId,\n        vectorMessageSearch: searchQuery,\n        config,\n      });\n\n      const threadMessages = (await memory.query({ threadId })).uiMessages;\n\n      result.messagesV2.forEach(msg => {\n        // Skip duplicates\n        if (messageMap.has(msg.id)) return;\n        messageMap.set(msg.id, true);\n\n        // Extract content\n        const content =\n          msg.content.content || msg.content.parts?.map(p => (p.type === 'text' ? p.text : '')).join(' ') || '';\n\n        // If not using semantic recall, filter by text search\n        if (!hasSemanticRecall && !content.toLowerCase().includes(searchQuery.toLowerCase())) {\n          return;\n        }\n\n        // Find message index for context\n        const messageIndex = threadMessages.findIndex(m => m.id === msg.id);\n\n        const searchResult: SearchResult = {\n          id: msg.id,\n          role: msg.role,\n          content,\n          createdAt: msg.createdAt,\n          threadId: threadId,\n          threadTitle: thread?.title || threadId,\n        };\n\n        // Add context if found\n        if (messageIndex !== -1) {\n          searchResult.context = {\n            before: threadMessages.slice(Math.max(0, messageIndex - 2), messageIndex).map(m => ({\n              id: m.id,\n              role: m.role,\n              content: m.content,\n              createdAt: m.createdAt || new Date(),\n            })),\n            after: threadMessages.slice(messageIndex + 1, messageIndex + 3).map(m => ({\n              id: m.id,\n              role: m.role,\n              content: m.content,\n              createdAt: m.createdAt || new Date(),\n            })),\n          };\n        }\n\n        searchResults.push(searchResult);\n      });\n    }\n\n    // Sort by date (newest first) and limit\n    const sortedResults = searchResults\n      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n      .slice(0, limit);\n\n    return {\n      results: sortedResults,\n      count: sortedResults.length,\n      query: searchQuery,\n      searchScope: resourceScope ? 'resource' : 'thread',\n      searchType: hasSemanticRecall ? 'semantic' : 'text',\n    };\n  } catch (error) {\n    return handleError(error, 'Error searching memory');\n  }\n}\n"]}