{"version":3,"sources":["../../src/http/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { LoggerTransport } from '@mastra/core/logger';\nimport type { BaseLogMessage, LogLevel } from '@mastra/core/logger';\n\ninterface RetryOptions {\n  maxRetries?: number;\n  retryDelay?: number;\n  exponentialBackoff?: boolean;\n}\n\ninterface HttpTransportOptions {\n  url: string;\n  method?: 'POST' | 'PUT' | 'PATCH';\n  headers?: Record<string, string>;\n  batchSize?: number;\n  flushInterval?: number;\n  timeout?: number;\n  retryOptions?: RetryOptions;\n}\n\nexport class HttpTransport extends LoggerTransport {\n  private url: string;\n  private method: string;\n  private headers: Record<string, string>;\n  private batchSize: number;\n  private flushInterval: number;\n  private timeout: number;\n  private retryOptions: Required<RetryOptions>;\n  private logBuffer: BaseLogMessage[];\n  private lastFlush: number;\n  private flushIntervalId: NodeJS.Timeout;\n\n  constructor(options: HttpTransportOptions) {\n    super({ objectMode: true });\n\n    if (!options.url) {\n      throw new Error('HTTP URL is required');\n    }\n\n    this.url = options.url;\n    this.method = options.method || 'POST';\n    this.headers = {\n      'Content-Type': 'application/json',\n      ...options.headers,\n    };\n    this.batchSize = options.batchSize || 100;\n    this.flushInterval = options.flushInterval || 10000;\n    this.timeout = options.timeout || 30000;\n    this.retryOptions = {\n      maxRetries: options.retryOptions?.maxRetries || 3,\n      retryDelay: options.retryOptions?.retryDelay || 1000,\n      exponentialBackoff: options.retryOptions?.exponentialBackoff || true,\n    };\n\n    this.logBuffer = [];\n    this.lastFlush = Date.now();\n\n    // Start flush interval\n    this.flushIntervalId = setInterval(() => {\n      this._flush().catch(err => {\n        console.error('Error flushing logs to HTTP endpoint:', err);\n      });\n    }, this.flushInterval);\n  }\n\n  private async makeHttpRequest(data: any, retryCount = 0): Promise<Response> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const body = JSON.stringify({ logs: data });\n\n      const response = await fetch(this.url, {\n        method: this.method,\n        headers: this.headers,\n        body,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      return response;\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (retryCount < this.retryOptions.maxRetries) {\n        const delay = this.retryOptions.exponentialBackoff\n          ? this.retryOptions.retryDelay * Math.pow(2, retryCount)\n          : this.retryOptions.retryDelay;\n\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.makeHttpRequest(data, retryCount + 1);\n      }\n\n      throw error;\n    }\n  }\n\n  async _flush(): Promise<void> {\n    if (this.logBuffer.length === 0) {\n      return;\n    }\n\n    const now = Date.now();\n    const logs = this.logBuffer.splice(0, this.batchSize);\n\n    try {\n      await this.makeHttpRequest(logs);\n      this.lastFlush = now;\n    } catch (error) {\n      // On error, put logs back in the buffer\n      this.logBuffer.unshift(...logs);\n      throw error;\n    }\n  }\n\n  _write(chunk: any, encoding?: string, callback?: (error?: Error | null) => void): boolean {\n    if (typeof callback === 'function') {\n      this._transform(chunk, encoding || 'utf8', callback);\n      return true;\n    }\n\n    this._transform(chunk, encoding || 'utf8', (error: Error | null) => {\n      if (error) console.error('Transform error in write:', error);\n    });\n    return true;\n  }\n\n  _transform(chunk: string, _enc: string, cb: Function): void {\n    try {\n      // Parse the log line if it's a string\n      const log = typeof chunk === 'string' ? JSON.parse(chunk) : chunk;\n\n      // Add timestamp if not present\n      if (!log.time) {\n        log.time = Date.now();\n      }\n\n      // Add to buffer\n      this.logBuffer.push(log);\n\n      // Flush if buffer reaches batch size\n      if (this.logBuffer.length >= this.batchSize) {\n        this._flush().catch(err => {\n          console.error('Error flushing logs to HTTP endpoint:', err);\n        });\n      }\n\n      // Pass through the log\n      cb(null, chunk);\n    } catch (error) {\n      cb(error);\n    }\n  }\n\n  _destroy(err: Error, cb: Function): void {\n    clearInterval(this.flushIntervalId);\n\n    // Final flush\n    if (this.logBuffer.length > 0) {\n      this._flush()\n        .then(() => cb(err))\n        .catch(flushErr => {\n          console.error('Error in final flush:', flushErr);\n          cb(err || flushErr);\n        });\n    } else {\n      cb(err);\n    }\n  }\n\n  async getLogs(params?: {\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    returnPaginationResults?: boolean;\n    page?: number;\n    perPage?: number;\n  }): Promise<{\n    logs: BaseLogMessage[];\n    total: number;\n    page: number;\n    perPage: number;\n    hasMore: boolean;\n  }> {\n    // HttpTransport is write-only by default\n    // Subclasses can override this method to implement log retrieval\n    console.warn(\n      'HttpTransport.getLogs: This transport is write-only. Override this method to implement log retrieval.',\n    );\n\n    return {\n      logs: [],\n      total: 0,\n      page: params?.page ?? 1,\n      perPage: params?.perPage ?? 100,\n      hasMore: false,\n    };\n  }\n\n  async getLogsByRunId({\n    runId: _runId,\n    fromDate: _fromDate,\n    toDate: _toDate,\n    logLevel: _logLevel,\n    filters: _filters,\n    page,\n    perPage,\n  }: {\n    runId: string;\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    page?: number;\n    perPage?: number;\n  }): Promise<{\n    logs: BaseLogMessage[];\n    total: number;\n    page: number;\n    perPage: number;\n    hasMore: boolean;\n  }> {\n    // HttpTransport is write-only by default\n    // Subclasses can override this method to implement log retrieval\n    console.warn(\n      'HttpTransport.getLogsByRunId: This transport is write-only. Override this method to implement log retrieval.',\n    );\n\n    return {\n      logs: [],\n      total: 0,\n      page: page ?? 1,\n      perPage: perPage ?? 100,\n      hasMore: false,\n    };\n  }\n\n  // Utility methods\n  public getBufferedLogs(): BaseLogMessage[] {\n    return [...this.logBuffer];\n  }\n\n  public clearBuffer(): void {\n    this.logBuffer = [];\n  }\n\n  public getLastFlushTime(): number {\n    return this.lastFlush;\n  }\n}\n"]}