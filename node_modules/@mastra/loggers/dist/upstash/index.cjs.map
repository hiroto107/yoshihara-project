{"version":3,"sources":["../../src/upstash/index.ts"],"names":["LoggerTransport"],"mappings":"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","file":"index.cjs","sourcesContent":["import { LoggerTransport } from '@mastra/core/logger';\nimport type { BaseLogMessage, LogLevel } from '@mastra/core/logger';\n\nexport class UpstashTransport extends LoggerTransport {\n  upstashUrl: string;\n  upstashToken: string;\n  listName: string;\n  maxListLength: number;\n  batchSize: number;\n  flushInterval: number;\n  logBuffer: any[];\n  lastFlush: number;\n  flushIntervalId: NodeJS.Timeout;\n\n  constructor(opts: {\n    listName?: string;\n    maxListLength?: number;\n    batchSize?: number;\n    upstashUrl: string;\n    flushInterval?: number;\n    upstashToken: string;\n  }) {\n    super({ objectMode: true });\n\n    if (!opts.upstashUrl || !opts.upstashToken) {\n      throw new Error('Upstash URL and token are required');\n    }\n\n    this.upstashUrl = opts.upstashUrl;\n    this.upstashToken = opts.upstashToken;\n    this.listName = opts.listName || 'application-logs';\n    this.maxListLength = opts.maxListLength || 10000;\n    this.batchSize = opts.batchSize || 100;\n    this.flushInterval = opts.flushInterval || 10000;\n\n    this.logBuffer = [];\n    this.lastFlush = Date.now();\n\n    // Start flush interval\n    this.flushIntervalId = setInterval(() => {\n      this._flush().catch(err => {\n        console.error('Error flushing logs to Upstash:', err);\n      });\n    }, this.flushInterval);\n  }\n\n  private async executeUpstashCommand(command: any[]): Promise<any> {\n    const response = await fetch(`${this.upstashUrl}/pipeline`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${this.upstashToken}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify([command]),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to execute Upstash command: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  async _flush() {\n    if (this.logBuffer.length === 0) {\n      return;\n    }\n\n    const now = Date.now();\n    const logs = this.logBuffer.splice(0, this.batchSize);\n\n    try {\n      // Prepare the Upstash Redis command\n      const command = ['LPUSH', this.listName, ...logs.map(log => JSON.stringify(log))];\n\n      // Trim the list if it exceeds maxListLength\n      if (this.maxListLength > 0) {\n        command.push('LTRIM', this.listName, 0 as any, (this.maxListLength - 1) as any);\n      }\n\n      // Send logs to Upstash Redis\n      await this.executeUpstashCommand(command);\n      this.lastFlush = now;\n    } catch (error) {\n      // On error, put logs back in the buffer\n      this.logBuffer.unshift(...logs);\n      throw error;\n    }\n  }\n\n  _write(chunk: any, encoding?: string, callback?: (error?: Error | null) => void): boolean {\n    if (typeof callback === 'function') {\n      this._transform(chunk, encoding || 'utf8', callback);\n      return true;\n    }\n\n    this._transform(chunk, encoding || 'utf8', (error: Error | null) => {\n      if (error) console.error('Transform error in write:', error);\n    });\n    return true;\n  }\n\n  _transform(chunk: string, _enc: string, cb: Function) {\n    try {\n      // Parse the log line if it's a string\n      const log = typeof chunk === 'string' ? JSON.parse(chunk) : chunk;\n\n      // Add timestamp if not present\n      if (!log.time) {\n        log.time = Date.now();\n      }\n\n      // Add to buffer\n      this.logBuffer.push(log);\n\n      // Flush if buffer reaches batch size\n      if (this.logBuffer.length >= this.batchSize) {\n        this._flush().catch(err => {\n          console.error('Error flushing logs to Upstash:', err);\n        });\n      }\n\n      // Pass through the log\n      cb(null, chunk);\n    } catch (error) {\n      cb(error);\n    }\n  }\n\n  _destroy(err: Error, cb: Function) {\n    clearInterval(this.flushIntervalId);\n\n    // Final flush\n    if (this.logBuffer.length > 0) {\n      this._flush()\n        .then(() => cb(err))\n        .catch(flushErr => {\n          console.error('Error in final flush:', flushErr);\n          cb(err || flushErr);\n        });\n    } else {\n      cb(err);\n    }\n  }\n\n  async getLogs(params?: {\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    returnPaginationResults?: boolean; // default true\n    page?: number;\n    perPage?: number;\n  }): Promise<{\n    logs: BaseLogMessage[];\n    total: number;\n    page: number;\n    perPage: number;\n    hasMore: boolean;\n  }> {\n    try {\n      // Get all logs from the list\n      const command = ['LRANGE', this.listName, 0, -1];\n      const response = await this.executeUpstashCommand(command);\n\n      const logs =\n        (response?.[0]?.result?.map((log: string) => {\n          try {\n            // Parse the logs from JSON strings back to objects\n            return JSON.parse(log);\n          } catch {\n            return {};\n          }\n        }) as BaseLogMessage[]) || [];\n\n      let filteredLogs = logs.filter(record => record !== null && typeof record === 'object');\n\n      const {\n        fromDate,\n        toDate,\n        logLevel,\n        filters,\n        returnPaginationResults: returnPaginationResultsInput,\n        page: pageInput,\n        perPage: perPageInput,\n      } = params || {};\n\n      const page = pageInput === 0 ? 1 : (pageInput ?? 1);\n      const perPage = perPageInput ?? 100;\n      const returnPaginationResults = returnPaginationResultsInput ?? true;\n\n      if (filters) {\n        filteredLogs = filteredLogs.filter(log =>\n          Object.entries(filters || {}).every(([key, value]) => log[key as keyof BaseLogMessage] === value),\n        );\n      }\n\n      if (logLevel) {\n        filteredLogs = filteredLogs.filter(log => log.level === logLevel);\n      }\n\n      if (fromDate) {\n        filteredLogs = filteredLogs.filter(log => new Date(log.time)?.getTime() >= fromDate!.getTime());\n      }\n\n      if (toDate) {\n        filteredLogs = filteredLogs.filter(log => new Date(log.time)?.getTime() <= toDate!.getTime());\n      }\n\n      if (!returnPaginationResults) {\n        return {\n          logs: filteredLogs,\n          total: filteredLogs.length,\n          page,\n          perPage: filteredLogs.length,\n          hasMore: false,\n        };\n      }\n\n      const total = filteredLogs.length;\n      const resolvedPerPage = perPage || 100;\n      const start = (page - 1) * resolvedPerPage;\n      const end = start + resolvedPerPage;\n      const paginatedLogs = filteredLogs.slice(start, end);\n      const hasMore = end < total;\n\n      return {\n        logs: paginatedLogs,\n        total,\n        page,\n        perPage: resolvedPerPage,\n        hasMore,\n      };\n    } catch (error) {\n      console.error('Error getting logs from Upstash:', error);\n      return {\n        logs: [],\n        total: 0,\n        page: params?.page ?? 1,\n        perPage: params?.perPage ?? 100,\n        hasMore: false,\n      };\n    }\n  }\n\n  async getLogsByRunId({\n    runId,\n    fromDate,\n    toDate,\n    logLevel,\n    filters,\n    page: pageInput,\n    perPage: perPageInput,\n  }: {\n    runId: string;\n    fromDate?: Date;\n    toDate?: Date;\n    logLevel?: LogLevel;\n    filters?: Record<string, any>;\n    page?: number;\n    perPage?: number;\n  }): Promise<{\n    logs: BaseLogMessage[];\n    total: number;\n    page: number;\n    perPage: number;\n    hasMore: boolean;\n  }> {\n    try {\n      const page = pageInput === 0 ? 1 : (pageInput ?? 1);\n      const perPage = perPageInput ?? 100;\n      const allLogs = await this.getLogs({ fromDate, toDate, logLevel, filters, returnPaginationResults: false });\n      const logs = (allLogs?.logs?.filter((log: any) => log.runId === runId) || []) as BaseLogMessage[];\n      const total = logs.length;\n      const resolvedPerPage = perPage || 100;\n      const start = (page - 1) * resolvedPerPage;\n      const end = start + resolvedPerPage;\n      const paginatedLogs = logs.slice(start, end);\n      const hasMore = end < total;\n\n      return {\n        logs: paginatedLogs,\n        total,\n        page,\n        perPage: resolvedPerPage,\n        hasMore,\n      };\n    } catch (error) {\n      console.error('Error getting logs by runId from Upstash:', error);\n      return {\n        logs: [],\n        total: 0,\n        page: pageInput ?? 1,\n        perPage: perPageInput ?? 100,\n        hasMore: false,\n      };\n    }\n  }\n}\n"]}