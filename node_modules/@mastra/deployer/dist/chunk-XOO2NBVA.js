import { getInputOptions } from './chunk-V5XLVZ27.js';
import { slash, getWorkspaceInformation, analyzeBundle, getPackageName, tsConfigPaths, aliasHono, extractMastraOption, removeAllOptionsFromMastraExcept } from './chunk-YC7SHFJ6.js';
import { watch } from 'rollup';
import { dirname, posix, extname } from 'path';
import * as pkg from 'empathic/package';
import { pathToFileURL } from 'url';
import resolveFrom from 'resolve-from';
import { builtinModules } from 'module';
import { noopLogger } from '@mastra/core/logger';

function isBuiltinModule(specifier) {
  return builtinModules.includes(specifier) || specifier.startsWith("node:") || builtinModules.includes(specifier.replace(/^node:/, ""));
}
function safeResolve(id, importer) {
  try {
    return resolveFrom(importer, id);
  } catch {
    return null;
  }
}
function nodeModulesExtensionResolver() {
  return {
    name: "node-modules-extension-resolver",
    resolveId(id, importer) {
      if (id.startsWith(".") || id.startsWith("/") || !importer) {
        return null;
      }
      if (isBuiltinModule(id)) {
        return null;
      }
      if (id.startsWith("@") && id.split("/").length === 2) {
        return null;
      }
      if (!id.startsWith("@") && id.split("/").length === 1) {
        return null;
      }
      const foundExt = extname(id);
      if (foundExt) {
        return null;
      }
      try {
        const resolved = import.meta.resolve(id);
        if (!extname(resolved)) {
          throw new Error(`Cannot resolve ${id} from ${importer}`);
        }
        return null;
      } catch (e) {
        const resolved = safeResolve(id, importer);
        if (resolved) {
          return {
            id: pathToFileURL(resolved).href,
            external: true
          };
        }
        for (const ext of [".mjs", ".js", ".cjs"]) {
          const resolved2 = safeResolve(id + ext, importer);
          if (resolved2) {
            const pkgName = getPackageName(id);
            if (!pkgName) {
              return null;
            }
            const pkgJsonPath = safeResolve(`${pkgName}/package.json`, importer);
            if (!pkgJsonPath) {
              return null;
            }
            const newImportWithExtension = resolved2.replace(dirname(pkgJsonPath), pkgName);
            return {
              id: pathToFileURL(newImportWithExtension).href,
              external: true
            };
          }
        }
      }
      return null;
    }
  };
}
async function getInputOptions2(entryFile, platform, env, { sourcemap = false } = {}) {
  const closestPkgJson = pkg.up({ cwd: dirname(entryFile) });
  const projectRoot = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());
  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: entryFile });
  const analyzeEntryResult = await analyzeBundle(
    [entryFile],
    entryFile,
    {
      outputDir: posix.join(process.cwd(), ".mastra", ".build"),
      projectRoot: workspaceRoot || process.cwd(),
      platform: "node",
      isDev: true
    },
    noopLogger
  );
  const deps = /* @__PURE__ */ new Map();
  for (const [dep, metadata] of analyzeEntryResult.dependencies.entries()) {
    const pkgName = getPackageName(dep);
    if (pkgName && workspaceMap.has(pkgName)) {
      deps.set(dep, metadata);
    }
  }
  const inputOptions = await getInputOptions(
    entryFile,
    {
      dependencies: deps,
      externalDependencies: /* @__PURE__ */ new Set(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot, projectRoot }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(aliasHono());
    inputOptions.plugins.push(nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/babel/remove-all-options-server.ts
function removeAllOptionsExceptServer(result, logger) {
  return removeAllOptionsFromMastraExcept(result, "server", logger);
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption(
    "server",
    entryFile,
    removeAllOptionsExceptServer,
    outputDir,
    logger
  );
  if (!result) {
    return null;
  }
  return result.getConfig();
}

export { createWatcher, getInputOptions2 as getInputOptions, getServerOptions };
//# sourceMappingURL=chunk-XOO2NBVA.js.map
//# sourceMappingURL=chunk-XOO2NBVA.js.map