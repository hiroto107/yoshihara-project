{"version":3,"sources":["../src/build/utils.ts","../src/validator/validate.ts","../src/build/babel/remove-all-options-except.ts","../src/build/babel/remove-all-options-bundler.ts","../src/build/plugins/esbuild.ts","../src/build/plugins/tsconfig-paths.ts","../src/build/babel/remove-non-referenced-nodes.ts","../src/build/plugins/remove-unused-references.ts","../src/build/shared/extract-mastra-option.ts","../src/build/bundlerOptions.ts","../src/build/babel/check-config-export.ts","../src/bundler/workspaceDependencies.ts","../src/build/isNodeBuiltin.ts","../src/build/babel/remove-deployer.ts","../src/build/plugins/remove-deployer.ts","../src/build/analyze/constants.ts","../src/build/analyze/analyzeEntry.ts","../src/build/plugins/hono-alias.ts","../src/build/analyze/bundleExternals.ts","../src/build/analyze.ts"],"names":["pathToFileURL","pkg","getPackageInfo","join","path","relative","basename","resolve","nodeSpawn","dirname","babel","originalEsbuild","createHandler","fs","normalize","babel3","rollup","optimizeLodashImports","commonjs","json","babel4","result","createWorkspacesCache","findWorkspaces","findWorkspacesRoot","builtinModules","removeDeployer","babel7","virtual","fileURLToPath","logger","resolveFrom","noopLogger","exports","path2","getInputPlugins","readFile","nodeResolve","esmShim","MastraBaseError","ErrorDomain","ErrorCategory","o","writeFile","MastraError","babel8","existsSync"],"mappings":"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","file":"chunk-DFG5D3TX.cjs","sourcesContent":["import { execSync } from 'child_process';\nimport { existsSync, mkdirSync } from 'fs';\nimport { basename, join, relative } from 'path';\nimport { getPackageInfo } from 'local-pkg';\nimport { pathToFileURL } from 'url';\n\nexport function upsertMastraDir({ dir = process.cwd() }: { dir?: string }) {\n  const dirPath = join(dir, '.mastra');\n\n  if (!existsSync(dirPath)) {\n    mkdirSync(dirPath, { recursive: true });\n    execSync(`echo \".mastra\" >> .gitignore`);\n  }\n}\n\n/**\n * Get the package name from a module ID\n */\nexport function getPackageName(id: string) {\n  const parts = id.split('/');\n\n  if (id.startsWith('@')) {\n    return parts.slice(0, 2).join('/');\n  }\n\n  return parts[0];\n}\n\n/**\n * Get package root path\n */\nexport async function getPackageRootPath(packageName: string, parentPath?: string): Promise<string | null> {\n  let rootPath: string | null;\n\n  try {\n    let options: { paths?: string[] } | undefined = undefined;\n    if (parentPath) {\n      if (!parentPath.startsWith('file://')) {\n        parentPath = pathToFileURL(parentPath).href;\n      }\n\n      options = {\n        paths: [parentPath],\n      };\n    }\n\n    const pkg = await getPackageInfo(packageName, options);\n    rootPath = pkg?.rootPath ?? null;\n  } catch (e) {\n    rootPath = null;\n  }\n\n  return rootPath;\n}\n\n/**\n * During `mastra dev` we are compiling TS files to JS (inside workspaces) so that users can just their workspace packages.\n * We store these compiled files inside `node_modules/.cache` for each workspace package.\n */\nexport function getCompiledDepCachePath(rootPath: string, packageName: string) {\n  return slash(join(rootPath, 'node_modules', '.cache', packageName));\n}\n\n/**\n * Convert windows backslashes to posix slashes\n *\n * @example\n * ```ts\n * slash('C:\\\\Users\\\\user\\\\code\\\\mastra') // 'C:/Users/user/code/mastra'\n * ```\n */\nexport function slash(path: string) {\n  const isExtendedLengthPath = path.startsWith('\\\\\\\\?\\\\');\n\n  if (isExtendedLengthPath) {\n    return path;\n  }\n\n  return path.replaceAll('\\\\', '/');\n}\n\n/**\n * Make a Rollup-safe name: pathless, POSIX, and without parent/absolute segments\n */\nexport function rollupSafeName(name: string, rootDir: string) {\n  const rel = relative(rootDir, name);\n  let entry = slash(rel);\n  entry = entry.replace(/^(\\.\\.\\/)+/, '');\n  entry = entry.replace(/^\\/+/, '');\n  entry = entry.replace(/^[A-Za-z]:\\//, '');\n  if (!entry) {\n    entry = slash(basename(name));\n  }\n  return entry;\n}\n\n/**\n * Native binding loaders and infrastructure packages that should be ignored when identifying the actual package that requires native bindings\n */\nconst NATIVE_BINDING_LOADERS = [\n  'node-gyp-build',\n  'prebuild-install',\n  'bindings',\n  'node-addon-api',\n  'node-pre-gyp',\n  'nan', // Native Abstractions for Node.js\n] as const;\n\n/**\n * Finds the first real package from node_modules that likely contains native bindings, filtering out virtual modules and native binding loader infrastructure.\n *\n * @param moduleIds - Array of module IDs from a Rollup chunk\n * @returns The module ID of the actual native package, or undefined if not found\n *\n * @example\n * const moduleIds = [\n *   '\\x00/path/node_modules/bcrypt/bcrypt.js?commonjs-module',\n *   '/path/node_modules/node-gyp-build/index.js',\n *   '/path/node_modules/bcrypt/bcrypt.js',\n * ];\n * findNativePackageModule(moduleIds); // Returns '/path/node_modules/bcrypt/bcrypt.js'\n */\nexport function findNativePackageModule(moduleIds: string[]): string | undefined {\n  return moduleIds.find(id => {\n    // Skip virtual modules (Rollup plugin-generated)\n    if (id.startsWith('\\x00')) {\n      return false;\n    }\n\n    // Must be from node_modules\n    if (!id.includes('/node_modules/')) {\n      return false;\n    }\n\n    // Skip native binding loader infrastructure\n    for (const loader of NATIVE_BINDING_LOADERS) {\n      if (id.includes(`/${loader}/`) || id.includes(`/${loader}@`)) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n","import { spawn as nodeSpawn } from 'node:child_process';\nimport type { SpawnOptions } from 'node:child_process';\nimport { dirname } from 'node:path';\nimport { slash } from '../build/utils';\n\n/**\n * Promisified version of Node.js spawn function\n *\n * @param command - The command to run\n * @param args - List of string arguments\n * @param options - Spawn options\n * @returns Promise that resolves with the exit code when the process completes\n */\nfunction spawn(command: string, args: string[] = [], options: SpawnOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const childProcess = nodeSpawn(command, args, {\n      // stdio: 'inherit',\n      ...options,\n    });\n\n    childProcess.on('error', error => {\n      reject(error);\n    });\n\n    let stderr = '';\n    childProcess.stderr?.on('data', message => {\n      stderr += message;\n    });\n\n    childProcess.on('close', code => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(stderr));\n      }\n    });\n  });\n}\n\nexport function validate(file: string) {\n  return spawn(\n    'node',\n    [\n      '--import',\n      import.meta.resolve('@mastra/deployer/loader'),\n      '--input-type=module',\n      '-e',\n      `import('file://${slash(file)}')`,\n    ],\n    {\n      cwd: dirname(file),\n    },\n  );\n}\n","import babel from '@babel/core';\nimport type { NodePath, types } from '@babel/core';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function removeAllOptionsFromMastraExcept(\n  result: { hasCustomConfig: boolean },\n  option: keyof MastraConfig,\n  logger?: IMastraLogger,\n) {\n  const t = babel.types;\n\n  return {\n    name: 'remove-all-except-' + option + '-config',\n    visitor: {\n      ExportNamedDeclaration: {\n        // remove all exports\n        exit(path) {\n          path.remove();\n        },\n      },\n\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        let mastraArgs = t.objectExpression([]);\n        if (t.isObjectExpression(path.node.arguments[0])) {\n          mastraArgs = path.node.arguments[0];\n        }\n\n        let telemetry = mastraArgs.properties.find(\n          // @ts-ignore\n          prop => prop.key.name === option,\n        );\n        let telemetryValue: types.Expression = t.objectExpression([]);\n\n        const programPath = path.scope.getProgramParent().path as NodePath<types.Program> | undefined;\n        if (!programPath) {\n          return;\n        }\n\n        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {\n          result.hasCustomConfig = true;\n          telemetryValue = telemetry.value;\n\n          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {\n            const telemetryBinding = state.file.scope.getBinding(option)!;\n\n            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {\n              const id = path.scope.generateUidIdentifier(option);\n\n              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init!));\n              telemetryValue = id;\n            }\n          }\n        }\n\n        // add the deployer export\n        const exportDeclaration = t.exportNamedDeclaration(\n          t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), telemetryValue)]),\n          [],\n        );\n\n        programPath.node.body.push(exportDeclaration);\n      },\n\n      Program: {\n        exit(path) {\n          // Add a fallback export if no mastra configuration was found\n          const hasExport = path.node.body.some(\n            node => node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration',\n          );\n\n          if (!hasExport) {\n            if (logger) {\n              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:\nexport const mastra = new Mastra({\n  ${option}: <value>\n})\n\n`);\n            }\n\n            const fallbackExportDeclaration = t.exportNamedDeclaration(\n              t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),\n              [],\n            );\n            path.node.body.push(fallbackExportDeclaration);\n          }\n        },\n      },\n    },\n  } as babel.PluginObj;\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport { removeAllOptionsFromMastraExcept } from './remove-all-options-except';\n\nexport function removeAllOptionsExceptBundler(result: { hasCustomConfig: boolean }, logger?: IMastraLogger) {\n  return removeAllOptionsFromMastraExcept(result, 'bundler', logger);\n}\n","import originalEsbuild from 'rollup-plugin-esbuild';\n\nexport function esbuild(options: Parameters<typeof originalEsbuild>[0] = {}) {\n  return originalEsbuild({\n    target: 'node20',\n    platform: 'node',\n    minify: false,\n    ...options,\n  });\n}\n","import fs from 'node:fs';\nimport path, { normalize } from 'node:path';\nimport resolveFrom from 'resolve-from';\nimport type { Plugin } from 'rollup';\nimport type { RegisterOptions } from 'typescript-paths';\nimport { createHandler } from 'typescript-paths';\n\nconst PLUGIN_NAME = 'tsconfig-paths';\n\nexport type PluginOptions = Omit<RegisterOptions, 'loggerID'> & { localResolve?: boolean };\n\nexport function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve }: PluginOptions = {}): Plugin {\n  let handler: ReturnType<typeof createHandler>;\n  return {\n    name: PLUGIN_NAME,\n    buildStart() {\n      handler = createHandler({\n        log: () => {},\n        tsConfigPath,\n        respectCoreModule,\n        falllback: moduleName => fs.existsSync(moduleName),\n      });\n      return;\n    },\n    async resolveId(request, importer, options) {\n      if (!importer || request.startsWith('\\0')) {\n        return null;\n      }\n\n      const moduleName = handler?.(request, normalize(importer));\n      // No tsconfig alias found, so we need to resolve it normally\n      if (!moduleName) {\n        let importerMeta: { [PLUGIN_NAME]?: { resolved?: boolean } } = {};\n\n        const resolved = await this.resolve(request, importer, { skipSelf: true, ...options });\n        if (!resolved) {\n          return null;\n        }\n\n        // If localResolve is true, we need to check if the importer has been resolved by the tsconfig-paths plugin\n        // if so, we need to resolve the request from the importer instead of the root and mark it as external\n        if (localResolve) {\n          const importerInfo = this.getModuleInfo(importer);\n          importerMeta = importerInfo?.meta || {};\n\n          if (!request.startsWith('./') && !request.startsWith('../') && importerMeta?.[PLUGIN_NAME]?.resolved) {\n            return {\n              ...resolved,\n              external: !request.startsWith('hono/') && request !== 'hono',\n            };\n          }\n        }\n\n        return {\n          ...resolved,\n          meta: {\n            ...(resolved.meta || {}),\n            ...importerMeta,\n          },\n        };\n      }\n\n      // When a module does not have an extension, we need to resolve it to a file\n      if (!path.extname(moduleName)) {\n        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });\n\n        if (!resolved) {\n          return null;\n        }\n\n        return {\n          ...resolved,\n          meta: {\n            ...resolved.meta,\n            [PLUGIN_NAME]: {\n              resolved: true,\n            },\n          },\n        };\n      }\n\n      return {\n        id: moduleName,\n        meta: {\n          [PLUGIN_NAME]: {\n            resolved: true,\n          },\n        },\n      };\n    },\n  } satisfies Plugin;\n}\n","import babel from '@babel/core';\n\nexport function removeNonReferencedNodes() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-non-referenced-nodes',\n    visitor: {\n      Program(path) {\n        // Get the scope information\n        const scope = path.scope;\n\n        // Filter body to keep only referenced nodes\n        const currentBody = path.get('body');\n        const filteredBody = currentBody.filter(childPath => {\n          if (childPath.isExportDeclaration()) {\n            return true;\n          }\n\n          // For variable declarations, check if any declared variables are referenced\n          if (childPath.isVariableDeclaration()) {\n            return childPath.node.declarations.some(decl => {\n              if (!t.isIdentifier(decl.id)) {\n                return false;\n              }\n\n              const name = decl.id.name;\n              const binding = scope.getBinding(name);\n              // Keep if it has references or is exported\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // For function/class declarations, check if they're referenced\n          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {\n            if (!t.isIdentifier(childPath.node.id)) {\n              return false;\n            }\n\n            const name = childPath.node.id.name;\n            const binding = scope.getBinding(name);\n            return binding && (binding.referenced || binding.referencePaths.length > 0);\n          }\n\n          // For imports, check if any imported items are referenced\n          if (childPath.isImportDeclaration()) {\n            return childPath.node.specifiers.some(specifier => {\n              const importedName = specifier.local.name;\n              const binding = scope.getBinding(importedName);\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // Default to keeping other node types\n          return false;\n        });\n\n        // Replace the program body with filtered nodes\n        path.set(\n          'body',\n          filteredBody.map(p => p.node),\n        );\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport { removeNonReferencedNodes } from '../babel/remove-non-referenced-nodes';\n\nexport function recursiveRemoveNonReferencedNodes(code: string) {\n  return new Promise<{ code: string; map: any }>(async (resolve, reject) => {\n    babel.transform(\n      code,\n      {\n        babelrc: false,\n        configFile: false,\n        plugins: [removeNonReferencedNodes()],\n      },\n      (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n\n        // keep looping until the code is not changed\n        if (result && result.code! !== code) {\n          return recursiveRemoveNonReferencedNodes(result!.code!).then(resolve, reject);\n        }\n\n        resolve({\n          code: result!.code!,\n          map: result!.map!,\n        });\n      },\n    );\n  });\n}\n","import * as babel from '@babel/core';\nimport { rollup, type RollupOutput } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport commonjs from '@rollup/plugin-commonjs';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport { recursiveRemoveNonReferencedNodes } from '../plugins/remove-unused-references';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport { removeAllOptionsFromMastraExcept } from '../babel/remove-all-options-except';\nimport json from '@rollup/plugin-json';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\ntype Transformer = (\n  result: { hasCustomConfig: boolean },\n  logger?: IMastraLogger,\n) => ReturnType<typeof removeAllOptionsFromMastraExcept>;\n\nexport function extractMastraOptionBundler(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  result: {\n    hasCustomConfig: false;\n  },\n  logger?: IMastraLogger,\n) {\n  return rollup({\n    logLevel: 'silent',\n    input: {\n      [`${name}-config`]: entryFile,\n    },\n    treeshake: 'smallest',\n    plugins: [\n      tsConfigPaths(),\n      // transpile typescript to something we understand\n      esbuild(),\n      optimizeLodashImports({\n        include: '**/*.{js,ts,mjs,cjs}',\n      }),\n      commonjs({\n        extensions: ['.js', '.ts'],\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      json(),\n      {\n        name: `extract-${name}-config`,\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return new Promise((resolve, reject) => {\n            babel.transform(\n              code,\n              {\n                babelrc: false,\n                configFile: false,\n                filename: id,\n                plugins: [transformer(result, logger)],\n              },\n              (err, result) => {\n                if (err) {\n                  return reject(err);\n                }\n\n                resolve({\n                  code: result!.code!,\n                  map: result!.map!,\n                });\n              },\n            );\n          });\n        },\n      },\n      // let esbuild remove all unused imports\n      esbuild(),\n      {\n        name: 'cleanup',\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return recursiveRemoveNonReferencedNodes(code);\n        },\n      },\n      // let esbuild remove it once more\n      esbuild(),\n    ],\n  });\n}\n\nexport async function extractMastraOption<T>(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<{\n  bundleOutput: RollupOutput;\n  getConfig: () => Promise<T>;\n} | null> {\n  const result = {\n    hasCustomConfig: false,\n  } as const;\n  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);\n\n  const output = await bundler.write({\n    dir: outputDir,\n    format: 'es',\n    entryFileNames: '[name].mjs',\n  });\n\n  if (result.hasCustomConfig) {\n    const configPath = `${outputDir}/${name}-config.mjs`;\n\n    return {\n      bundleOutput: output,\n      getConfig: () => import(`file:${configPath}`).then(m => m[name] as T),\n    };\n  }\n\n  return null;\n}\n","import { removeAllOptionsExceptBundler } from './babel/remove-all-options-bundler';\nimport type { Config } from '@mastra/core/mastra';\nimport { extractMastraOption, extractMastraOptionBundler } from './shared/extract-mastra-option';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function getBundlerOptionsBundler(\n  entryFile: string,\n  result: {\n    hasCustomConfig: false;\n  },\n) {\n  return extractMastraOptionBundler('bundler', entryFile, removeAllOptionsExceptBundler, result);\n}\n\nexport async function getBundlerOptions(\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<Config['bundler'] | null> {\n  const result = await extractMastraOption<Config['bundler']>(\n    'bundler',\n    entryFile,\n    removeAllOptionsExceptBundler,\n    outputDir,\n    logger,\n  );\n\n  if (!result) {\n    return null;\n  }\n\n  return result.getConfig();\n}\n","import type { PluginObj } from '@babel/core';\nimport babel from '@babel/core';\n\nexport function checkConfigExport(result: { hasValidConfig: boolean }): PluginObj {\n  const t = babel.types;\n  // Track which local variable names are assigned to `new Mastra()`\n  const mastraVars = new Set<string>();\n\n  return {\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const decl = path.node.declaration;\n        // 1) export const mastra = new Mastra(...)\n        if (t.isVariableDeclaration(decl)) {\n          const varDecl = decl.declarations[0];\n          if (\n            t.isIdentifier(varDecl?.id, { name: 'mastra' }) &&\n            t.isNewExpression(varDecl.init) &&\n            t.isIdentifier(varDecl.init.callee, { name: 'Mastra' })\n          ) {\n            result.hasValidConfig = true;\n          }\n        }\n        /**\n         * 2) export { foo as mastra }\n         * 3) export { mastra }\n         * 4) export { mastra, foo }\n         */\n        if (Array.isArray(path.node.specifiers)) {\n          for (const spec of path.node.specifiers) {\n            if (\n              t.isExportSpecifier(spec) &&\n              t.isIdentifier(spec.exported, { name: 'mastra' }) &&\n              t.isIdentifier(spec.local) &&\n              mastraVars.has(spec.local.name)\n            ) {\n              result.hasValidConfig = true;\n            }\n          }\n        }\n      },\n      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`\n      VariableDeclaration(path) {\n        for (const decl of path.node.declarations) {\n          if (\n            t.isIdentifier(decl.id) &&\n            t.isNewExpression(decl.init) &&\n            t.isIdentifier(decl.init.callee, { name: 'Mastra' })\n          ) {\n            mastraVars.add(decl.id.name);\n          }\n        }\n      },\n    },\n  };\n}\n","import { join, dirname } from 'node:path';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport slugify from '@sindresorhus/slugify';\nimport * as pkg from 'empathic/package';\nimport { findWorkspaces, findWorkspacesRoot, createWorkspacesCache } from 'find-workspaces';\nimport { ensureDir } from 'fs-extra';\nimport { slash } from '../build/utils';\nimport { DepsService } from '../services';\n\nexport type WorkspacePackageInfo = {\n  location: string;\n  dependencies: Record<string, string> | undefined;\n  version: string | undefined;\n};\n\ntype TransitiveDependencyResult = {\n  resolutions: Record<string, string>;\n  usedWorkspacePackages: Set<string>;\n};\n\n/**\n * Create a shared cache for find-workspaces\n */\nconst workspacesCache = createWorkspacesCache();\n\n/**\n * A utility function around find-workspaces to get information about:\n * - Which workspace packages are available in the project\n * - What is the workspace root location\n * - Is the current package a workspace package\n *\n * Because `findWorkspacesRoot` only traverses up until it finds workspace information, but doesn't check if the current package is even part of the workspace. We rather want to return `null` for these cases because in other code paths we use `workspaceRoot || projectRoot` to determine the root of the project.\n *\n * @params dir - The directory to start searching from (default: `process.cwd()`)\n * @params location - The location of the current package (usually the directory containing the package.json)\n */\nexport async function getWorkspaceInformation({\n  dir = process.cwd(),\n  mastraEntryFile,\n}: {\n  dir?: string;\n  mastraEntryFile: string;\n}) {\n  // 1) Get the location of the current package and its package.json\n  const closestPkgJson = pkg.up({ cwd: dirname(mastraEntryFile) });\n  const location = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());\n\n  // 2) Get all workspaces\n  const workspaces = await findWorkspaces(dir, { cache: workspacesCache });\n  const _workspaceMap = new Map(\n    workspaces?.map(workspace => [\n      workspace.package.name,\n      {\n        location: workspace.location,\n        dependencies: workspace.package.dependencies,\n        version: workspace.package.version,\n      },\n    ]) ?? [],\n  );\n\n  // 3) Check if the current package is part of the workspace\n  const isWorkspacePackage = (workspaces ?? []).some(ws => ws.location === location);\n\n  // 4) Get the workspace root only if the current package is part of the workspace\n  const workspaceRoot = isWorkspacePackage ? findWorkspacesRoot(dir, { cache: workspacesCache })?.location : undefined;\n\n  return {\n    // If the current package is not part of the workspace, the bundling down the line shouldn't look at any workspace packages\n    workspaceMap: isWorkspacePackage ? _workspaceMap : new Map<string, WorkspacePackageInfo>(),\n    workspaceRoot,\n    isWorkspacePackage,\n  };\n}\n\n/**\n * Collects all transitive workspace dependencies and their TGZ paths\n */\nexport const collectTransitiveWorkspaceDependencies = ({\n  workspaceMap,\n  initialDependencies,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  initialDependencies: Set<string>;\n  logger: IMastraLogger;\n}): TransitiveDependencyResult => {\n  const usedWorkspacePackages = new Set<string>();\n  const queue: string[] = Array.from(initialDependencies);\n  const resolutions: Record<string, string> = {};\n\n  while (queue.length > 0) {\n    const len = queue.length;\n    for (let i = 0; i < len; i += 1) {\n      const pkgName = queue.shift();\n      if (!pkgName || usedWorkspacePackages.has(pkgName)) {\n        continue;\n      }\n\n      const dep = workspaceMap.get(pkgName);\n      if (!dep) continue;\n\n      const root = findWorkspacesRoot();\n      if (!root) {\n        throw new Error('Could not find workspace root');\n      }\n\n      const depsService = new DepsService(root.location);\n      depsService.__setLogger(logger);\n      const sanitizedName = slugify(pkgName);\n\n      const tgzPath = depsService.getWorkspaceDependencyPath({\n        pkgName: sanitizedName,\n        version: dep.version!,\n      });\n      resolutions[pkgName] = tgzPath;\n      usedWorkspacePackages.add(pkgName);\n\n      for (const [depName, _depVersion] of Object.entries(dep?.dependencies ?? {})) {\n        if (!usedWorkspacePackages.has(depName) && workspaceMap.has(depName)) {\n          queue.push(depName);\n        }\n      }\n    }\n  }\n\n  return { resolutions, usedWorkspacePackages };\n};\n\n/**\n * Creates TGZ packages for workspace dependencies in the workspace-module directory\n */\nexport const packWorkspaceDependencies = async ({\n  workspaceMap,\n  usedWorkspacePackages,\n  bundleOutputDir,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  bundleOutputDir: string;\n  logger: IMastraLogger;\n  usedWorkspacePackages: Set<string>;\n}): Promise<void> => {\n  const root = findWorkspacesRoot();\n  if (!root) {\n    throw new Error('Could not find workspace root');\n  }\n\n  const depsService = new DepsService(root.location);\n  depsService.__setLogger(logger);\n\n  // package all workspace dependencies\n  if (usedWorkspacePackages.size > 0) {\n    const workspaceDirPath = join(bundleOutputDir, 'workspace-module');\n    await ensureDir(workspaceDirPath);\n\n    logger.info(`Packaging ${usedWorkspacePackages.size} workspace dependencies...`);\n\n    const batchSize = 5;\n    const packages = Array.from(usedWorkspacePackages.values());\n\n    for (let i = 0; i < packages.length; i += batchSize) {\n      const batch = packages.slice(i, i + batchSize);\n      logger.info(\n        `Packaging batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(packages.length / batchSize)}: ${batch.join(', ')}`,\n      );\n      await Promise.all(\n        batch.map(async pkgName => {\n          const dep = workspaceMap.get(pkgName);\n          const sanitizedName = slugify(pkgName);\n          if (!dep) return;\n\n          await depsService.pack({ dir: dep.location, destination: workspaceDirPath, sanitizedName: sanitizedName });\n        }),\n      );\n    }\n\n    logger.info(`Successfully packaged ${usedWorkspacePackages.size} workspace dependencies`);\n  }\n};\n","import { builtinModules } from 'node:module';\n\nexport function isNodeBuiltin(dep: string): boolean {\n  const [pkg] = dep.split('/');\n\n  return dep.startsWith('node:') || builtinModules.includes(dep) || builtinModules.includes(pkg!);\n}\n","import babel from '@babel/core';\n\nexport function removeDeployer() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-deployer',\n    visitor: {\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        if (!state.hasReplaced) {\n          state.hasReplaced = true;\n          const newMastraObj = t.cloneNode(path.node);\n          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.[0]) {\n            const deployer = newMastraObj.arguments[0].properties.find(\n              prop => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === 'deployer',\n            );\n\n            if (!deployer) {\n              return;\n            }\n\n            newMastraObj.arguments[0].properties = newMastraObj.arguments[0].properties.filter(\n              prop => prop !== deployer,\n            );\n\n            // try to find the binding of the deployer which should be the reference to the deployer\n            if (t.isObjectProperty(deployer) && t.isIdentifier(deployer.value)) {\n              const deployerBinding = state.file.scope.getBinding(deployer.value.name);\n\n              if (deployerBinding) {\n                deployerBinding?.path?.parentPath?.remove();\n              }\n            }\n\n            path.replaceWith(newMastraObj);\n          }\n        }\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport type { Plugin } from 'rollup';\n\nimport { removeDeployer as removeDeployerBabelPlugin } from '../babel/remove-deployer';\n\nexport function removeDeployer(mastraEntry: string, options?: { sourcemap?: boolean }): Plugin {\n  return {\n    name: 'remove-deployer',\n    transform(code, id) {\n      if (id !== mastraEntry) {\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        babel.transform(\n          code,\n          {\n            babelrc: false,\n            configFile: false,\n            filename: id,\n            plugins: [removeDeployerBabelPlugin],\n            sourceMaps: options?.sourcemap,\n          },\n          (err, result) => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve({\n              code: result!.code!,\n              map: result!.map!,\n            });\n          },\n        );\n      });\n    },\n  } satisfies Plugin;\n}\n","export const DEPS_TO_IGNORE = ['#tools'];\n\nexport const GLOBAL_EXTERNALS = [\n  'pino',\n  'pino-pretty',\n  '@libsql/client',\n  'pg',\n  'libsql',\n  '#tools',\n  'typescript',\n  'undici',\n];\nexport const DEPRECATED_EXTERNALS = ['fastembed', 'nodemailer', 'jsdom', 'sqlite3'];\n","import { noopLogger, type IMastraLogger } from '@mastra/core/logger';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport virtual from '@rollup/plugin-virtual';\nimport { fileURLToPath } from 'node:url';\nimport { rollup, type OutputChunk, type Plugin, type SourceMap } from 'rollup';\nimport resolveFrom from 'resolve-from';\nimport { esbuild } from '../plugins/esbuild';\nimport { isNodeBuiltin } from '../isNodeBuiltin';\nimport { removeDeployer } from '../plugins/remove-deployer';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport { getPackageName, getPackageRootPath, slash } from '../utils';\nimport { type WorkspacePackageInfo } from '../../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from '../types';\nimport { DEPS_TO_IGNORE } from './constants';\n\n/**\n * Configures and returns the Rollup plugins needed for analyzing entry files.\n * Sets up module resolution, transpilation, and custom alias handling for Mastra-specific imports.\n */\nfunction getInputPlugins(\n  { entry, isVirtualFile }: { entry: string; isVirtualFile: boolean },\n  mastraEntry: string,\n  { sourcemapEnabled }: { sourcemapEnabled: boolean },\n): Plugin[] {\n  const normalizedMastraEntry = slash(mastraEntry);\n  let virtualPlugin = null;\n  if (isVirtualFile) {\n    virtualPlugin = virtual({\n      '#entry': entry,\n    });\n    entry = '#entry';\n  }\n\n  const plugins = [];\n  if (virtualPlugin) {\n    plugins.push(virtualPlugin);\n  }\n\n  plugins.push(\n    ...[\n      tsConfigPaths(),\n      {\n        name: 'custom-alias-resolver',\n        resolveId(id: string) {\n          if (id === '#server') {\n            return slash(fileURLToPath(import.meta.resolve('@mastra/deployer/server')));\n          }\n          if (id === '#mastra') {\n            return normalizedMastraEntry;\n          }\n          if (id.startsWith('@mastra/server')) {\n            return fileURLToPath(import.meta.resolve(id));\n          }\n        },\n      } satisfies Plugin,\n      json(),\n      esbuild(),\n      commonjs({\n        strictRequires: 'debug',\n        ignoreTryCatch: false,\n        transformMixedEsModules: true,\n        extensions: ['.js', '.ts'],\n      }),\n      removeDeployer(mastraEntry, { sourcemap: sourcemapEnabled }),\n      esbuild(),\n    ],\n  );\n\n  return plugins;\n}\n\n/**\n * Extracts and categorizes dependencies from Rollup output to determine which ones need optimization.\n * Analyzes both static imports and dynamic imports while filtering out Node.js built-ins and ignored dependencies.\n * Identifies workspace packages and resolves package root paths for proper bundling optimization.\n */\nasync function captureDependenciesToOptimize(\n  output: OutputChunk,\n  workspaceMap: Map<string, WorkspacePackageInfo>,\n  projectRoot: string,\n  {\n    logger,\n  }: {\n    logger: IMastraLogger;\n  },\n): Promise<Map<string, DependencyMetadata>> {\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n\n  if (!output.facadeModuleId) {\n    throw new Error(\n      'Something went wrong, we could not find the package name of the entry file. Please open an issue.',\n    );\n  }\n\n  let entryRootPath = projectRoot;\n  if (!output.facadeModuleId.startsWith('\\x00virtual:')) {\n    entryRootPath = (await getPackageRootPath(output.facadeModuleId)) || projectRoot;\n  }\n\n  for (const [dependency, bindings] of Object.entries(output.importedBindings)) {\n    if (isNodeBuiltin(dependency) || DEPS_TO_IGNORE.includes(dependency)) {\n      continue;\n    }\n\n    // The `getPackageName` helper also handles subpaths so we only get the proper package name\n    const pkgName = getPackageName(dependency);\n    let rootPath: string | null = null;\n    let isWorkspace = false;\n\n    if (pkgName) {\n      rootPath = await getPackageRootPath(dependency, entryRootPath);\n      isWorkspace = workspaceMap.has(pkgName);\n    }\n\n    const normalizedRootPath = rootPath ? slash(rootPath) : null;\n\n    depsToOptimize.set(dependency, { exports: bindings, rootPath: normalizedRootPath, isWorkspace });\n  }\n\n  /**\n   * Recursively discovers and analyzes transitive workspace dependencies\n   */\n  async function checkTransitiveDependencies(\n    internalMap: Map<string, DependencyMetadata>,\n    maxDepth = 10,\n    currentDepth = 0,\n  ) {\n    // Could be a circular dependency...\n    if (currentDepth >= maxDepth) {\n      logger.warn('Maximum dependency depth reached while checking transitive dependencies.');\n      return;\n    }\n\n    // Make a copy so that we can safely iterate over it\n    const depsSnapshot = new Map(depsToOptimize);\n    let hasAddedDeps = false;\n\n    for (const [dep, meta] of depsSnapshot) {\n      // We only care about workspace deps that we haven't already processed\n      if (!meta.isWorkspace || internalMap.has(dep)) {\n        continue;\n      }\n\n      try {\n        // Absolute path to the dependency\n        const resolvedPath = resolveFrom(projectRoot, dep);\n\n        if (!resolvedPath) {\n          logger.warn(`Could not resolve path for workspace dependency ${dep}`);\n          continue;\n        }\n\n        const analysis = await analyzeEntry({ entry: resolvedPath, isVirtualFile: false }, '', {\n          workspaceMap,\n          projectRoot,\n          logger: noopLogger,\n          sourcemapEnabled: false,\n        });\n\n        if (!analysis?.dependencies) {\n          continue;\n        }\n\n        for (const [innerDep, innerMeta] of analysis.dependencies) {\n          /**\n           * Only add to depsToOptimize if:\n           * - It's a workspace package\n           * - We haven't already processed it\n           * - We haven't already discovered it at the beginning\n           */\n          if (innerMeta.isWorkspace && !internalMap.has(innerDep) && !depsToOptimize.has(innerDep)) {\n            depsToOptimize.set(innerDep, innerMeta);\n            internalMap.set(innerDep, innerMeta);\n            hasAddedDeps = true;\n          }\n        }\n      } catch (err) {\n        logger.error(`Failed to resolve or analyze dependency ${dep}: ${(err as Error).message}`);\n      }\n    }\n\n    // Continue until no new deps are found\n    if (hasAddedDeps) {\n      await checkTransitiveDependencies(internalMap, maxDepth, currentDepth + 1);\n    }\n  }\n\n  await checkTransitiveDependencies(new Map());\n\n  // #tools is a generated dependency, we don't want our analyzer to handle it\n  const dynamicImports = output.dynamicImports.filter(d => !DEPS_TO_IGNORE.includes(d));\n  if (dynamicImports.length) {\n    for (const dynamicImport of dynamicImports) {\n      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {\n        depsToOptimize.set(dynamicImport, { exports: ['*'], rootPath: null, isWorkspace: false });\n      }\n    }\n  }\n\n  return depsToOptimize;\n}\n\n/**\n * Analyzes the entry file to identify external dependencies and their imports. This allows us to treeshake all code that is not used.\n *\n * @param entryConfig - Configuration object for the entry file\n * @param entryConfig.entry - The entry file path or content\n * @param entryConfig.isVirtualFile - Whether the entry is a virtual file (content string) or a file path\n * @param mastraEntry - The mastra entry point\n * @param options - Configuration options for the analysis\n * @param options.logger - Logger instance for debugging\n * @param options.sourcemapEnabled - Whether sourcemaps are enabled\n * @param options.workspaceMap - Map of workspace packages\n * @returns A promise that resolves to an object containing the analyzed dependencies and generated output\n */\nexport async function analyzeEntry(\n  {\n    entry,\n    isVirtualFile,\n  }: {\n    entry: string;\n    isVirtualFile: boolean;\n  },\n  mastraEntry: string,\n  {\n    logger,\n    sourcemapEnabled,\n    workspaceMap,\n    projectRoot,\n  }: {\n    logger: IMastraLogger;\n    sourcemapEnabled: boolean;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    projectRoot: string;\n  },\n): Promise<{\n  dependencies: Map<string, DependencyMetadata>;\n  output: {\n    code: string;\n    map: SourceMap | null;\n  };\n}> {\n  const optimizerBundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: isVirtualFile ? '#entry' : entry,\n    treeshake: 'smallest',\n    preserveSymlinks: true,\n    plugins: getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }),\n    external: DEPS_TO_IGNORE,\n  });\n\n  const { output } = await optimizerBundler.generate({\n    format: 'esm',\n    inlineDynamicImports: true,\n  });\n\n  await optimizerBundler.close();\n\n  const depsToOptimize = await captureDependenciesToOptimize(output[0] as OutputChunk, workspaceMap, projectRoot, {\n    logger,\n  });\n\n  return {\n    dependencies: depsToOptimize,\n    output: {\n      code: output[0].code,\n      map: output[0].map as SourceMap,\n    },\n  };\n}\n","import { fileURLToPath } from 'node:url';\nimport type { Plugin } from 'rollup';\n\n// hono is imported from deployer, so we need to resolve from here instead of the project root\nexport function aliasHono(): Plugin {\n  return {\n    name: 'hono-alias',\n    resolveId(id: string) {\n      if (!id.startsWith('@hono/') && !id.startsWith('hono/') && id !== 'hono' && id !== 'hono-openapi') {\n        return;\n      }\n\n      const path = import.meta.resolve(id);\n      return fileURLToPath(path);\n    },\n  } satisfies Plugin;\n}\n","import commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport virtual from '@rollup/plugin-virtual';\nimport esmShim from '@rollup/plugin-esm-shim';\nimport { basename } from 'node:path/posix';\nimport * as path from 'node:path';\nimport { rollup, type OutputChunk, type OutputAsset, type Plugin } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport { aliasHono } from '../plugins/hono-alias';\nimport { getCompiledDepCachePath, getPackageRootPath, rollupSafeName, slash } from '../utils';\nimport { type WorkspacePackageInfo } from '../../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from '../types';\nimport { DEPS_TO_IGNORE, GLOBAL_EXTERNALS, DEPRECATED_EXTERNALS } from './constants';\nimport * as resolve from 'resolve.exports';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport { readFile } from 'node:fs/promises';\nimport { getPackageInfo } from 'local-pkg';\nimport { ErrorCategory, ErrorDomain, MastraBaseError } from '@mastra/core/error';\n\ntype VirtualDependency = {\n  name: string;\n  virtual: string;\n};\n\nfunction prepareEntryFileName(name: string, rootDir: string) {\n  return rollupSafeName(name, rootDir);\n}\n\n/**\n * Creates virtual dependency modules for optimized bundling by generating virtual entry points for each dependency with their specific exports and handling workspace package path resolution.\n */\nexport function createVirtualDependencies(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  {\n    projectRoot,\n    workspaceRoot,\n    outputDir,\n    bundlerOptions,\n  }: { workspaceRoot: string | null; projectRoot: string; outputDir: string; bundlerOptions?: { isDev?: boolean } },\n): {\n  optimizedDependencyEntries: Map<string, VirtualDependency>;\n  fileNameToDependencyMap: Map<string, string>;\n} {\n  const { isDev = false } = bundlerOptions || {};\n  const fileNameToDependencyMap = new Map<string, string>();\n  const optimizedDependencyEntries = new Map<string, VirtualDependency>();\n  const rootDir = workspaceRoot || projectRoot;\n\n  for (const [dep, { exports }] of depsToOptimize.entries()) {\n    const fileName = dep.replaceAll('/', '-');\n    const virtualFile: string[] = [];\n    const exportStringBuilder = [];\n\n    for (const local of exports) {\n      if (local === '*') {\n        virtualFile.push(`export * from '${dep}';`);\n        continue;\n      } else if (local === 'default') {\n        exportStringBuilder.push('default');\n      } else {\n        exportStringBuilder.push(local);\n      }\n    }\n\n    const chunks = [];\n    if (exportStringBuilder.length) {\n      chunks.push(`{ ${exportStringBuilder.join(', ')} }`);\n    }\n    if (chunks.length) {\n      virtualFile.push(`export ${chunks.join(', ')} from '${dep}';`);\n    }\n\n    // Determine the entry name based on the complexity of exports\n    let entryName = prepareEntryFileName(path.join(outputDir, fileName), rootDir);\n\n    fileNameToDependencyMap.set(entryName, dep);\n    optimizedDependencyEntries.set(dep, {\n      name: entryName,\n      virtual: virtualFile.join('\\n'),\n    });\n  }\n\n  // For workspace packages, we still want the dependencies to be imported from the original path\n  // We rewrite the path to the original folder inside node_modules/.cache\n  if (isDev) {\n    for (const [dep, { isWorkspace, rootPath }] of depsToOptimize.entries()) {\n      if (!isWorkspace || !rootPath || !workspaceRoot) {\n        continue;\n      }\n\n      const currentDepPath = optimizedDependencyEntries.get(dep);\n      if (!currentDepPath) {\n        continue;\n      }\n\n      const fileName = basename(currentDepPath.name);\n      const entryName = prepareEntryFileName(getCompiledDepCachePath(rootPath, fileName), rootDir);\n\n      fileNameToDependencyMap.set(entryName, dep);\n      optimizedDependencyEntries.set(dep, {\n        ...currentDepPath,\n        name: entryName,\n      });\n    }\n  }\n\n  return { optimizedDependencyEntries, fileNameToDependencyMap };\n}\n\n/**\n * Configures and returns Rollup plugins for bundling external dependencies.\n * Sets up virtual modules, TypeScript compilation, CommonJS transformation, and workspace resolution.\n */\nasync function getInputPlugins(\n  virtualDependencies: Map<string, { name: string; virtual: string }>,\n  {\n    transpilePackages,\n    workspaceMap,\n    bundlerOptions,\n    rootDir,\n  }: {\n    transpilePackages: Set<string>;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    bundlerOptions: { enableEsmShim: boolean; isDev: boolean };\n    rootDir: string;\n  },\n) {\n  const transpilePackagesMap = new Map<string, string>();\n  for (const pkg of transpilePackages) {\n    const dir = await getPackageRootPath(pkg);\n\n    if (dir) {\n      transpilePackagesMap.set(pkg, slash(dir));\n    } else {\n      transpilePackagesMap.set(pkg, workspaceMap.get(pkg)?.location ?? pkg);\n    }\n  }\n\n  return [\n    virtual(\n      Array.from(virtualDependencies.entries()).reduce(\n        (acc, [dep, virtualDep]) => {\n          acc[`#virtual-${dep}`] = virtualDep.virtual;\n          return acc;\n        },\n        {} as Record<string, string>,\n      ),\n    ),\n    transpilePackagesMap.size\n      ? esbuild({\n          format: 'esm',\n          include: [...transpilePackagesMap.values()].map(p => {\n            // Match files from transpilePackages but exclude any nested node_modules\n            // Escapes regex special characters in the path and uses negative lookahead to avoid node_modules\n            // generated by cursor\n            if (path.isAbsolute(p)) {\n              return new RegExp(`^${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n            } else {\n              return new RegExp(`\\/${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n            }\n          }),\n        })\n      : null,\n    bundlerOptions.isDev\n      ? ({\n          name: 'alias-optimized-deps',\n          async resolveId(id, importer, options) {\n            if (!virtualDependencies.has(id)) {\n              return null;\n            }\n\n            const info = virtualDependencies.get(id)!;\n            // go from ./node_modules/.cache/index.js to ./pkg\n            const packageRootPath = path.join(rootDir, path.dirname(path.dirname(path.dirname(info.name))));\n            const pkgJsonBuffer = await readFile(path.join(packageRootPath, 'package.json'), 'utf-8');\n            const pkgJson = JSON.parse(pkgJsonBuffer);\n            if (!pkgJson) {\n              return null;\n            }\n\n            const pkgName = pkgJson.name || '';\n            let resolvedPath: string | undefined = resolve.exports(pkgJson, id.replace(pkgName, '.'))?.[0];\n            if (!resolvedPath) {\n              resolvedPath = pkgJson!.main ?? 'index.js';\n            }\n\n            return await this.resolve(path.posix.join(packageRootPath, resolvedPath!), importer, options);\n          },\n        } satisfies Plugin)\n      : null,\n    optimizeLodashImports({\n      include: '**/*.{js,ts,mjs,cjs}',\n    }),\n    commonjs({\n      strictRequires: 'strict',\n      transformMixedEsModules: true,\n      ignoreTryCatch: false,\n    }),\n    bundlerOptions.isDev ? null : nodeResolve(),\n    bundlerOptions.isDev ? esmShim() : null,\n    // hono is imported from deployer, so we need to resolve from here instead of the project root\n    aliasHono(),\n    json(),\n    {\n      name: 'not-found-resolver',\n      resolveId: {\n        order: 'post',\n        async handler(id, importer) {\n          if (!importer) {\n            return null;\n          }\n\n          if (!id.endsWith('.node')) {\n            return null;\n          }\n\n          const pkgInfo = await getPackageInfo(importer);\n          const packageName = pkgInfo?.packageJson?.name || id;\n          throw new MastraBaseError({\n            id: 'DEPLOYER_BUNDLE_EXTERNALS_MISSING_NATIVE_BUILD',\n            domain: ErrorDomain.DEPLOYER,\n            category: ErrorCategory.USER,\n            details: {\n              importFile: importer,\n              packageName,\n            },\n            text: `We found a binary dependency in your bundle. Please add \\`${packageName}\\` to your externals.\n  \nexport const mastra = new Mastra({\n  bundler: {\n    externals: [\"${packageName}\"],\n  }\n})`,\n          });\n        },\n      },\n    } satisfies Plugin,\n  ].filter(Boolean);\n}\n\n/**\n * Executes the Rollup build process for virtual dependencies using configured plugins.\n * Bundles all virtual dependency modules into optimized ESM files with proper external handling.\n */\nasync function buildExternalDependencies(\n  virtualDependencies: Map<string, VirtualDependency>,\n  {\n    externals,\n    packagesToTranspile,\n    workspaceMap,\n    rootDir,\n    outputDir,\n    bundlerOptions,\n  }: {\n    externals: string[];\n    packagesToTranspile: Set<string>;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    rootDir: string;\n    outputDir: string;\n    bundlerOptions: {\n      enableEsmShim: boolean;\n      isDev: boolean;\n    };\n  },\n) {\n  /**\n   * If there are no virtual dependencies to bundle, return an empty array to avoid Rollup errors.\n   */\n  if (virtualDependencies.size === 0) {\n    return [] as unknown as [OutputChunk, ...(OutputAsset | OutputChunk)[]];\n  }\n  const bundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: Array.from(virtualDependencies.entries()).reduce(\n      (acc, [dep, virtualDep]) => {\n        acc[virtualDep.name] = `#virtual-${dep}`;\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n    external: externals,\n    treeshake: 'smallest',\n    plugins: getInputPlugins(virtualDependencies, {\n      transpilePackages: packagesToTranspile,\n      workspaceMap,\n      bundlerOptions,\n      rootDir,\n    }),\n  });\n\n  const outputDirRelative = prepareEntryFileName(outputDir, rootDir);\n\n  const { output } = await bundler.write({\n    format: 'esm',\n    dir: rootDir,\n    entryFileNames: '[name].mjs',\n    /**\n     * Rollup creates chunks for common dependencies, but these chunks are by default written to the root directory instead of respecting the entryFileNames structure.\n     * So we want to write them to the `.mastra/output` folder as well.\n     */\n    chunkFileNames: `${outputDirRelative}/[name].mjs`,\n    hoistTransitiveImports: false,\n  });\n\n  await bundler.close();\n\n  return output;\n}\n\n/**\n * Recursively searches through Rollup output chunks to find which module imports a specific external dependency.\n * Used to build the module resolution map for proper external dependency tracking.\n */\nfunction findExternalImporter(module: OutputChunk, external: string, allOutputs: OutputChunk[]): OutputChunk | null {\n  const capturedFiles = new Set();\n\n  for (const id of module.imports) {\n    if (id === external) {\n      return module;\n    } else {\n      if (id.endsWith('.mjs')) {\n        capturedFiles.add(id);\n      }\n    }\n  }\n\n  for (const file of capturedFiles) {\n    const nextModule = allOutputs.find(o => o.fileName === file);\n    if (nextModule) {\n      const importer = findExternalImporter(nextModule, external, allOutputs);\n\n      if (importer) {\n        return importer;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Bundles vendor dependencies identified in the analysis step.\n * Creates virtual modules for each dependency and bundles them using rollup.\n *\n * @param depsToOptimize - Map of dependencies to optimize with their metadata (exported bindings, rootPath, isWorkspace)\n * @param outputDir - Directory where bundled files will be written\n * @param logger - Logger instance for debugging\n * @returns Object containing bundle output and reference map for validation\n */\nexport async function bundleExternals(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  outputDir: string,\n  options: {\n    bundlerOptions?: {\n      externals?: string[];\n      transpilePackages?: string[];\n      isDev?: boolean;\n      enableEsmShim?: boolean;\n    } | null;\n    projectRoot?: string;\n    workspaceRoot?: string;\n    workspaceMap?: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  const { workspaceRoot = null, workspaceMap = new Map(), projectRoot = outputDir, bundlerOptions = {} } = options;\n  const {\n    externals: customExternals = [],\n    transpilePackages = [],\n    isDev = false,\n    enableEsmShim = true,\n  } = bundlerOptions || {};\n  const allExternals = [...GLOBAL_EXTERNALS, ...DEPRECATED_EXTERNALS, ...customExternals];\n\n  const workspacePackagesNames = Array.from(workspaceMap.keys());\n  const packagesToTranspile = new Set([...transpilePackages, ...workspacePackagesNames]);\n\n  const { optimizedDependencyEntries, fileNameToDependencyMap } = createVirtualDependencies(depsToOptimize, {\n    workspaceRoot,\n    outputDir,\n    projectRoot,\n    bundlerOptions: {\n      isDev,\n    },\n  });\n\n  const output = await buildExternalDependencies(optimizedDependencyEntries, {\n    externals: allExternals,\n    packagesToTranspile,\n    workspaceMap,\n    rootDir: workspaceRoot || projectRoot,\n    outputDir,\n    bundlerOptions: {\n      enableEsmShim,\n      isDev,\n    },\n  });\n\n  const moduleResolveMap = new Map<string, Map<string, string>>();\n  const filteredChunks = output.filter(o => o.type === 'chunk');\n\n  for (const o of filteredChunks.filter(o => o.isEntry || o.isDynamicEntry)) {\n    for (const external of allExternals) {\n      if (DEPS_TO_IGNORE.includes(external)) {\n        continue;\n      }\n\n      const importer = findExternalImporter(o, external, filteredChunks);\n\n      if (importer) {\n        const fullPath = path.join(workspaceRoot || projectRoot, importer.fileName);\n        let innerMap = moduleResolveMap.get(fullPath);\n\n        if (!innerMap) {\n          innerMap = new Map<string, string>();\n          moduleResolveMap.set(fullPath, innerMap);\n        }\n\n        if (importer.moduleIds.length) {\n          innerMap.set(\n            external,\n            importer.moduleIds[importer.moduleIds.length - 1]?.startsWith('\\x00virtual:#virtual')\n              ? importer.moduleIds[importer.moduleIds.length - 2]!\n              : importer.moduleIds[importer.moduleIds.length - 1]!,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert moduleResolveMap to a plain object with prototype-less objects\n   */\n  const usedExternals = Object.create(null) as Record<string, Record<string, string>>;\n  for (const [fullPath, innerMap] of moduleResolveMap) {\n    const innerObj = Object.create(null) as Record<string, string>;\n    for (const [external, value] of innerMap) {\n      innerObj[external] = value;\n    }\n    usedExternals[fullPath] = innerObj;\n  }\n\n  return { output, fileNameToDependencyMap, usedExternals };\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport * as babel from '@babel/core';\nimport { existsSync } from 'node:fs';\nimport { readFile, writeFile } from 'node:fs/promises';\nimport type { OutputAsset, OutputChunk } from 'rollup';\nimport { join } from 'node:path';\nimport { validate } from '../validator/validate';\nimport { getBundlerOptions } from './bundlerOptions';\nimport { checkConfigExport } from './babel/check-config-export';\nimport { getWorkspaceInformation, type WorkspacePackageInfo } from '../bundler/workspaceDependencies';\nimport type { DependencyMetadata } from './types';\nimport { analyzeEntry } from './analyze/analyzeEntry';\nimport { bundleExternals } from './analyze/bundleExternals';\nimport { getPackageInfo } from 'local-pkg';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { findNativePackageModule } from './utils';\n\n/**\n * Validates the bundled output by attempting to import each generated module.\n * Tracks external dependencies that couldn't be bundled.\n *\n * @param output - Bundle output from rollup\n * @param reverseVirtualReferenceMap - Map to resolve virtual module names back to original deps\n * @param outputDir - Directory containing the bundled files\n * @param logger - Logger instance for debugging\n * @param workspaceMap - Map of workspace packages that gets directly passed through for later consumption\n * @returns Analysis result containing dependency mappings\n */\nasync function validateOutput(\n  {\n    output,\n    reverseVirtualReferenceMap,\n    usedExternals,\n    outputDir,\n    projectRoot,\n    workspaceMap,\n  }: {\n    output: (OutputChunk | OutputAsset)[];\n    reverseVirtualReferenceMap: Map<string, string>;\n    usedExternals: Record<string, Record<string, string>>;\n    outputDir: string;\n    projectRoot: string;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n  logger: IMastraLogger,\n) {\n  const result = {\n    dependencies: new Map<string, string>(),\n    externalDependencies: new Set<string>(),\n    workspaceMap,\n  };\n\n  // store resolve map for validation\n  await writeFile(join(outputDir, 'module-resolve-map.json'), JSON.stringify(usedExternals, null, 2));\n\n  // we should resolve the version of the deps\n  for (const deps of Object.values(usedExternals)) {\n    for (const dep of Object.keys(deps)) {\n      result.externalDependencies.add(dep);\n    }\n  }\n\n  for (const file of output) {\n    if (file.type === 'asset') {\n      continue;\n    }\n\n    try {\n      logger.debug(`Validating if ${file.fileName} is a valid module.`);\n      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n        result.dependencies.set(reverseVirtualReferenceMap.get(file.name)!, file.fileName);\n      }\n\n      if (!file.isDynamicEntry && file.isEntry) {\n        // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n        await validate(join(projectRoot, file.fileName));\n      }\n    } catch (err) {\n      if (err instanceof Error && err.message.includes('Error: No native build was found for ')) {\n        const moduleName = findNativePackageModule(file.moduleIds);\n\n        if (!moduleName) {\n          logger.debug(`Could not determine the module name for file ${file.fileName}`);\n          continue;\n        }\n\n        const pkgInfo = await getPackageInfo(moduleName);\n        const packageName = pkgInfo?.packageJson?.name;\n\n        if (packageName) {\n          throw new MastraError({\n            id: 'DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD',\n            domain: ErrorDomain.DEPLOYER,\n            category: ErrorCategory.USER,\n            details: {\n              importFile: moduleName,\n              packageName: packageName,\n            },\n            text: `We found a binary dependency in your bundle. Please add \\`${packageName}\\` to your externals.\n\nexport const mastra = new Mastra({\n  bundler: {\n    externals: [\"${packageName}\"],\n  }\n})`,\n          });\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Main bundle analysis function that orchestrates the three-step process:\n * 1. Analyze dependencies\n * 2. Bundle dependencies modules\n * 3. Validate generated bundles\n *\n * This helps identify which dependencies need to be externalized vs bundled.\n */\nexport async function analyzeBundle(\n  entries: string[],\n  mastraEntry: string,\n  {\n    outputDir,\n    projectRoot,\n    isDev = false,\n    bundlerOptions: _bundlerOptions,\n  }: {\n    outputDir: string;\n    projectRoot: string;\n    platform: 'node' | 'browser';\n    isDev?: boolean;\n    bundlerOptions?: {\n      enableEsmShim?: boolean;\n    } | null;\n  },\n  logger: IMastraLogger,\n) {\n  const mastraConfig = await readFile(mastraEntry, 'utf-8');\n  const mastraConfigResult = {\n    hasValidConfig: false,\n  } as const;\n\n  await babel.transformAsync(mastraConfig, {\n    filename: mastraEntry,\n    presets: [import.meta.resolve('@babel/preset-typescript')],\n    plugins: [checkConfigExport(mastraConfigResult)],\n  });\n\n  if (!mastraConfigResult.hasValidConfig) {\n    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:\nexport const mastra = new Mastra({\n  // your options\n})\n  \nIf you think your configuration is valid, please open an issue.`);\n  }\n\n  const { enableEsmShim = true } = _bundlerOptions || {};\n  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);\n  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: mastraEntry });\n\n  let index = 0;\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n\n  logger.info('Analyzing dependencies...');\n\n  for (const entry of entries) {\n    const isVirtualFile = entry.includes('\\n') || !existsSync(entry);\n    const analyzeResult = await analyzeEntry({ entry, isVirtualFile }, mastraEntry, {\n      logger,\n      sourcemapEnabled: bundlerOptions?.sourcemap ?? false,\n      workspaceMap,\n      projectRoot,\n    });\n\n    // Write the entry file to the output dir so that we can use it for workspace resolution stuff\n    await writeFile(join(outputDir, `entry-${index++}.mjs`), analyzeResult.output.code);\n\n    // Merge dependencies from each entry (main, tools, etc.)\n    for (const [dep, metadata] of analyzeResult.dependencies.entries()) {\n      if (depsToOptimize.has(dep)) {\n        // Merge with existing exports if dependency already exists\n        const existingEntry = depsToOptimize.get(dep)!;\n        depsToOptimize.set(dep, {\n          ...existingEntry,\n          exports: [...new Set([...existingEntry.exports, ...metadata.exports])],\n        });\n      } else {\n        depsToOptimize.set(dep, metadata);\n      }\n    }\n  }\n\n  /**\n   * Only during `mastra dev` we want to optimize workspace packages. In previous steps we might have added dependencies that are not workspace packages, so we gotta remove them again.\n   */\n  if (isDev) {\n    for (const [dep, metadata] of depsToOptimize.entries()) {\n      if (!metadata.isWorkspace) {\n        depsToOptimize.delete(dep);\n      }\n    }\n  }\n\n  logger.debug(`Analyzed dependencies: ${Array.from(depsToOptimize.keys()).join(', ')}`);\n\n  logger.info('Optimizing dependencies...');\n  logger.debug(\n    `${Array.from(depsToOptimize.keys())\n      .map(key => `- ${key}`)\n      .join('\\n')}`,\n  );\n\n  const { output, fileNameToDependencyMap, usedExternals } = await bundleExternals(depsToOptimize, outputDir, {\n    bundlerOptions: {\n      ...bundlerOptions,\n      enableEsmShim,\n      isDev,\n    },\n    projectRoot,\n    workspaceRoot,\n    workspaceMap,\n  });\n\n  const result = await validateOutput(\n    {\n      output,\n      reverseVirtualReferenceMap: fileNameToDependencyMap,\n      usedExternals,\n      outputDir,\n      projectRoot: workspaceRoot || projectRoot,\n      workspaceMap,\n    },\n    logger,\n  );\n\n  return result;\n}\n"]}