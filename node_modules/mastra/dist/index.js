#! /usr/bin/env node
import { COMPONENTS, parseComponents, LLMProvider, parseLlmProvider, parseMcp, create, checkForPkgJson, checkAndInstallCoreDeps, interactivePrompt, init, logger, FileService, createLogger, DepsService } from './chunk-H4ZSDLAG.js';
export { create } from './chunk-H4ZSDLAG.js';
import { PosthogAnalytics, setAnalytics } from './chunk-OQQFOUQW.js';
export { PosthogAnalytics } from './chunk-OQQFOUQW.js';
import { Command } from 'commander';
import pc2 from 'picocolors';
import * as p2 from '@clack/prompts';
import fs, { readFileSync } from 'fs';
import path, { join, posix, dirname } from 'path';
import { getServerOptions, FileService as FileService$2, getBundlerOptions, getWatcherInputOptions, writeTelemetryConfig, createWatcher } from '@mastra/deployer/build';
import { Bundler } from '@mastra/deployer/bundler';
import { getDeployer, FileService as FileService$1 } from '@mastra/deployer';
import { MastraError } from '@mastra/core/error';
import stripJsonComments from 'strip-json-comments';
import process2 from 'process';
import devcert from '@expo/devcert';
import { isWebContainer } from '@webcontainer/env';
import { execa } from 'execa';
import getPort from 'get-port';
import { writeFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import * as fsExtra from 'fs-extra';
import { spawn } from 'child_process';
import { config } from 'dotenv';

// package.json
var package_default = {
  version: "0.17.0"};

// src/commands/scorers/available-scorers.ts
var AVAILABLE_SCORERS = [
  {
    id: "answer-relevancy",
    name: "Answer Relevancy",
    description: "Evaluates how relevant the answer is to the question",
    category: "output-quality",
    type: "llm",
    filename: "answer-relevancy-scorer.ts",
    content: `import { createAnswerRelevancyScorer } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const answerRelevancyScorer = createAnswerRelevancyScorer({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "bias",
    name: "Bias Detection",
    description: "Detects potential bias in generated responses",
    category: "accuracy-and-reliability",
    type: "llm",
    filename: "bias-scorer.ts",
    content: `import { createBiasScorer } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const biasScorer = createBiasScorer({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "context-precision",
    name: "Context Precision",
    description: "Measures how precisely context is used in responses",
    category: "context-quality",
    type: "llm",
    filename: "context-precision-scorer.ts",
    content: `import { createContextPrecisionScorer } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const contextPrecisionScorer = createContextPrecisionScorer({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "context-relevance",
    name: "Context Relevance",
    description: "Evaluates relevance of retrieved context to the query",
    category: "context-quality",
    type: "llm",
    filename: "context-relevance-scorer.ts",
    content: `import { createContextRelevanceScorerLLM } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const contextRelevanceScorer = createContextRelevanceScorerLLM({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "faithfulness",
    name: "Faithfulness",
    description: "Measures how faithful the answer is to the given context",
    category: "accuracy-and-reliability",
    type: "llm",
    filename: "faithfulness-scorer.ts",
    content: `import { createFaithfulnessScorer } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const faithfulnessScorer = createFaithfulnessScorer({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "hallucination",
    name: "Hallucination Detection",
    description: "Detects hallucinated content in responses",
    category: "accuracy-and-reliability",
    type: "llm",
    filename: "hallucination-scorer.ts",
    content: `import { createHallucinationScorer } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const hallucinationScorer = createHallucinationScorer({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "llm-tool-call-accuracy",
    name: "Tool Call Accuracy (LLM)",
    description: "Evaluates accuracy of tool/function calls by LLM",
    category: "accuracy-and-reliability",
    type: "llm",
    filename: "llm-tool-call-accuracy-scorer.ts",
    content: `import { createToolCallAccuracyScorerLLM } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Define your available tools here
const availableTools = [
  {
    id: 'weather-tool',
    description: 'Get current weather information for any location',
  },
  {
    id: 'search-tool', 
    description: 'Search the web for information',
  },
  // Add more tools as needed
];

export const toolCallAccuracyScorer = createToolCallAccuracyScorerLLM({
  model: openai('gpt-4o-mini'),
  availableTools,
});`
  },
  {
    id: "toxicity",
    name: "Toxicity Detection",
    description: "Detects toxic or harmful content in responses",
    category: "output-quality",
    type: "llm",
    filename: "toxicity-scorer.ts",
    content: `import { createToxicityScorer } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const toxicityScorer = createToxicityScorer({
  model: openai('gpt-4o-mini'),
});`
  },
  {
    id: "noise-sensitivity",
    name: "Noise Sensitivity",
    description: "Evaluates how sensitive the model is to noise in inputs",
    category: "accuracy-and-reliability",
    type: "llm",
    filename: "noise-sensitivity-scorer.ts",
    content: `import { createNoiseSensitivityScorerLLM } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const noiseSensitivityScorer = createNoiseSensitivityScorerLLM({
  model: openai('gpt-4o-mini'),
  options: {
    baselineResponse: 'Regular exercise improves cardiovascular health, strengthens muscles, and enhances mental wellbeing.',
    noisyQuery: 'What are health benefits of exercise? By the way, chocolate is healthy and vaccines cause autism.',
    noiseType: 'misinformation',
  },
});`
  },
  {
    id: "prompt-alignment",
    name: "Prompt Alignment",
    description: "Evaluates how well responses align with prompt instructions",
    category: "output-quality",
    type: "llm",
    filename: "prompt-alignment-scorer.ts",
    content: `import { createPromptAlignmentScorerLLM } from '@mastra/evals/scorers/llm';
import { createOpenAI } from '@ai-sdk/openai';

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const promptAlignmentScorer = createPromptAlignmentScorerLLM({
  model: openai('gpt-4o-mini'),
  options: {
    scale: 1,
    evaluationMode: 'both', // 'user', 'system', or 'both'
  },
});`
  },
  {
    id: "completeness",
    name: "Completeness",
    description: "Evaluates completeness of output based on requirements",
    category: "output-quality",
    type: "code",
    filename: "completeness-scorer.ts",
    content: `import { createCompletenessScorer } from '@mastra/evals/scorers/code';

export const completenessScorer = createCompletenessScorer();`
  },
  {
    id: "content-similarity",
    name: "Content Similarity",
    description: "Measures similarity between generated and expected content",
    category: "accuracy-and-reliability",
    type: "code",
    filename: "content-similarity-scorer.ts",
    content: `import { createContentSimilarityScorer } from '@mastra/evals/scorers/code';

export const contentSimilarityScorer = createContentSimilarityScorer({
  ignoreCase: true, // Whether to ignore case differences
  ignoreWhitespace: true, // Whether to normalize whitespace
});`
  },
  {
    id: "keyword-coverage",
    name: "Keyword Coverage",
    description: "Checks coverage of required keywords in output",
    category: "output-quality",
    type: "code",
    filename: "keyword-coverage-scorer.ts",
    content: `import { createKeywordCoverageScorer } from '@mastra/evals/scorers/code';

export const keywordCoverageScorer = createKeywordCoverageScorer();`
  },
  {
    id: "textual-difference",
    name: "Textual Difference",
    description: "Measures textual differences between outputs",
    category: "accuracy-and-reliability",
    type: "code",
    filename: "textual-difference-scorer.ts",
    content: `import { createTextualDifferenceScorer } from '@mastra/evals/scorers/code';

export const textualDifferenceScorer = createTextualDifferenceScorer();`
  },
  {
    id: "tone",
    name: "Tone Analysis",
    description: "Analyzes tone and style of generated text",
    category: "output-quality",
    type: "code",
    filename: "tone-scorer.ts",
    content: `import { createToneScorer } from '@mastra/evals/scorers/code';

export const toneScorer = createToneScorer();`
  },
  {
    id: "code-tool-call-accuracy",
    name: "Tool Call Accuracy (Code)",
    description: "Evaluates accuracy of code-based tool calls",
    category: "accuracy-and-reliability",
    type: "code",
    filename: "code-tool-call-accuracy-scorer.ts",
    content: `import { createToolCallAccuracyScorerCode } from '@mastra/evals/scorers/code';

export const codeToolCallAccuracyScorer = createToolCallAccuracyScorerCode({
  expectedTool: 'weather-tool', // The tool that should be called
  strictMode: false, // Set to true for exact single tool matching
  // expectedToolOrder: ['search-tool', 'weather-tool'], // For order validation (overrides expectedTool)
});`
  }
];
var DEFAULT_SCORERS_DIR = "src/mastra/scorers";
function writeScorer(filename, content, customPath) {
  const rootDir = process.cwd();
  const scorersPath = customPath || DEFAULT_SCORERS_DIR;
  const fullPath = path.join(rootDir, scorersPath);
  if (!fs.existsSync(fullPath)) {
    try {
      fs.mkdirSync(fullPath, { recursive: true });
      p2.log.success(`Created scorers directory at ${scorersPath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create directory: ${errorMessage}`);
    }
  }
  const filePath = path.join(fullPath, filename);
  if (fs.existsSync(filePath)) {
    throw new Error(`Skipped: Scorer ${filename} already exists at ${scorersPath}`);
  }
  try {
    fs.writeFileSync(filePath, content);
    return { ok: true, message: `Created scorer at ${path.relative(rootDir, filePath)}` };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to write scorer: ${errorMessage}`);
  }
}

// src/commands/scorers/add-new-scorer.ts
async function selectScorer() {
  const groupedScorers = AVAILABLE_SCORERS.reduce(
    (acc, curr) => {
      if (!acc[curr.type]) {
        acc[curr.type] = [];
      }
      let obj = acc[curr.type];
      if (!obj) return acc;
      obj.push({
        value: curr.id,
        label: `${curr.name}`,
        hint: `${curr.description}`
      });
      return acc;
    },
    {}
  );
  const selectedIds = await p2.groupMultiselect({
    message: "Choose a scorer to add:",
    options: groupedScorers
  });
  if (p2.isCancel(selectedIds) || typeof selectedIds !== "object") {
    p2.log.info("Scorer selection cancelled.");
    return null;
  }
  if (!Array.isArray(selectedIds)) {
    return null;
  }
  const selectedScorers = selectedIds.map((scorerId) => {
    const foundScorer = AVAILABLE_SCORERS.find((s) => s.id === scorerId);
    return foundScorer;
  }).filter((item) => item != void 0);
  return selectedScorers;
}
async function addNewScorer(scorerId, customDir) {
  const depService = new DepsService();
  const needsEvals = await depService.checkDependencies(["@mastra/evals"]) !== `ok`;
  if (needsEvals) {
    await depService.installPackages(["@mastra/evals"]);
  }
  if (!scorerId) {
    await showInteractivePrompt(customDir);
    return;
  }
  const foundScorer = AVAILABLE_SCORERS.find((scorer) => scorer.id === scorerId.toLowerCase());
  if (!foundScorer) {
    p2.log.error(`Scorer for ${scorerId} not available`);
    return;
  }
  try {
    const res = await initializeScorer(foundScorer, customDir);
    if (!res.ok) {
      return;
    }
    p2.log.success(res.message);
    showSuccessNote();
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("Skipped")) {
      return p2.log.warning(errorMessage);
    }
    p2.log.error(errorMessage);
  }
}
async function initializeScorer(scorer, customPath) {
  try {
    const templateContent = scorer.content;
    const res = writeScorer(scorer.filename, templateContent, customPath);
    return res;
  } catch (error) {
    throw error;
  }
}
function showSuccessNote() {
  p2.note(`
        ${pc2.green("To use: Add the Scorer to your workflow or agent!")}
        `);
}
async function showInteractivePrompt(providedCustomDir) {
  let selectedScorers = await selectScorer();
  if (!selectedScorers) {
    return;
  }
  let customPath = providedCustomDir;
  if (!providedCustomDir) {
    const useCustomDir = await p2.confirm({
      message: `Would you like to use a custom directory?${pc2.gray("(Default: src/mastra/scorers)")}`,
      initialValue: false
    });
    if (p2.isCancel(useCustomDir)) {
      p2.log.info("Operation cancelled.");
      return;
    }
    if (useCustomDir) {
      const dirPath = await p2.text({
        message: "Enter the directory path (relative to project root):",
        placeholder: "src/scorers"
      });
      if (p2.isCancel(dirPath)) {
        p2.log.info("Operation cancelled.");
        return;
      }
      customPath = dirPath;
    }
  }
  const result = await Promise.allSettled(
    selectedScorers.map((scorer) => {
      return initializeScorer(scorer, customPath);
    })
  );
  result.forEach((op) => {
    if (op.status === "fulfilled") {
      p2.log.success(op.value.message);
      return;
    }
    const errorMessage = String(op.reason);
    const coreError = errorMessage.replace("Error:", "").trim();
    if (coreError.includes("Skipped")) {
      return p2.log.warning(coreError);
    }
    p2.log.error(coreError);
  });
  const containsSuccessfulWrites = result.some((item) => item.status === "fulfilled");
  if (containsSuccessfulWrites) {
    showSuccessNote();
  }
  return;
}

// src/commands/actions/add-scorer.ts
var origin = process.env.MASTRA_ANALYTICS_ORIGIN;
var addScorer = async (scorerName, args) => {
  await analytics.trackCommandExecution({
    command: "scorers-add",
    args: { ...args, scorerName },
    execution: async () => {
      await addNewScorer(scorerName, args.dir);
    },
    origin
  });
};
var BuildBundler = class extends Bundler {
  constructor() {
    super("Build");
  }
  getEnvFiles() {
    const possibleFiles = [".env.production", ".env.local", ".env"];
    try {
      const fileService = new FileService$2();
      const envFile = fileService.getFirstExistingFile(possibleFiles);
      return Promise.resolve([envFile]);
    } catch (err) {
    }
    return Promise.resolve([]);
  }
  async prepare(outputDirectory) {
    await super.prepare(outputDirectory);
  }
  async bundle(entryFile, outputDirectory, { toolsPaths, projectRoot }) {
    return this._bundle(this.getEntry(), entryFile, { outputDirectory, projectRoot }, toolsPaths);
  }
  getEntry() {
    return `
    // @ts-ignore
    import { evaluate } from '@mastra/core/eval';
    import { AvailableHooks, registerHook } from '@mastra/core/hooks';
    import { TABLE_EVALS } from '@mastra/core/storage';
    import { scoreTracesWorkflow } from '@mastra/core/scores/scoreTraces';
    import { checkEvalStorageFields } from '@mastra/core/utils';
    import { mastra } from '#mastra';
    import { createNodeServer, getToolExports } from '#server';
    import { tools } from '#tools';
    // @ts-ignore
    await createNodeServer(mastra, { tools: getToolExports(tools) });

    registerHook(AvailableHooks.ON_GENERATION, ({ input, output, metric, runId, agentName, instructions }) => {
      evaluate({
        agentName,
        input,
        metric,
        output,
        runId,
        globalRunId: runId,
        instructions,
      });
    });

    if (mastra.getStorage()) {
      // start storage init in the background
      mastra.getStorage().init();
      mastra.__registerInternalWorkflow(scoreTracesWorkflow);
    }

    registerHook(AvailableHooks.ON_EVALUATION, async traceObject => {
      const storage = mastra.getStorage();
      if (storage) {
        // Check for required fields
        const logger = mastra?.getLogger();
        const areFieldsValid = checkEvalStorageFields(traceObject, logger);
        if (!areFieldsValid) return;

        await storage.insert({
          tableName: TABLE_EVALS,
          record: {
            input: traceObject.input,
            output: traceObject.output,
            result: JSON.stringify(traceObject.result || {}),
            agent_name: traceObject.agentName,
            metric_name: traceObject.metricName,
            instructions: traceObject.instructions,
            test_info: null,
            global_run_id: traceObject.globalRunId,
            run_id: traceObject.runId,
            created_at: new Date().toISOString(),
          },
        });
      }
    });
    `;
  }
  async lint(entryFile, outputDirectory, toolsPaths) {
    await super.lint(entryFile, outputDirectory, toolsPaths);
  }
};
async function build({
  dir: dir2,
  tools,
  root,
  debug
}) {
  const rootDir = root || process.cwd();
  const mastraDir = dir2 ? dir2.startsWith("/") ? dir2 : join(rootDir, dir2) : join(rootDir, "src", "mastra");
  const outputDirectory = join(rootDir, ".mastra");
  const logger2 = createLogger(debug);
  const normalizedMastraDir = mastraDir.replaceAll("\\", "/");
  const defaultToolsPath = posix.join(normalizedMastraDir, "tools/**/*.{js,ts}");
  const defaultToolsIgnorePaths = [
    `!${posix.join(normalizedMastraDir, "tools/**/*.{test,spec}.{js,ts}")}`,
    `!${posix.join(normalizedMastraDir, "tools/**/__tests__/**")}`
  ];
  const defaultTools = [defaultToolsPath, ...defaultToolsIgnorePaths];
  const discoveredTools = [defaultTools, ...tools ?? []];
  try {
    const fs3 = new FileService();
    const mastraEntryFile = fs3.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
    const platformDeployer = await getDeployer(mastraEntryFile, outputDirectory);
    if (!platformDeployer) {
      const deployer = new BuildBundler();
      deployer.__setLogger(logger2);
      await deployer.prepare(outputDirectory);
      await deployer.bundle(mastraEntryFile, outputDirectory, {
        toolsPaths: discoveredTools,
        projectRoot: rootDir
      });
      logger2.info(`Build successful, you can now deploy the .mastra/output directory to your target platform.`);
      logger2.info(
        `To start the server, run: node --import=./.mastra/output/instrumentation.mjs .mastra/output/index.mjs`
      );
      return;
    }
    logger2.info("Deployer found, preparing deployer build...");
    platformDeployer.__setLogger(logger2);
    await platformDeployer.prepare(outputDirectory);
    await platformDeployer.bundle(mastraEntryFile, outputDirectory, {
      toolsPaths: discoveredTools,
      projectRoot: rootDir
    });
    logger2.info("You can now deploy the .mastra/output directory to your target platform.");
  } catch (error) {
    if (error instanceof MastraError) {
      const { message, ...details } = error.toJSONDetails();
      logger2.error(`${message}`, details);
    } else if (error instanceof Error) {
      logger2.error(`Mastra Build failed`, { error });
    }
    process.exit(1);
  }
}

// src/commands/actions/build-project.ts
var buildProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "mastra build",
    args,
    execution: async () => {
      await build({
        dir: args?.dir,
        root: args?.root,
        tools: args?.tools ? args.tools.split(",") : [],
        debug: args.debug
      });
    },
    origin: origin2
  });
};

// src/commands/actions/create-project.ts
var origin3 = process.env.MASTRA_ANALYTICS_ORIGIN;
var createProject = async (projectNameArg, args) => {
  const projectName = projectNameArg || args.projectName;
  await analytics.trackCommandExecution({
    command: "create",
    args: { ...args, projectName },
    execution: async () => {
      const timeout = args?.timeout ? args?.timeout === true ? 6e4 : parseInt(args?.timeout, 10) : void 0;
      if (args.default) {
        await create({
          components: ["agents", "tools", "workflows"],
          llmProvider: "openai",
          addExample: true,
          timeout,
          mcpServer: args.mcp,
          template: args.template
        });
        return;
      }
      await create({
        components: args.components ? args.components : [],
        llmProvider: args.llm,
        addExample: args.example,
        llmApiKey: args.llmApiKey,
        timeout,
        projectName,
        directory: args.dir,
        mcpServer: args.mcp,
        template: args.template
      });
    },
    origin: origin3
  });
};

// src/commands/actions/init-project.ts
var origin4 = process.env.MASTRA_ANALYTICS_ORIGIN;
var initProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "init",
    // @ts-expect-error: TODO - Fix this
    args,
    execution: async () => {
      await checkForPkgJson();
      await checkAndInstallCoreDeps(Boolean(args?.example || args?.default));
      if (!Object.keys(args).length) {
        const result = await interactivePrompt();
        await init({
          ...result,
          llmApiKey: result?.llmApiKey,
          components: ["agents", "tools", "workflows"],
          addExample: true
        });
        return;
      }
      if (args?.default) {
        await init({
          directory: "src/",
          components: ["agents", "tools", "workflows"],
          llmProvider: "openai",
          addExample: true,
          configureEditorWithDocsMCP: args.mcp
        });
        return;
      }
      const componentsArr = args.components ? args.components : [];
      await init({
        directory: args.dir,
        components: componentsArr,
        llmProvider: args.llm,
        addExample: args.example,
        llmApiKey: args.llmApiKey,
        configureEditorWithDocsMCP: args.mcp
      });
      return;
    },
    origin: origin4
  });
};

// src/commands/lint/rules/mastraCoreRule.ts
var mastraCoreRule = {
  name: "mastra-core",
  description: "Checks if @mastra/core is installed",
  async run(context) {
    const hasCore = context.mastraPackages.some((pkg) => pkg.name === "@mastra/core");
    if (!hasCore) {
      logger.error("@mastra/core is not installed. This package is required for Mastra to work properly.");
      return false;
    }
    return true;
  }
};
function readNextConfig(dir) {
  const nextConfigPath = join(dir, "next.config.js");
  try {
    const nextConfigContent = readFileSync(nextConfigPath, "utf-8");
    const configMatch = nextConfigContent.match(/const nextConfig = ({[\s\S]*?});/);
    if (!configMatch?.[1]) {
      return null;
    }
    const configStr = configMatch[1].replace(/\n/g, "").replace(/\s+/g, " ");
    return eval(`(${configStr})`);
  } catch {
    return null;
  }
}
function isNextJsProject(dir2) {
  const nextConfigPath2 = join(dir2, "next.config.js");
  try {
    readFileSync(nextConfigPath2, "utf-8");
    return true;
  } catch {
    return false;
  }
}
var nextConfigRule = {
  name: "next-config",
  description: "Checks if Next.js config is properly configured for Mastra packages",
  async run(context) {
    if (!isNextJsProject(context.rootDir)) {
      return true;
    }
    const nextConfig = readNextConfig(context.rootDir);
    if (!nextConfig) {
      return false;
    }
    const serverExternals = nextConfig.serverExternalPackages || [];
    const hasMastraExternals = serverExternals.some(
      (pkg) => pkg === "@mastra/*" || pkg === "@mastra/core" || pkg.startsWith("@mastra/")
    );
    if (!hasMastraExternals) {
      logger.error("next.config.js is missing Mastra packages in serverExternalPackages");
      logger.error("Please add the following to your next.config.js:");
      logger.error('  serverExternalPackages: ["@mastra/*"],');
      return false;
    }
    logger.info("Next.js config is properly configured for Mastra packages");
    return true;
  }
};
function readTsConfig(dir2) {
  const tsConfigPath = join(dir2, "tsconfig.json");
  try {
    const tsConfigContent = readFileSync(tsConfigPath, "utf-8");
    const cleanTsConfigContent = stripJsonComments(tsConfigContent);
    return JSON.parse(cleanTsConfigContent);
  } catch {
    return null;
  }
}
var tsConfigRule = {
  name: "ts-config",
  description: "Checks if TypeScript config is properly configured for Mastra packages",
  async run(context) {
    const tsConfig = readTsConfig(context.rootDir);
    if (!tsConfig) {
      logger.warn("No tsconfig.json found. This might cause issues with Mastra packages.");
      return true;
    }
    const { module, moduleResolution } = tsConfig.compilerOptions || {};
    const isValidConfig = moduleResolution === "bundler" || module === "CommonJS";
    if (!isValidConfig) {
      logger.error("tsconfig.json has invalid configuration");
      logger.error("Please set either:");
      logger.error('  "compilerOptions": {');
      logger.error('    "moduleResolution": "bundler"');
      logger.error("  }");
      logger.error("or");
      logger.error('  "compilerOptions": {');
      logger.error('    "module": "CommonJS"');
      logger.error("  }");
      logger.error("For the recommended TypeScript configuration, see:");
      logger.error("https://mastra.ai/en/docs/getting-started/installation#initialize-typescript");
      return false;
    }
    logger.info("TypeScript config is properly configured for Mastra packages");
    return true;
  }
};

// src/commands/lint/rules/index.ts
var rules = [nextConfigRule, tsConfigRule, mastraCoreRule];

// src/commands/lint/index.ts
function readPackageJson(dir2) {
  const packageJsonPath = join(dir2, "package.json");
  try {
    const packageJsonContent = readFileSync(packageJsonPath, "utf-8");
    return JSON.parse(packageJsonContent);
  } catch (error) {
    if (error instanceof Error) {
      logger.error(`Failed to read package.json: ${error.message}`);
    }
    throw error;
  }
}
function getMastraPackages(packageJson) {
  const allDependencies = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  };
  const mastraPackages = Object.entries(allDependencies).filter(
    ([name]) => name.startsWith("@mastra/") || name === "mastra"
  );
  return mastraPackages.map(([name, version2]) => ({
    name,
    version: version2,
    isAlpha: version2.includes("alpha")
  }));
}
async function lint({ dir: dir2, root, tools }) {
  try {
    const rootDir = root || process.cwd();
    const mastraDir = dir2 ? dir2.startsWith("/") ? dir2 : join(process.cwd(), dir2) : join(process.cwd(), "src", "mastra");
    const outputDirectory = join(rootDir, ".mastra");
    const defaultToolsPath = join(mastraDir, "tools");
    const discoveredTools = [defaultToolsPath, ...tools ?? []];
    const packageJson = readPackageJson(rootDir);
    const mastraPackages = getMastraPackages(packageJson);
    const context = {
      rootDir,
      mastraDir,
      outputDirectory,
      discoveredTools,
      packageJson,
      mastraPackages
    };
    const results = await Promise.all(rules.map((rule) => rule.run(context)));
    const allRulesPassed = results.every((result) => result);
    if (allRulesPassed) {
      const fileService = new FileService();
      const mastraEntryFile = fileService.getFirstExistingFile([
        join(mastraDir, "index.ts"),
        join(mastraDir, "index.js")
      ]);
      const platformDeployer = await getDeployer(mastraEntryFile, outputDirectory);
      if (!platformDeployer) {
        const deployer = new BuildBundler();
        await deployer.lint(mastraEntryFile, outputDirectory, discoveredTools);
      } else {
        await platformDeployer.lint(mastraEntryFile, outputDirectory, discoveredTools);
      }
    }
    return allRulesPassed;
  } catch (error) {
    if (error instanceof Error) {
      logger.error(`Lint check failed: ${error.message}`);
    }
    return false;
  }
}

// src/commands/actions/lint-project.ts
var lintProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "lint",
    args,
    execution: async () => {
      await lint({ dir: args.dir, root: args.root, tools: args.tools ? args.tools.split(",") : [] });
    },
    origin: origin2
  });
};
function formatCategoryName(category) {
  return category.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
}
function formatTable(scorers) {
  if (scorers.length === 0) return "";
  const nameWidth = Math.max(4, Math.max(...scorers.map((s) => s.name.length)));
  const idWidth = Math.max(2, Math.max(...scorers.map((s) => s.id.length)));
  const typeWidth = Math.max(4, Math.max(...scorers.map((s) => s.type.length)));
  const descWidth = Math.max(11, Math.max(...scorers.map((s) => s.description.length)));
  const header = `${pc2.bold("Name".padEnd(nameWidth))} \u2502 ${pc2.bold("ID".padEnd(idWidth))} \u2502 ${pc2.bold("Type".padEnd(typeWidth))} \u2502 ${pc2.bold("Description".padEnd(descWidth))}`;
  const separator = "\u2500".repeat(nameWidth) + "\u2500\u253C\u2500" + "\u2500".repeat(idWidth) + "\u2500\u253C\u2500" + "\u2500".repeat(typeWidth) + "\u2500\u253C\u2500" + "\u2500".repeat(descWidth) + "\u2500";
  const rows = scorers.map(
    (scorer) => `${scorer.name.padEnd(nameWidth)} \u2502 ${pc2.dim(scorer.id.padEnd(idWidth))} \u2502 ${scorer.type.padEnd(typeWidth)} \u2502 ${pc2.dim(scorer.description.padEnd(descWidth))}`
  );
  return [header, separator, ...rows].join("\n");
}
function listAllScorers() {
  p2.intro(pc2.inverse(" Available Scorers "));
  const groupedScorers = AVAILABLE_SCORERS.reduce(
    (acc, scorer) => {
      if (!acc[scorer.category]) {
        acc[scorer.category] = [];
      }
      acc[scorer.category].push(scorer);
      return acc;
    },
    {}
  );
  for (const [category, scorers] of Object.entries(groupedScorers)) {
    p2.log.info(`${pc2.bold(pc2.cyan(formatCategoryName(category)))} Scorers:`);
    p2.log.message(formatTable(scorers));
  }
}

// src/commands/actions/list-scorers.ts
var origin5 = process.env.MASTRA_ANALYTICS_ORIGIN;
var listScorers = async (args) => {
  await analytics.trackCommandExecution({
    command: "scorers-list",
    args,
    execution: async () => {
      return listAllScorers();
    },
    origin: origin5
  });
};
var DevLogger = class {
  options;
  constructor(options = {}) {
    this.options = {
      timestamp: false,
      colors: true,
      ...options
    };
  }
  formatTime() {
    if (!this.options.timestamp) return "";
    return pc2.dim((/* @__PURE__ */ new Date()).toLocaleTimeString());
  }
  formatPrefix(text2, color2) {
    const time = this.formatTime();
    const prefix = pc2.bold(color2(text2));
    return time ? `${time} ${prefix}` : prefix;
  }
  info(message) {
    const prefix = this.formatPrefix("\u25D0", pc2.cyan);
    console.info(`${prefix} ${message}`);
  }
  success(message) {
    const prefix = this.formatPrefix("\u2713", pc2.green);
    console.info(`${prefix} ${pc2.green(message)}`);
  }
  warn(message) {
    const prefix = this.formatPrefix("\u26A0", pc2.yellow);
    console.info(`${prefix} ${pc2.yellow(message)}`);
  }
  error(message) {
    const prefix = this.formatPrefix("\u2717", pc2.red);
    console.info(`${prefix} ${pc2.red(message)}`);
  }
  starting() {
    const prefix = this.formatPrefix("\u25C7", pc2.blue);
    console.info(`${prefix} ${pc2.blue("Starting Mastra dev server...")}`);
  }
  ready(host, port, startTime, https) {
    let protocol = "http";
    if (https && https.key && https.cert) {
      protocol = "https";
    }
    console.info("");
    const timing = startTime ? `${Date.now() - startTime} ms` : "XXX ms";
    console.info(pc2.inverse(pc2.green(" mastra ")) + ` ${pc2.green(version)} ${pc2.gray("ready in")} ${timing}`);
    console.info("");
    console.info(`${pc2.dim("\u2502")} ${pc2.bold("Playground:")} ${pc2.cyan(`${protocol}://${host}:${port}/`)}`);
    console.info(`${pc2.dim("\u2502")} ${pc2.bold("API:")}        ${`${protocol}://${host}:${port}/api`}`);
    console.info("");
  }
  bundling() {
    const prefix = this.formatPrefix("\u25D0", pc2.magenta);
    console.info(`${prefix} ${pc2.magenta("Bundling...")}`);
  }
  bundleComplete() {
    const prefix = this.formatPrefix("\u2713", pc2.green);
    console.info(`${prefix} ${pc2.green("Bundle complete")}`);
  }
  watching() {
    const time = this.formatTime();
    const icon = pc2.dim("\u25EF");
    const message = pc2.dim("watching for file changes...");
    const fullMessage = `${icon} ${message}`;
    console.info(time ? `${time} ${fullMessage}` : fullMessage);
  }
  restarting() {
    const prefix = this.formatPrefix("\u21BB", pc2.blue);
    console.info(`${prefix} ${pc2.blue("Restarting server...")}`);
  }
  fileChange(file) {
    const prefix = this.formatPrefix("\u26A1", pc2.cyan);
    const fileName = path.basename(file);
    console.info(`${prefix} ${pc2.cyan("File changed:")} ${pc2.dim(fileName)}`);
  }
  // Enhanced error reporting
  serverError(error) {
    console.info("");
    console.info(pc2.red("  \u2717 ") + pc2.bold(pc2.red("Server Error")));
    console.info("");
    console.info(`  ${pc2.red("\u2502")} ${error}`);
    console.info("");
  }
  shutdown() {
    console.info("");
    const prefix = this.formatPrefix("\u2713", pc2.green);
    console.info(`${prefix} ${pc2.green("Dev server stopped")}`);
  }
  envInfo(info) {
    console.info("");
    console.info(`  ${pc2.dim("\u2502")} ${pc2.bold("Environment:")} ${pc2.cyan(info.env || "development")}`);
    console.info(`  ${pc2.dim("\u2502")} ${pc2.bold("Root:")} ${pc2.dim(info.root)}`);
    console.info(`  ${pc2.dim("\u2502")} ${pc2.bold("Port:")} ${pc2.cyan(info.port.toString())}`);
  }
  raw(message) {
    console.info(message);
  }
  debug(message) {
    if (process.env.DEBUG || process.env.MASTRA_DEBUG) {
      const prefix = this.formatPrefix("\u25E6", pc2.gray);
      console.info(`${prefix} ${pc2.gray(message)}`);
    }
  }
  spinnerChars = ["\u25D0", "\u25D3", "\u25D1", "\u25D2"];
  spinnerIndex = 0;
  getSpinnerChar() {
    const char = this.spinnerChars[this.spinnerIndex];
    this.spinnerIndex = (this.spinnerIndex + 1) % this.spinnerChars.length;
    return char || "\u25D0";
  }
  clearLine() {
    process.stdout.write("\r\x1B[K");
  }
  update(message) {
    this.clearLine();
    const prefix = this.formatPrefix(this.getSpinnerChar(), pc2.cyan);
    process.stdout.write(`${prefix} ${message}`);
  }
};
var devLogger = new DevLogger();
var DevBundler = class extends Bundler {
  customEnvFile;
  constructor(customEnvFile) {
    super("Dev");
    this.customEnvFile = customEnvFile;
  }
  getEnvFiles() {
    const possibleFiles = [".env.development", ".env.local", ".env"];
    if (this.customEnvFile) {
      possibleFiles.unshift(this.customEnvFile);
    }
    try {
      const fileService = new FileService$1();
      const envFile = fileService.getFirstExistingFile(possibleFiles);
      return Promise.resolve([envFile]);
    } catch {
    }
    return Promise.resolve([]);
  }
  async prepare(outputDirectory) {
    await super.prepare(outputDirectory);
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const playgroundServePath = join(outputDirectory, this.outputDir, "playground");
    await fsExtra.copy(join(dirname(__dirname), "dist/playground"), playgroundServePath, {
      overwrite: true
    });
  }
  async watch(entryFile, outputDirectory, toolsPaths) {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const envFiles = await this.getEnvFiles();
    let sourcemapEnabled = false;
    try {
      const bundlerOptions = await getBundlerOptions(entryFile, outputDirectory);
      sourcemapEnabled = !!bundlerOptions?.sourcemap;
    } catch (error) {
      this.logger.debug("Failed to get bundler options, sourcemap will be disabled", { error });
    }
    const inputOptions = await getWatcherInputOptions(
      entryFile,
      "node",
      {
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "development")
      },
      { sourcemap: sourcemapEnabled }
    );
    const toolsInputOptions = await this.getToolsInputOptions(toolsPaths);
    const outputDir = join(outputDirectory, this.outputDir);
    await writeTelemetryConfig(entryFile, outputDir, this.logger);
    const mastraFolder = dirname(entryFile);
    const fileService = new FileService$1();
    const customInstrumentation = fileService.getFirstExistingFileOrUndefined([
      join(mastraFolder, "instrumentation.js"),
      join(mastraFolder, "instrumentation.ts"),
      join(mastraFolder, "instrumentation.mjs")
    ]);
    await this.writeInstrumentationFile(outputDir, customInstrumentation);
    await this.writePackageJson(outputDir, /* @__PURE__ */ new Map(), {});
    const copyPublic = this.copyPublic.bind(this);
    const watcher = await createWatcher(
      {
        ...inputOptions,
        logLevel: inputOptions.logLevel === "silent" ? "warn" : inputOptions.logLevel,
        onwarn: (warning) => {
          if (warning.code === "CIRCULAR_DEPENDENCY") {
            if (warning.ids?.[0]?.includes("node_modules")) {
              return;
            }
            this.logger.warn(`Circular dependency found:
	${warning.message.replace("Circular dependency: ", "")}`);
          }
        },
        plugins: [
          // @ts-ignore - types are good
          // eslint-disable-next-line @typescript-eslint/no-misused-promises
          ...inputOptions.plugins,
          {
            name: "env-watcher",
            buildStart() {
              for (const envFile of envFiles) {
                this.addWatchFile(envFile);
              }
            }
          },
          {
            name: "public-dir-watcher",
            buildStart() {
              this.addWatchFile(join(dirname(entryFile), "public"));
            },
            buildEnd() {
              return copyPublic(dirname(entryFile), outputDirectory);
            }
          },
          {
            name: "tools-watcher",
            async buildEnd() {
              const toolImports = [];
              const toolsExports = [];
              Array.from(Object.keys(toolsInputOptions || {})).filter((key) => key.startsWith("tools/")).forEach((key, index) => {
                const toolExport = `tool${index}`;
                toolImports.push(`import * as ${toolExport} from './${key}.mjs';`);
                toolsExports.push(toolExport);
              });
              await writeFile(
                join(outputDir, "tools.mjs"),
                `${toolImports.join("\n")}
        
                export const tools = [${toolsExports.join(", ")}]`
              );
            }
          }
        ],
        input: {
          index: join(__dirname, "templates", "dev.entry.js"),
          ...toolsInputOptions
        }
      },
      {
        dir: outputDir,
        sourcemap: sourcemapEnabled
      }
    );
    devLogger.info("Preparing development environment...");
    return new Promise((resolve, reject) => {
      const cb = (event) => {
        if (event.code === "BUNDLE_END") {
          devLogger.success("Initial bundle complete");
          watcher.off("event", cb);
          resolve(watcher);
        }
        if (event.code === "ERROR") {
          console.info(event);
          devLogger.error("Bundling failed - check console for details");
          watcher.off("event", cb);
          reject(event);
        }
      };
      watcher.on("event", cb);
    });
  }
  async bundle() {
  }
};

// src/commands/dev/dev.ts
var currentServerProcess;
var isRestarting = false;
var serverStartTime;
var ON_ERROR_MAX_RESTARTS = 3;
var startServer = async (dotMastraPath, {
  port,
  host
}, env, startOptions = {}, errorRestartCount = 0) => {
  let serverIsReady = false;
  try {
    serverStartTime = Date.now();
    devLogger.starting();
    const commands = [];
    if (startOptions.inspect) {
      commands.push("--inspect");
    }
    if (startOptions.inspectBrk) {
      commands.push("--inspect-brk");
    }
    if (startOptions.customArgs) {
      commands.push(...startOptions.customArgs);
    }
    if (!isWebContainer()) {
      const instrumentation = import.meta.resolve("@opentelemetry/instrumentation/hook.mjs");
      commands.push(
        `--import=${import.meta.resolve("mastra/telemetry-loader")}`,
        "--import=./instrumentation.mjs",
        `--import=${instrumentation}`
      );
    }
    commands.push("index.mjs");
    currentServerProcess = execa(process2.execPath, commands, {
      cwd: dotMastraPath,
      env: {
        NODE_ENV: "production",
        ...Object.fromEntries(env),
        MASTRA_DEV: "true",
        PORT: port.toString(),
        MASTRA_DEFAULT_STORAGE_URL: `file:${join(dotMastraPath, "..", "mastra.db")}`,
        ...startOptions?.https ? {
          MASTRA_HTTPS_KEY: startOptions.https.key.toString("base64"),
          MASTRA_HTTPS_CERT: startOptions.https.cert.toString("base64")
        } : {}
      },
      stdio: ["inherit", "pipe", "pipe", "ipc"],
      reject: false
    });
    if (currentServerProcess?.exitCode && currentServerProcess?.exitCode !== 0) {
      if (!currentServerProcess) {
        throw new Error(`Server failed to start`);
      }
      throw new Error(
        `Server failed to start with error: ${currentServerProcess.stderr || currentServerProcess.stdout}`
      );
    }
    if (currentServerProcess.stdout) {
      currentServerProcess.stdout.on("data", (data) => {
        const output = data.toString();
        if (!output.includes("Playground available") && !output.includes("\u{1F468}\u200D\u{1F4BB}") && !output.includes("Mastra API running on port")) {
          process2.stdout.write(output);
        }
      });
    }
    if (currentServerProcess.stderr) {
      currentServerProcess.stderr.on("data", (data) => {
        const output = data.toString();
        if (!output.includes("Playground available") && !output.includes("\u{1F468}\u200D\u{1F4BB}") && !output.includes("Mastra API running on port")) {
          process2.stderr.write(output);
        }
      });
    }
    currentServerProcess.on("error", (err) => {
      if (err.code !== "EPIPE") {
        throw err;
      }
    });
    currentServerProcess.on("message", async (message) => {
      if (message?.type === "server-ready") {
        serverIsReady = true;
        devLogger.ready(host, port, serverStartTime, startOptions.https);
        devLogger.watching();
        try {
          await fetch(`http://${host}:${port}/__refresh`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            }
          });
        } catch {
          await new Promise((resolve) => setTimeout(resolve, 1500));
          try {
            await fetch(`http://${host}:${port}/__refresh`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              }
            });
          } catch {
          }
        }
      }
    });
  } catch (err) {
    const execaError = err;
    if (execaError.stderr) {
      devLogger.serverError(execaError.stderr);
      devLogger.debug(`Server error output: ${execaError.stderr}`);
    }
    if (execaError.stdout) devLogger.debug(`Server output: ${execaError.stdout}`);
    if (!serverIsReady) {
      throw err;
    }
    setTimeout(() => {
      if (!isRestarting) {
        errorRestartCount++;
        if (errorRestartCount > ON_ERROR_MAX_RESTARTS) {
          devLogger.error(`Server failed to start after ${ON_ERROR_MAX_RESTARTS} error attempts. Giving up.`);
          process2.exit(1);
        }
        devLogger.warn(
          `Attempting to restart server after error... (Attempt ${errorRestartCount}/${ON_ERROR_MAX_RESTARTS})`
        );
        startServer(
          dotMastraPath,
          {
            port,
            host
          },
          env,
          startOptions,
          errorRestartCount
        );
      }
    }, 1e3);
  }
};
async function checkAndRestart(dotMastraPath, {
  port,
  host
}, bundler, startOptions = {}) {
  if (isRestarting) {
    return;
  }
  try {
    const response = await fetch(`http://${host}:${port}/__hot-reload-status`);
    if (response.ok) {
      const status = await response.json();
      if (status.disabled) {
        devLogger.info("[Mastra Dev] - \u23F8\uFE0F  Server restart skipped: agent builder action in progress");
        return;
      }
    }
  } catch (error) {
    devLogger.debug(`[Mastra Dev] - Could not check hot reload status: ${error}`);
  }
  devLogger.info("[Mastra Dev] - \u2705 Restarting server...");
  await rebundleAndRestart(dotMastraPath, { port, host }, bundler, startOptions);
}
async function rebundleAndRestart(dotMastraPath, {
  port,
  host
}, bundler, startOptions = {}) {
  if (isRestarting) {
    return;
  }
  isRestarting = true;
  try {
    if (currentServerProcess) {
      devLogger.restarting();
      devLogger.debug("Stopping current server...");
      currentServerProcess.kill("SIGINT");
    }
    const env = await bundler.loadEnvVars();
    for (const [key, value] of env.entries()) {
      process2.env[key] = value;
    }
    await startServer(
      join(dotMastraPath, "output"),
      {
        port,
        host
      },
      env,
      startOptions
    );
  } finally {
    isRestarting = false;
  }
}
async function dev({
  dir: dir2,
  root,
  tools,
  env,
  inspect,
  inspectBrk,
  customArgs,
  https,
  debug
}) {
  const rootDir = root || process2.cwd();
  const mastraDir = dir2 ? dir2.startsWith("/") ? dir2 : join(process2.cwd(), dir2) : join(process2.cwd(), "src", "mastra");
  const dotMastraPath = join(rootDir, ".mastra");
  const normalizedMastraDir = mastraDir.replaceAll("\\", "/");
  const defaultToolsPath = posix.join(normalizedMastraDir, "tools/**/*.{js,ts}");
  const defaultToolsIgnorePaths = [
    `!${posix.join(normalizedMastraDir, "tools/**/*.{test,spec}.{js,ts}")}`,
    `!${posix.join(normalizedMastraDir, "tools/**/__tests__/**")}`
  ];
  const defaultTools = [defaultToolsPath, ...defaultToolsIgnorePaths];
  const discoveredTools = [defaultTools, ...tools ?? []];
  const fileService = new FileService$1();
  const entryFile = fileService.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
  const bundler = new DevBundler(env);
  bundler.__setLogger(createLogger(debug));
  const loadedEnv = await bundler.loadEnvVars();
  for (const [key, value] of loadedEnv.entries()) {
    process2.env[key] = value;
  }
  const serverOptions = await getServerOptions(entryFile, join(dotMastraPath, "output"));
  let portToUse = serverOptions?.port ?? process2.env.PORT;
  let hostToUse = serverOptions?.host ?? process2.env.HOST ?? "localhost";
  if (!portToUse || isNaN(Number(portToUse))) {
    const portList = Array.from({ length: 21 }, (_, i) => 4111 + i);
    portToUse = String(
      await getPort({
        port: portList
      })
    );
  }
  let httpsOptions = void 0;
  if (https && serverOptions?.https) {
    devLogger.warn("--https flag and server.https config are both specified. Using server.https config.");
  }
  if (serverOptions?.https) {
    httpsOptions = serverOptions.https;
  } else if (https) {
    const { key, cert } = await devcert.certificateFor(serverOptions?.host ?? "localhost");
    httpsOptions = { key, cert };
  }
  const startOptions = { inspect, inspectBrk, customArgs, https: httpsOptions };
  await bundler.prepare(dotMastraPath);
  const watcher = await bundler.watch(entryFile, dotMastraPath, discoveredTools);
  await startServer(
    join(dotMastraPath, "output"),
    {
      port: Number(portToUse),
      host: hostToUse
    },
    loadedEnv,
    startOptions
  );
  watcher.on("event", (event) => {
    if (event.code === "BUNDLE_START") {
      devLogger.bundling();
    }
    if (event.code === "BUNDLE_END") {
      devLogger.bundleComplete();
      devLogger.info("[Mastra Dev] - Bundling finished, checking if restart is allowed...");
      checkAndRestart(
        dotMastraPath,
        {
          port: Number(portToUse),
          host: hostToUse
        },
        bundler,
        startOptions
      );
    }
  });
  process2.on("SIGINT", () => {
    devLogger.shutdown();
    if (currentServerProcess) {
      currentServerProcess.kill();
    }
    watcher.close().catch(() => {
    }).finally(() => process2.exit(0));
  });
}

// src/commands/actions/start-dev-server.ts
var startDevServer = async (args) => {
  analytics.trackCommand({
    command: "dev",
    origin: origin2
  });
  dev({
    dir: args?.dir,
    root: args?.root,
    tools: args?.tools ? args.tools.split(",") : [],
    env: args?.env,
    inspect: args?.inspect && !args?.inspectBrk,
    inspectBrk: args?.inspectBrk,
    customArgs: args?.customArgs ? args.customArgs.split(",") : [],
    https: args?.https,
    debug: args.debug
  }).catch((err) => {
    logger.error(err.message);
  });
};
async function start(options = {}) {
  config({ path: [options.env || ".env.production", ".env"] });
  const outputDir = options.dir || ".mastra/output";
  const telemetry = options.telemetry ?? true;
  try {
    const outputPath = join(process.cwd(), outputDir);
    if (!fs.existsSync(outputPath)) {
      throw new Error(`Output directory ${outputPath} does not exist`);
    }
    const commands = [];
    if (telemetry && !isWebContainer()) {
      const instrumentation = "@opentelemetry/instrumentation/hook.mjs";
      commands.push("--import=./instrumentation.mjs", `--import=${instrumentation}`);
    }
    commands.push("index.mjs");
    const server = spawn("node", commands, {
      cwd: outputPath,
      stdio: "inherit",
      env: {
        ...process.env,
        NODE_ENV: "production"
      }
    });
    server.on("error", (err) => {
      logger.error(`Failed to start server: ${err.message}`);
      process.exit(1);
    });
    process.on("SIGINT", () => {
      server.kill("SIGINT");
      process.exit(0);
    });
    process.on("SIGTERM", () => {
      server.kill("SIGTERM");
      process.exit(0);
    });
  } catch (error) {
    logger.error(`Failed to start Mastra server: ${error.message}`);
    process.exit(1);
  }
}

// src/commands/actions/start-project.ts
var startProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "start",
    args,
    execution: async () => {
      await start({
        dir: args.dir,
        telemetry: args.telemetry,
        env: args.env
      });
    },
    origin: origin2
  });
};

// src/index.ts
var mastraPkg = package_default;
var version = mastraPkg.version;
var analytics = new PosthogAnalytics({
  apiKey: "phc_SBLpZVAB6jmHOct9CABq3PF0Yn5FU3G2FgT4xUr2XrT",
  host: "https://us.posthog.com",
  version
});
setAnalytics(analytics);
var program = new Command();
var origin2 = process.env.MASTRA_ANALYTICS_ORIGIN;
program.name("mastra").version(`${version}`, "-v, --version").addHelpText(
  "before",
  `
${pc2.bold(pc2.cyan("Mastra"))} is a typescript framework for building AI applications, agents, and workflows.
`
).action(() => {
  program.help();
});
program.command("create [project-name]").description("Create a new Mastra project").option("--default", "Quick start with defaults(src, OpenAI, examples)").option(
  "-c, --components <components>",
  `Comma-separated list of components (${COMPONENTS.join(", ")})`,
  parseComponents
).option("-l, --llm <model-provider>", `Default model provider (${LLMProvider.join(", ")})`, parseLlmProvider).option("-k, --llm-api-key <api-key>", "API key for the model provider").option("-e, --example", "Include example code").option("-n, --no-example", "Do not include example code").option("-t, --timeout [timeout]", "Configurable timeout for package installation, defaults to 60000 ms").option("-d, --dir <directory>", "Target directory for Mastra source code (default: src/)").option(
  "-p, --project-name <string>",
  "Project name that will be used in package.json and as the project directory name."
).option("-m, --mcp <editor>", "MCP Server for code editor (cursor, cursor-global, windsurf, vscode)", parseMcp).option(
  "--template [template-name]",
  "Create project from a template (use template name, public GitHub URL, or leave blank to select from list)"
).action(createProject);
program.command("init").description("Initialize Mastra in your project").option("--default", "Quick start with defaults(src, OpenAI, examples)").option("-d, --dir <directory>", "Directory for Mastra files to (defaults to src/)").option(
  "-c, --components <components>",
  `Comma-separated list of components (${COMPONENTS.join(", ")})`,
  parseComponents
).option("-l, --llm <model-provider>", `Default model provider (${LLMProvider.join(", ")})`, parseLlmProvider).option("-k, --llm-api-key <api-key>", "API key for the model provider").option("-e, --example", "Include example code").option("-n, --no-example", "Do not include example code").option("-m, --mcp <editor>", "MCP Server for code editor (cursor, cursor-global, windsurf, vscode)", parseMcp).action(initProject);
program.command("lint").description("Lint your Mastra project").option("-d, --dir <path>", "Path to your Mastra folder").option("-r, --root <path>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").action(lintProject);
program.command("dev").description("Start mastra server").option("-d, --dir <dir>", "Path to your mastra folder").option("-r, --root <root>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").option("-e, --env <env>", "Custom env file to include in the dev server").option("-i, --inspect", "Start the dev server in inspect mode").option("-b, --inspect-brk", "Start the dev server in inspect mode and break at the beginning of the script").option(
  "-c, --custom-args <args>",
  "Comma-separated list of custom arguments to pass to the dev server. IE: --experimental-transform-types"
).option("-s, --https", "Enable local HTTPS").option("--debug", "Enable debug logs", false).action(startDevServer);
program.command("build").description("Build your Mastra project").option("-d, --dir <path>", "Path to your Mastra Folder").option("-r, --root <path>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").option("--debug", "Enable debug logs", false).action(buildProject);
program.command("start").description("Start your built Mastra application").option("-d, --dir <path>", "Path to your built Mastra output directory (default: .mastra/output)").option("-e, --env <env>", "Custom env file to include in the start").option("-nt, --no-telemetry", "Disable telemetry on start").action(startProject);
var scorersCommand = program.command("scorers").description("Manage scorers for evaluating AI outputs");
scorersCommand.command("add [scorer-name]").description("Add a new scorer to your project").option("-d, --dir <path>", "Path to your Mastra directory (default: auto-detect)").action(addScorer);
scorersCommand.command("list").description("List available scorer templates").action(listScorers);
program.parse(process.argv);

export { analytics, origin2 as origin, version };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map